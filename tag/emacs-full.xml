<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="../feed.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
<title>Susam's Emacs Pages</title>
<link>https://susam.net/tag/emacs.html</link>
<atom:link rel="self" type="application/rss+xml" href="https://susam.net/tag/emacs-full.xml"/>
<description>Feed for Susam's Emacs Pages</description>

<item>
<title>Emacs Info Expressions</title>
<link>https://susam.net/emacs-info-expression.html</link>
<guid isPermaLink="false">eminf</guid>
<pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  On <code>#emacs</code> IRC or Matrix channels, we often share
  references to the built-in Emacs documentation as Elisp expressions
  that look like this:
</p>
<pre><code>(info "(emacs) Basic Undo")</code></pre>
<p>
  Here is another example:
</p>
<pre><code>(info "(emacs) Word Search")</code></pre>
<p>
  This is a common practice in the Emacs community even though all of
  the Emacs manual is available on the World Wide Web too.  For
  example, the section referred to in the above expression eis
  available
  here: <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Word-Search.html">GNU
  Emacs Manual: Word Search</a>.  The reason for sharing Elisp
  expressions like this is likely partly tradition and partly
  convenience.  Many Emacs users are logged into IRC networks via
  Emacs itself, so once the recipient sees an Elisp expression like
  the above one in their chat buffer, visiting the corresponding
  manual page is a simple matter of placing the cursor right after the
  closing parenthesis and typing <code>C-x C-e</code>.
</p>
<p>
  But isn't it clumsy for the sender to type Elisp expressions like
  this merely to share a pointer to a section of a manual with others?
  Turns out, it is not.  This is Emacs!  So of course there are
  key-bindings to do this.
</p>
<p>
  Say, while helping another Emacs user we type <code>M-x info-apropos
  RET version control RET</code> and land on the section "Branches"
  and realise that this is the section that the person we are trying
  to help should read.  Now when we are on this section, we can simply
  type <code>c</code> and Emacs will copy the name of the current Info
  node to the kill ring.  The name looks like this:
</p>
<pre><code>(emacs) Branches</code></pre>
<p>
  While this is handy in some situations, it isn't the
  <code>info</code> expression we want.  It's just the Info node name.
  To copy the complete <code>info</code> expression with the node
  name, we need to use the zero prefix argument with
  the <code>c</code> key.  So when we are on the section "Branches",
  if we type <code>C-0 c</code>, the following expression is copied to
  the kill ring:
</p>
<pre><code>(info "(emacs) Branches")</code></pre>
<p>
  The person who receives this <code>info</code> expression can visit
  the corresponding section of the manual simply by evaluating it.
  For example, after copying the expression in Emacs, they could
  type <code>C-y C-x C-e</code> to paste the expression into a buffer
  and evaluate it immediately.  Alternatively, they might want to
  type <code>M-: C-y RET</code> to bring the
  <code>eval-expression</code> minibuffer, paste the expression there
  and evaluate it.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/emacs-info-expression.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a>
</p>
]]>
</description>
</item>
<item>
<title>Elisp in Replacement String</title>
<link>https://susam.net/elisp-in-replacement-string.html</link>
<guid isPermaLink="false">rmcte</guid>
<pubDate>Tue, 09 Jan 2024 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  It is likely well known among Emacs users that the following key
  sequence starts a search-and-replace operation to match strings with
  the regular expression pattern <code>f..</code> and replace the
  matches with <code>bar</code>.
</p>
<pre><code>C-M-% f.. RET bar RET</code></pre>
<p>
  Similarly, the following key sequence looks for strings that match a
  pattern that has two capturing groups and replaces each match with a
  new string that swaps the substrings matched by the capturing
  groups:
</p>
<pre><code>C-M-% \(f..\)-\(b..\) RET \2-\1</code></pre>
<p>
  For example, this operation matches a string
  like <code>foo-bar</code> and replaces it with <code>bar-foo</code>.
  A string like <code>postfix-boxing</code> becomes
  <code>postbox-fixing</code>.  The backreference <code>\1</code>
  refers to the string matched by the first capturing
  group <code>\(f..\)</code> and similarly <code>\2</code> refers to
  the string matched by the second capturing
  group <code>\(b..\)</code>.  The replacement string then swaps the
  positions of the matches in both capturing groups.
</p>
<p>
  What may be less commonly known is the ability to utilise Elisp
  expressions to dynamically compute portions of the replacement
  strings.  To employ this feature, simply write <code>\,</code>
  (i.e. backslash and comma) followed by the Elisp expression in the
  replacement string.  Consider the following key sequence:
</p>
<pre><code>C-M-% f.. RET \,(upcase \&amp;) RET</code></pre>
<p>
  The backreference <code>\&amp;</code> refers to the whole match.  We
  pass it as the argument to the Elisp function <code>upcase</code>.
  This function converts its argument to upper-case.  This example
  searches for strings that match the pattern <code>f..</code> and
  replaces each match with the upper-case form of the match.  A string
  like <code>foo-bar</code> is replaced with <code>FOO-bar</code>.
</p>
<p>
  Here is another slightly more sophisticated example:
</p>
<pre><code>C-M-% host:\([0-9]+\) RET host:\,(+ 1000 \#1)</code></pre>
<p>
  The backreference <code>\#1</code> refers to the string matched by
  the first capturing group <code>\([0-9]+\)</code> as
  a <em>number</em>.  The Elisp expression in the replacement pattern
  simply adds <code>1000</code> to that number and replaces the
  matched string with the result.  A string like <code>host:80</code>
  becomes <code>host:1080</code>.  Another string like
  <code>localhost:8000</code> becomes <code>localhost:9000</code>.
</p>
<p>
  Finally, here is an example from the real world of text editing
  where this feature was useful to me recently while solving a text
  editing problem.  Consider the following text buffer with a list of
  numbered items:
</p>
<pre>
<code>### 1) apple
### 2) ball
### 3) bat
### 4) cat
### 5) dog
### 6) elephant
### 7) fish
### 8) grapes
### 9) hen
### 10) ink
### 11) jug
### 12) kite
### 13) lion</code>
</pre>
<p>
  While this is a toy example presented here for the sake of
  simplicity and clarity, this example is based on an actual text
  editing problem I encountered recently.  In my actual problem
  though, there were more words on each line and there were some
  arbitrary paragraphs of text between every consecutive pair of
  items.  Further, the list was long with 50 or so items.  The problem
  now was to remove item number 3 and renumber all the lines below it.
</p>
<p>
  It is quite straightforward to remove item 3.  Just move the point
  (cursor) to that line and type <code>C-S-&lt;backspace&gt;</code>
  or <code>C-a C-k</code> to kill that line.  We get this:
</p>
<pre>
<code>### 1) apple
### 2) ball
### 4) cat
### 5) dog
### 6) elephant
### 7) fish
### 8) grapes
### 9) hen
### 10) ink
### 11) jug
### 12) kite
### 13) lion</code>
</pre>
<p>
  How do we now renumber all the items starting from <code>4)
  cat</code>?  This is where the support for Elisp expressions in
  replacement strings turns out to be useful.  First move the point to
  the beginning of that line.  Then type the following key sequence:
</p>
<pre><code>C-M-% ^### \([0-9]+\) RET ### \,(1- \#1) RET</code></pre>
<p>
  The search pattern captures the item number on each line in a
  capturing group.  The replacement string contains an Elisp
  expression that subtracts one from this number.  Thus a string
  like <code>### 4</code> gets replaced with <code>### 3</code>.
  After completing the replacement, the buffer looks like this:
</p>
<pre>
<code>### 1) apple
### 2) ball
### 3) cat
### 4) dog
### 5) elephant
### 6) fish
### 7) grapes
### 8) hen
### 9) ink
### 10) jug
### 11) kite
### 12) lion</code>
</pre>
<p>
  I hope this was useful.  Do you have an interesting
  Elisp-in-replacement-string story?  Please share it in the comments.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/elisp-in-replacement-string.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/lisp.html">#lisp</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a>
</p>
]]>
</description>
</item>
<item>
<title>From Fill Prefix to TRAMP</title>
<link>https://susam.net/from-fill-prefix-to-tramp.html</link>
<guid isPermaLink="false">zxgyx</guid>
<pubDate>Sat, 30 Dec 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  Our <a href="cc/mastering-emacs/">tiny book club</a> that
  used to meet during the weekends and holidays and discuss the
  book <a href="https://www.masteringemacs.org/">Mastering Emacs</a>,
  2022 edition concluded today.  In our
  <a href="cc/mastering-emacs/log.html#72">final meeting</a> today,
  we first discussed how to work across multiple directories in the
  same Dired buffer.  Then we did several demos of the various shells
  and terminal modes available in Emacs out of the box.  That
  completed our discussion on Chapter 6.  Then we moved on to Chapter
  7 (the final chapter) that first reiterates the importance of using
  the describe-system to ask Emacs questions about itself and then
  offers some recommendations about third-party packages and online
  Emacs communities.  Completing this chapter brought our book club
  discussions to an end.
</p>
<p>
  A big thanks to Mickey Petersen for writing the book and also very
  generously granting me the permission to share his book on screen
  while discussing it.
</p>
<p>
  This book club began on 16 Dec 2022 when we had our first meeting
  over Jitsi.  About 3&half; months after beginning these meetings, I
  posted an update about this book club in another blog post
  titled <a href="from-lunar-phases-to-yank-pop.html">From Lunar
  Phases to Yank-Pop</a>.  If you have not read that post yet, I
  suggest you read it before returning to this post.  Especially if
  you have recently begun learning Emacs, I think you will find that
  post useful.
</p>
<p>
  Back then, when I posted that last update, we had spent about 26
  hours together across 36 meetings and we were reading Chapter 5 of
  the book.  It took another 36 meetings to complete that chapter and
  the remaining two chapters.  After a total of 72 meetings, we
  completed discussing Chapter 7 of the book today which concluded
  this series of book club meetings.  In total, we have spent a little
  over 52 hours together to discuss this book, trying out every
  concept and command introduced in the book and sharing our insights
  about the material with each other.
</p>
<p>
  In this post, I will share some highlights from our meetings since
  the <a href="from-lunar-phases-to-yank-pop.html">last update</a>.
  These highlights share some concepts and commands we learnt that
  most members of our book club were not familiar with earlier but
  were found to be very useful after having learnt them.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#fill-prefix">Fill Prefix</a></li>
  <li><a href="#elisp-expressions-in-replacement-strings">Elisp Expressions in Replacement Strings</a></li>
  <li><a href="#keep-lines-and-flush-lines">Keep Lines and Flush Lines</a></li>
  <li><a href="#keyboard-macros">Keyboard Macros</a></li>
  <li><a href="#dabbrev">DAbbrev</a></li>
  <li><a href="#tab-vs-m-i">TAB vs M-i</a></li>
  <li><a href="#project-management">Project Management</a></li>
  <li><a href="#eshell-with-tramp">Eshell with TRAMP</a></li>
  <li><a href="#thanks">Thanks</a></li>
</ul>
<h2 id="fill-prefix">Fill Prefix<a href="#fill-prefix"></a></h2>
<p>
  Most of us in the book discussion group knew about filling
  paragraphs with <code>M-q</code>.  Consider the following badly
  formatted paragraphs with very long and very short lines:
</p>
<pre>
<code>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
incididunt ut labore et dolore
magna aliqua.  Arcu dui vivamus arcu felis bibendum ut tristique et egestas.
Bibendum arcu vitae
elementum curabitur vitae.</code>
</pre>
<p>
  Now put the point (cursor) anywhere on the paragraph and
  type <code>M-q</code>.  The paragraph gets neatly formatted to
  something like this:
</p>
<pre>
<code>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua.  Arcu dui
vivamus arcu felis bibendum ut tristique et egestas.  Bibendum arcu
vitae elementum curabitur vitae.</code>
</pre>
<p>
  The key sequence <code>M-q</code> invokes
  the <code>fill-paragraph</code> command that reformats the paragraph
  such that each line is as long as possible without exceeding the
  fill width (70 columns by default).  Most of us already used this
  command very often while writing and editing text.  However what
  some of us did not know was that there is such a thing as fill
  prefix which is taken into account while filling paragraphs.  To
  illustrate this concept, we will first consider this badly formatted
  paragraph:
</p>
<pre>
<code>:::: Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
:::: incididunt ut labore et dolore
:::: magna aliqua.  Arcu dui vivamus arcu felis bibendum ut tristique et egestas.
:::: Bibendum arcu vitae
:::: elementum curabitur vitae.</code>
</pre>
<p>
  Each line has a prefix consisting of four colons and a space.  After
  we reformat this paragraph with <code>M-q</code>, we get something
  like this:
</p>
<pre>
<code>:::: Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
eiusmod tempor :::: incididunt ut labore et dolore :::: magna aliqua.
Arcu dui vivamus arcu felis bibendum ut tristique et egestas.  ::::
Bibendum arcu vitae :::: elementum curabitur vitae.</code>
</pre>
<p>
  This is not what we want.  We want the paragraph to be formatted
  such that each line does not exceed 70 characters in length (which
  we have, in fact, accomplished above) and each line contains the
  four colons and a space as the prefix (this is broken above).  Can
  we do this?  Yes, by setting the fill prefix.  Type <code>C-/</code>
  or <code>C-x u</code> to undo the bad formatting we did just now and
  let us try again.  This time move the point over to
  the <code>L</code> of <code>Lorem</code> and type <code>C-x .</code>
  to set the fill prefix to the current line up to the point.  A
  confirmation is printed in the echo area that <code>":::: "</code>
  has been set as the fill prefix.  Then type <code>M-q</code> and the
  paragraph is now neatly formatted to look like this:
</p>
<pre>
<code>:::: Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
:::: eiusmod tempor incididunt ut labore et dolore magna aliqua.  Arcu
:::: dui vivamus arcu felis bibendum ut tristique et egestas.
:::: Bibendum arcu vitae elementum curabitur vitae.</code>
</pre>
<p>
  Note how every line is as long as possible without exceeding 70
  characters in length and each line has the fill prefix.  Emacs took
  care to remove the fill prefix from each line, subtract the length
  of the fill prefix from the maximum character budget it has for each
  line, reformat the lines and then reinsert the fill prefix on each
  line of the result.
</p>
<p>
  To turn off the fill prefix, simply set it to an empty prefix by
  typing <code>C-x .</code> at the beginning of the line.
  Thus <code>C-a C-x .</code> becomes an idiom for turning off the
  fill prefix.
</p>
<h2 id="elisp-expressions-in-replacement-strings">Elisp Expressions in Replacement Strings<a href="#elisp-expressions-in-replacement-strings"></a></h2>
<p>
  It was no surprise to anyone in the book discussion group that the
  key sequence <code>C-M-% f.. RET bar RET</code> starts a
  search-and-replace operation for strings that match the regular
  expression pattern <code>f..</code> to be replaced with the
  text <code>bar</code>.
</p>
<p>
  The concept of backreferences was also known to most.  For
  example, <code>C-M-% \(f..\)-\(b..\) RET \2-\1 RET</code> searches
  for strings matching the given regular expression pattern and
  replaces it with a new string that swaps the positions of the first
  capturing group and the second capturing group.  The
  backreference <code>\1</code> refers to the string matched by the
  first capturing group <code>\(f..\)</code> and
  similarly <code>\2</code> refers to the string matched by the second
  capturing group <code>\(b..\)</code>.  In this example, a string
  like <code>foo-bar</code> is replaced with <code>bar-foo</code>
  or <code>playful-banter</code> with <code>playban-fulter</code>.
</p>
<p>
  However what came as a surprise to some of us was that we could also
  use Elisp expressions in the replacement strings.  The syntax to do
  so is to write <code>\,</code> followed by the Elisp expression in
  the replacement string.  For example, consider the key
  sequence <code>C-M-% f.. RET \,(upcase \&amp;) RET</code>.  Note how
  we are using the backreference <code>\&amp;</code> that refers to
  the whole match as the argument to the Elisp function
  <code>upcase</code> that converts its argument to upper-case.  This
  example searches for strings that match the pattern <code>f..</code>
  and replaces them with the upper-case form of the match.  A string
  like <code>foo-bar</code> is replaced with <code>FOO-bar</code>.
</p>
<p>
  Here is another slightly more sophisticated example: <code>C-M-%
  port-\([0-9]+\) RET port-\,(+ 1000 \#1)</code>.  The
  backreference <code>\#1</code> refers to the string matched by the
  first capturing group <code>\([0-9]+\)</code> as <em>number</em>.
  The Elisp expression in the replacement pattern simply adds 1000 to
  that number and replaces the matched string with the result.  A
  string like <code>port-80</code> becomes <code>port-1080</code>.
</p>
<h2 id="keep-lines-and-flush-lines">Keep Lines and Flush Lines<a href="#keep-lines-and-flush-lines"></a></h2>
<p>
  A nifty set of commands that our group members enjoyed learning were
  the commands for keeping and flushing lines.  These commands can be
  incredibly useful while filtering large log files.  Here is a brief
  illustration of a couple of these commands:
</p>
<ul>
  <li>
    <p>
      <code>M-x keep-lines RET f.. RET</code>: Keep lines in region
      that match the regular expression <code>f..</code> and delete
      the rest.  If no region is active, then keep matching lines
      between the point and end of buffer; delete the rest.  The
      deleted lines are not copied to kill ring.
    </p>
  </li>
  <li>
    <p>
      <code>M-x flush-lines RET f.. RET</code>: Delete lines in the
      region that match the regular expression <code>f..</code>.  If
      no region is active, then delete matching lines between the
      point and end of buffer.  The deleted lines are not copied to
      kill ring.
    </p>
  </li>
</ul>
<p>
  Note how each point above mentions that the deleted lines are not
  copied to the kill ring.  This can be an inconvenience if we want to
  quickly yank the deleted lines to another buffer.  Emacs 28.1
  introduces a couple of more commands that remedy this situation to
  an extent.  Here they are:
</p>
<ul>
  <li>
    <p>
      <code>M-x copy-matching-lines RET f.. RET</code>: Copy lines in
      the region that match the regular expression <code>f..</code>.
      If no region is active, then copy matching lines between the
      point and end of buffer.
    </p>
  </li>
  <li>
    <p>
      <code>M-x kill-matching-lines RET f.. RET</code>: Kill lines in
      region that match the regular expression <code>f..</code> to the
      kill ring.  If no region is active, then kill matching lines
      between the point and end of buffer.
    </p>
  </li>
</ul>
<h2 id="keyboard-macros">Keyboard Macros<a href="#keyboard-macros"></a></h2>
<p>
  Most experienced Emacs users in our group were aware of keyboard
  macros.  However, some people did learn this wonderful automation
  feature for the first time in our meetings, so I thought this
  deserves its own section in this post.
</p>
<p>
  Keyboard macros is a large topic on its own which is best learnt
  from
  section <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html">Keyboard
  Macros</a> of the manual.  On Emacs, type <code>M-: (info "(emacs)
  Keyboard Macros") RET</code> to open this section using the Info
  documentation browser.  In this blog post though, we will very
  briefly talk about keyboard macros that should be enough to get
  someone very new to it started with them quickly.
</p>
<p>
  Say, we have a buffer that looks like this:
</p>
<pre>
<code>foo:bar:baz
bar:baz:qux
quux:corge:grault
garply:waldo:fred</code>
</pre>
<p>
  Now suppose we want to swap the first two fields separated by colon
  in each line.  Of course, we could do it using regular expressions,
  for example, with the key sequence
  <code>C-M-% ^\(.+?:\)\(.+?:\) RET \2\1 RET</code>.  But we can also
  solve this problem in a "dumb" way by simply performing the edits
  necessary to do the swap on one line and then asking Emacs to repeat
  what we did on the other lines.  Here are the steps:
</p>
<ol>
  <li>
    <p>
      First move the point to somewhere on the first line.
    </p>
  </li>
  <li>
    <p>
      Then type <code>C-x (</code> to start recording a keyboard
      macro.
    </p>
  </li>
  <li>
    <p>
      Then type <code>C-a M-d C-d M-f : C-y C-n</code> to swap the
      first and second fields on the first line and move the point to
      the next line.  This is just one way to achieve the swap.  You
      may use any editing commands you are comfortable with to make
      the swap happen and move the point to the next line.
    </p>
  </li>
  <li>
    Now type <code>C-x )</code> to stop macro recording.
  </li>
  <li>
    <p>
      Now type <code>C-x e</code> to replay the macro in the second
      line.  As soon as we type this key sequence, the swap occurs in
      the second line and the cursor moves to the third line.  Keep
      repeating this key sequence to keep repeating the swap operation
      on subsequent lines.
    </p>
  </li>
</ol>
<p>
  To summarise, <code>C-x (</code> starts recording a new keyboard
  macro, <code>C-x )</code> stops recording the keyboard macro
  and <code>C-x e</code> replays the last keyboard macro.
  Alternatively, we could also use the function keys <code>F3</code>
  and <code>F4</code>.  To start recording a keyboard macro,
  type <code>F3</code>.  Type <code>F4</code> to stop recording a
  keyboard macro.  Then type <code>F4</code> again to replay the last
  macro.
</p>
<p>
  Pay close attention to step 3 above.  We start the key sequence
  with <code>C-a</code> to move the point to the first column.  This
  may feel redundant when the cursor is already at the first column.
  However in our meetings, I used to emphasise often about the
  importance of doing this.  Typing <code>C-a</code> at the beginning
  ensures that we do not carry over any assumption about where the
  cursor is on the line into the rest of the keyboard macro definition
  we are going to record.  By typing <code>C-a</code>, we ensure that
  no matter where the cursor is on the line, when we replay the macro,
  the cursor would first move to the beginning of the line.  This
  guarantee allows us to confidently define the rest of the editing
  operations necessary to perform the swap.
</p>
<p>
  Similarly, at the end we type <code>C-n</code> to move the point to
  the next line.  I used to emphasise the importance of doing this too
  in our meetings.  Moving the cursor to the next line ensures that
  the cursor is in a good place to allow repeating the keyboard macro
  again immediately.  This is why we could type <code>C-x e</code> (or
  alternatively, <code>F4</code>) over and over again to replay the
  macro on subsequent lines.  In fact, if we feel confident about the
  keyboard macro, we can repeat it several times automatically using
  the digit argument.  For example, type <code>C-3 C-x e</code> (or
  alternatively <code>C-3 F4</code>) to repeat the keyboard macro 3
  times.  We could also type <code>C-0 C-x e</code> (or
  alternatively <code>C-0 F4</code>) to repeat the keyboard macro
  until there is an error (e.g. reaching the end of the buffer).
</p>
<h2 id="dabbrev">DAbbrev<a href="#dabbrev"></a></h2>
<p>
  DAbbrev stands for <em>dynamic abbrevation</em>.  This is a pretty
  useful package that many of us learnt only from our book club
  meetings.  We discussed two simple key sequences supported by this
  package:
</p>
<ul>
  <li>
    <p>
      <code>M-/</code>: Expand the word before the point to the
      nearest preceding word for which the current word is a prefix.
      If no suitable preceding word is found, then expand the current
      word to the nearest succeeding word for which the current word
      is a prefix.
    </p>
  </li>
  <li>
    <p>
      <code>C-M-/</code>: Find all words in the buffer that has the
      current word before the cursor as the prefix and expand the
      current word to the longest common prefix of all these matching
      words.  However, if the longest common prefix of the matching
      words is same as the word before the cursor, then present them
      as suggestions for completion.  If there is exactly one matching
      word, expand the word before the cursor to that word.
    </p>
  </li>
</ul>
<p>
  Let us look at some examples.  Suppose there is a buffer with the
  following one line of text:
</p>
<pre><code>abacus apple appliance application</code></pre>
<p>
  Now if we type <code>ap</code> on the next line and
  type <code>M-/</code>, DAbbrev automatically expands the partially
  written word to <code>application</code> because that is the nearest
  word that has <code>ap</code> as the prefix.
</p>
<p>
  But if we type <code>ap</code> and type <code>C-M-/</code>, the word
  expands to <code>appl</code> since that is the longest common prefix
  among all the matching words.  If we type <code>C-M-/</code> again
  then <code>apple</code>, <code>appliance</code>
  and <code>application</code> are presented as possible completions
  in a temporary buffer named <code>*Completions*</code>.  If we
  type <code>ic</code>, so that the word before the cursor
  becomes <code>applic</code> and type <code>C-M-/</code>, it is
  expanded to <code>application</code> because that is the only
  possible completion now.
</p>
<p>
  These two commands are simpler than it sounds from the verbose
  descriptions of these commands presented in the above paragraphs.
  When we actually begin to use them, they become intuitive in no
  time.  Roughly speaking, while <code>M-/</code> expands the word
  before the point to the nearest preceding word, <code>C-M-/</code>
  considers all matching words in the file for expansion and presents
  completion options to the user when it finds multiple of them.
</p>
<h2 id="tab-vs-m-i">TAB vs M-i<a href="#tab-vs-m-i"></a></h2>
<p>
  The behaviour of Emacs when we type <code>TAB</code> can be
  surprising to beginners.  In most other mainstream editors, this key
  either inserts a tab character or it inserts enough number of spaces
  so that the cursor moves to the next tab stop.  But in
  Emacs, <code>TAB</code> most often indents the current line
  according to the syntax rules implemented by the major mode enabled
  in the buffer.
</p>
<p>
  What is a simple key on other editors happens to be a complex
  feature in Emacs.  The exact behaviour of <code>TAB</code> is
  controlled by variables
  like <code>tab-always-indent</code>, <code>indent-line-function</code>,
  etc.  Some major modes may refer to other such special variables to
  decide what <code>TAB</code> should do.  However, as a user of Emacs
  this is not something we normally have to worry about.  Most major
  modes set up all these variables appropriately, so that
  <code>TAB</code> almost always does what an experienced Emacs user
  expects, i.e. indent the current line of code correctly.
</p>
<p>
  But what if we really do want to just insert a tab or enough number
  of spaces to move the point to the next tab stop column?  That is
  done with <code>M-i</code>.  If the
  variable <code>indent-tabs-mode</code> is set to <code>t</code>,
  then <code>M-i</code> inserts a literal tab character.  If it is set
  to <code>nil</code>, then <code>M-i</code> inserts enough number of
  spaces to move the point to the next tab stop column.
</p>
<p>
  To summarise, the behaviour of <code>M-i</code> is similar to
  the <code>TAB</code> behaviour we observe in other editors.  In
  practice though, the key sequence <code>M-i</code> is rarely
  required.  Most people just type <code>TAB</code> to automatically
  indent code.  In fact, we can also select a region of code and
  type <code>TAB</code> to reindent the whole region.
</p>
<h2 id="project-management">Project Management<a href="#project-management"></a></h2>
<p>
  The project management commands that come out of the box (from the
  package named <code>project.el</code>) came as a surprise to some.
  In fact, some members of our group who never used the project
  management commands earlier happen to use them regularly now after
  learning about them in our meetings.
</p>
<p>
 When we use a project command like <code>C-x p f</code> to visit a
 file in the current project, the command automatically detects the
 top-level directory of the project by checking parent directories for
 version control system artefacts (e.g. <code>.git</code> directory)
 and presents files within that top-level directory as autocomplete
 options.
</p>
<p>
  There is a lot that can be written about the project management
  features that come out of the box in Emacs.  The following list
  introduces only the very simple ones to get someone started with
  them:
</p>
<ul>
  <li>
    <p>
      <code>C-x p f logger RET</code>: Find file with name that
      matches <code>logger</code> in the current project.  This
      searches all subdirectories recursively.  If there is only one
      matching file (say, <code>src/logger.cc</code>), that file is
      opened.  If there are multiple matching files, they are
      presented as completion options.  Running this command or, in
      fact, running any project command leads to discovering the
      current project and adding an entry for the discovered project
      to <code>~/.emacs.d/projects</code>.  This is useful for a
      command like the one presented in the next point.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p f foo TAB RET logger TAB RET</code>: When we
      type <code>C-x p f</code> while visiting a file that does not
      belong to any project, then its prompts for a project path
      first.  In this example, we type <code>foo TAB RET</code> to
      automatically expand it to a known project path such
      as <code>~/git/foo/</code> and enter it.  Then we
      type <code>logger TAB RET</code> to automatically expand it to a
      file name such as <code>src/logger.cc</code> and visit it.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p p bar TAB RET f logger TAB RET</code>: Say we are in
      project <code>~/git/foo/</code> but we want to switch to another
      previously discovered project <code>~/git/bar/</code> and find a
      file there.  To do so, we first type <code>C-x p p</code> to
      switch project.  At the project selection prompt, we
      type <code>bar TAB</code> to automatically complete the
      directory path of the known project <code>~/git/bar/</code>.
      Then another prompt is presented to choose an action from a
      number of actions.  In this case, we type <code>f</code> to find
      a file in the project we have switched to.  Finally, we
      type <code>logger TAB RET</code> to automatically expand the
      partially entered name to a path like <code>src/logger.cc</code>
      and visit it.  The key sequence <code>C-x p p</code> is very
      useful when the current file belongs to one project but we want
      to run a project command on another project.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p p ... RET ~/git/baz/ RET f logger TAB RET</code>:
      This awkward key sequence discovers a new project directory
      at <code>~/git/baz/</code> and then finds a file in it.  The key
      sequence <code>C-x p p ... RET</code> is rarely required though.
      See the notes after the end of this list to read why.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p g ^key\&gt; RET</code>: Find all matches for the
      regular expression <code>^key\&gt;</code> in the current
      project.  The results are displayed in <code>*xref*</code>
      buffer.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p s</code>: Start a shell in the current project's
      root directory.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p d</code>: Start Dired in the current project's root
      directory.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p k yes RET</code>: Kill all buffers belonging to the
      current project.
    </p>
  </li>
</ul>
<p>
  There are several more project commands but we will end the above
  list here for the sake of brevity.  Do pay attention to the second
  point that mentions that if the current file does not belong to any
  project, we are first prompted to enter the project name.  This is a
  common theme for all project commands.  Anytime we invoke a project
  command, it works on the current project.  However if there is no
  current project, then it automatically prompts us to enter a project
  name before executing the command.
</p>
<p>
  The key sequence <code>C-x p p ... RET</code> is very rarely
  required during day-to-day editing activities.  Once a project has
  been discovered (say, due to having run a project command on that
  project earlier) and added to the list of known projects
  at <code>~/.emacs.d/projects</code>, we never have to discover it
  again.  We can use the other key sequences to switch to or work on a
  known project.  Most day-to-day project activities involve working
  on known projects.
</p>
<p>
  Further, even when we do want to discover a new project and add it
  to the list of known projects, a much more natural way to do it is
  to run a project command while we are visiting a file in the project
  directory.  In most cases, we already have a file from some project
  open in the current buffer.  Therefore it makes more sense to just
  go ahead with a project command, say, with <code>C-x p
  f</code>, <code>C-x p g</code>, etc. directly instead of explicitly
  discovering the project with <code>C-x p p ... RET</code>.  Merely
  running a project command while we have a file from a project open
  ends up discovering the current project automatically.  Explicitly
  discovering projects with <code>C-x p p ... RET</code> is almost
  never necessary.
</p>
<h2 id="eshell-with-tramp">Eshell with TRAMP<a href="#eshell-with-tramp"></a></h2>
<p>
  Many members of our group knew about Eshell and TRAMP separately.
  For example, <code>M-x eshell RET</code> starts Eshell.  Eshell is
  implemented purely in Elisp and we can use it much like a regular
  shell.  Here is an example session:
</p>
<pre>
<samp>~ $ <kbd>cd /tmp/</kbd>
/tmp $ <kbd>echo hello &gt; hello.txt</kbd>
/tmp $ <kbd>cat hello.txt</kbd>
hello
/tmp $ <kbd>python3 --version</kbd>
Python 3.11.5
/tmp $ <kbd>which cd echo cat python3 which</kbd>
eshell/cd is a byte-compiled Lisp function in &lsquo;em-dirs.el&rsquo;.
eshell/echo is a byte-compiled Lisp function in &lsquo;em-basic.el&rsquo;.
eshell/cat is a byte-compiled Lisp function in &lsquo;em-unix.el&rsquo;.
/usr/bin/python3
eshell/which is a byte-compiled Lisp function in &lsquo;esh-cmd.el&rsquo;.</samp>
</pre>
<p>
  We also knew about TRAMP.  For example, when we type the key
  sequence <code>C-x C-f /ssh:alice@box:/tmp/foo.txt RET</code>, TRAMP
  notices that we intend to connect to a remote system
  named <code>box</code> as the user <code>alice</code> via SSH and
  edit a file named <code>/tmp/foo.txt</code> on the remote system.
  TRAMP then transparently establishes the SSH connection for us.  If
  public key authentication is already set up, then the connection is
  successfully established immediately.  Otherwise it prompts for a
  password.  In the end, we get a buffer to edit the remote
  file <code>/tmp/foo.txt</code>.  Once we have this buffer, we never
  have to do anything special to work on the remote file.  All Emacs
  commands work seamlessly on this buffer for the remote file.  For
  example, when we type <code>C-x C-s</code> TRAMP would go ahead and
  save the file to the remote system using the established SSH
  connection.  If we type <code>C-x d</code>, TRAMP would create a
  Dired buffer for the remote directory <code>/tmp/</code>.  All the
  Emacs commands for working with files and directories we know just
  work fine with the remote file or directory.
</p>
<p>
  So we knew about Eshell and we knew about TRAMP.  However what many
  of us found pleasantly surprising was how remarkably well Eshell and
  TRAMP work together.  Here is an example Eshell session that
  illustrates this point:
</p>
<pre>
<samp>~ $ <kbd>cd /ssh:alice@box:/tmp/</kbd>
/ssh:alice@box:/tmp $ <kbd>echo foo &gt; foo.txt</kbd>
/ssh:alice@box:/tmp $ <kbd>ls</kbd>
foo.txt
/ssh:alice@box:/tmp $ <kbd>cd /tmp/</kbd>
/tmp $ <kbd>echo bar &gt; bar.txt</kbd>
/tmp $ <kbd>ls</kbd>
bar.txt
/tmp $ <kbd>cp /ssh:alice@box:/tmp/foo.txt .</kbd>
/tmp $ <kbd>ls</kbd>
bar.txt  foo.txt
/tmp $</samp>
</pre>
<p>
  Look at how the command <code>cd /ssh:alice@box:/tmp/</code> above
  has seamlessly and transparently set the current directory of the
  shell to the remote directory.  When we create a file after that, it
  gets created on the remote directory!  We can work across
  directories opened with multiple TRAMP methods too.  For example
  first consider this session where the current local user does not
  have the permissions to write to the local <code>/etc/</code>
  directory:
</p>
<pre>
<samp>~ $ <kbd>cp /ssh:alice@box:/etc/wgetrc /etc/</kbd>
Opening output file Permission denied /etc/wgetrc</samp>
</pre>
<p>
  But if the current user has <code>sudo</code> privilege, we can do
  something like this:
</p>
<pre>
<samp>~ $ <kbd>cp /ssh:alice@box:/etc/wgetrc /sudo::/etc/</kbd>
~ $ <kbd>ls /etc/wgetrc</kbd>
/etc/wgetrc</samp>
</pre>
<p>
  We copied a file from a remote system and wrote it to a protected
  directory on the local system by using the <code>sudo</code>
  privilege.  We used the <code>ssh</code> method to read a remote
  file and the <code>sudo</code> method to write the file to a
  protected local directory.  TRAMP really does live up to its
  name: <em>Transparent Remote Access, Multiple Protocol</em>!
</p>
<h2 id="thanks">Thanks<a href="#thanks"></a></h2>
<p>
  It has been a pleasure hosting these Emacs book club meetings
  throughout this year.  I have really enjoyed discussing the book in
  great detail, examining each new concept introduced in the book
  carefully and performing demos to illustrate the concepts.  A big
  thank you to the Emacs communities on Libera and Matrix networks who
  showed interest in these meetings, joined these meetings,
  participated in the discussions and helped make these meetings
  successful!
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/from-fill-prefix-to-tramp.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes on Mastering Emacs: Chapter 7: Conclusion</title>
<link>https://susam.net/cc/mastering-emacs/ch07.html</link>
<guid isPermaLink="false">zoygz</guid>
<pubDate>Fri, 29 Dec 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The following notes were taken while discussing Chapter 6 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#third-party-packages-and-tools">Third-Party Packages and Tools</a></li>
  <li><a href="#communities">Communities</a></li>
</ul>
<h2 id="third-party-packages-and-tools">Third-Party Packages and Tools<a href="#third-party-packages-and-tools"></a></h2>
<p>
  Here is a list of third-party packages and tools this chapter
  introduces to the reader:
</p>
<ul>
  <li>nov, an EPUB reader</li>
  <li>Magit, a Git UI system with a chord-based key system</li>
  <li>Multiple Cursors</li>
  <li>LSP Mode, a language server interface for Emacs</li>
  <li>Eglot, another language server interface for Emacs</li>
  <li>Helm, a powerful completion framework</li>
  <li>Flycheck, a generic framework for linting and syntax error checking</li>
  <li>Org mode, an organiser for notes, agenda, literate programming, etc.</li>
  <li>YASnippet, a text snippet expansion tool</li>
  <li>Hydra, a package to build flexible popup UIs for key bindings</li>
  <li>dumb-jump, a package to jump to definitions from symbols</li>
</ul>
<p>
  Note that Eglot comes out of the box since Emacs version 29.1.
</p>
<h2 id="communities">Communities<a href="#communities"></a></h2>
<p>
  Some of the communities recommended by this chapter are:
</p>
<ul>
  <li><a href="https://old.reddit.com/r/emacs/">Reddit r/emacs</a></li>
  <li><a href="https://emacs.stackexchange.com/">Emacs Stack Exchange</a></li>
  <li><a href="https://planet.emacslife.com/">Planet Emacslife</a></li>
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/ch07.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes on Mastering Emacs: Chapter 6: The Practicals of Emacs</title>
<link>https://susam.net/cc/mastering-emacs/ch06.html</link>
<guid isPermaLink="false">nqgkb</guid>
<pubDate>Thu, 28 Dec 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The following notes were taken while discussing Chapter 6 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#exploring-emacs">Exploring Emacs</a></li>
  <li><a href="#project-management">Project Management</a></li>
  <li><a href="#xref">Xref</a>
    <ul>
      <li><a href="#xref-setup">Xref Setup</a></li>
      <li><a href="#search-tools-for-xref">Search Tools for Xref</a></li>
      <li><a href="#four-most-common-xref-commands">Four Most Common Xref Commands</a></li>
      <li><a href="#xref-and-dired">Xref and Dired</a></li>
    </ul>
  </li>
  <li><a href="#working-with-log-files">Working with Log Files</a></li>
  <li><a href="#highlighting">Highlighting</a></li>
  <li><a href="#auto-revert-mode">Auto-Revert Mode</a></li>
  <li><a href="#auto-revert-tail-mode">Auto Revert Tail Mode</a></li>
  <li><a href="#browsing-tarballs">Browsing Tarballs</a></li>
  <li><a href="#dired-thumbnail-image-browser">Dired: Thumbnail Image Browser</a>
    <ul>
      <li><a href="#preview-buffer-quirks">Preview Buffer Quirks</a></li>
      <li><a href="#working-on-marked-files">Working on Marked Files</a></li>
      <li><a href="#deleting-images">Deleting Images</a></li>
      <li><a href="#tagging-and-untagging">Tagging and Untagging</a></li>
      <li><a href="#using-tags">Using Tags</a></li>
      <li><a href="#display-buffer">Display Buffer</a></li>
    </ul>
  </li>
  <li><a href="#docview">DocView</a>
    <ul>
      <li><a href="#docview-resolution">DocView Resolution</a></li>
    </ul>
  </li>
  <li><a href="#tramp">TRAMP</a>
    <ul>
      <li><a href="#default-directory">Default Directory</a></li>
      <li><a href="#multi-hops">Multi-Hops</a></li>
    </ul>
  </li>
  <li><a href="#eww">EWW: Emacs Web Wowser</a></li>
  <li><a href="#invoking-external-browser">Invoking External Browser</a></li>
  <li><a href="#dired">Dired</a>
    <ul>
      <li><a href="#dired-getting-started">Dired: Getting Started</a></li>
      <li><a href="#dired-navigation">Dired: Navigation</a></li>
      <li><a href="#dired-marking-and-unmarking">Dired: Marking and Unmarking</a></li>
      <li><a href="#dired-operations">Dired: Operations</a></li>
      <li><a href="#dired-copying-or-renaming-between-buffers">Dired: Copying or Renaming Between Buffers</a></li>
      <li><a href="#dired-more-keys">Dired: More Keys</a></li>
      <li><a href="#dired-x">Dired-X</a></li>
      <li><a href="#dired-working-across-directories">Dired: Working Across Directories</a></li>
    </ul>
  </li>
  <li><a href="#shell-commands">Shell Commands</a></li>
  <li><a href="#compiling-in-emacs">Compiling in Emacs</a></li>
  <li><a href="#shells-in-emacs">Shells in Emacs</a>
    <ul>
      <li><a href="#m-x-shell">M-x shell</a></li>
      <li><a href="#m-x-ansi-term">M-x ansi-term</a></li>
      <li><a href="#m-x-eshell">M-x eshell</a></li>
    </ul>
  </li>
</ul>
<h2 id="exploring-emacs">Exploring Emacs<a href="#exploring-emacs"></a></h2>
<p>
  The book suggests the following techniques to explore Emacs:
</p>
<ul>
  <li>
    <p>
      Reading the manual.  For example, type <code>M-x info RET</code>
      or <code>C-h i</code>, then navigate to the <code>Emacs</code>
      hyperlink, then type <code>C-s version control RET</code> and
      then navigate to the node named <code>Version Control</code> to
      read the corresponding manual.
    </p>
    <p>
      Note that the section named <em>The Info Manual</em> in Chapter
      3 offers more alternatives to reach a specific node in a more
      straightforward manner.  For example, <code>C-h i m emacs RET m
      Version Control RET</code> accomplishes the same result.
      Alternatively, <code>C-h R emacs RET m Version Control
      RET</code> also accomplishes the same result.  Yet another way
      to accomplish the same result is to evaluate the Elisp
      expression <code>(info "(emacs)Version Control")</code>.  See
      section <a href="ch03.html#info">Info</a> in chapter 3 notes for
      more details.
    </p>
    <p>
      Yet another way to explore the manual is to use
      the <code>info-apropos</code> command.  For example,
      type <code>M-x info-apropos RET version control RET</code> to
      find manuals which have the string "version control" in them.
    </p>
  </li>
  <li>
    <p>
      Using apropos.  For example, type <code>C-h d version control
      RET</code> to search for all symbols whose documentation string
      contains the specified pattern.  Then type <code>C-h a ^vc-
      RET</code> to search for all commands that match this pattern.
      This is a convenient way to list the vc commands.  Also, see
      section <a href="ch03.html#apropos">Apropos</a> in chapter 3
      notes for more details.
    </p>
  </li>
  <li>
    <p>
      Exploring prefix keys.  For example, type <code>C-x v C-h</code>
      to list all key sequences bound to the prefix key <code>C-x
      v</code>.  This is in fact a convenient way to list all the vc
      key bindings.  Also, see section
      <a href="ch03.html#discovering-and-remembering-keys">Discovering
      and Remembering Keys</a> in chapter 3 notes for more details.
    </p>
  </li>
  <li>
    <p>
      Describe what a key does.  For example, type <code>C-h k</code>
      followed by <code>C-x v v</code> to see the command that is
      bound to the latter key sequence as well as its documentation
      string along with other details like the keymap where the key
      binding is found, the file where the command is defined, other
      key bindings for the same command, etc.  See
      section <a href="ch03.html#describe">Describe</a> in chapter 3
      notes for some more details.
    </p>
  </li>
  <li>
    <p>
      Describe commands.  For example, type <code>C-h f vc-dir
      RET</code> to see information about the <code>vc-dir</code>
      command.  See section <a href="ch03.html#describe">Describe</a>
      in chapter 3 notes for some more details.
    </p>
  </li>
  <li>
    <p>
      Find mode commands.  Type <code>C-h m</code> to see the
      documentation strings of the current major mode and minor modes.
      A brief summary of the minor modes is shown first, followed by
      the major mode description.  This is followed by documentation
      strings of the minor modes separated by page breaks (the form
      feed character that is rendered as <code>^L</code> in Emacs).
      See section <a href="ch03.html#describe">Describe</a> in chapter
      3 notes for some more details.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-X</code> to run
      <code>execute-extended-command-for-buffer</code> which executes
      commands that are relevant to the current buffer.  While
      offering completions, it limits the completions to commands
      relevant to the current buffer.  See
      section <a href="ch03.html#m-x-execute-extended-command-for-buffer">M-X:
      Execute Extended Command for Buffer</a> of chapter 3 notes for
      more details.
    </p>
  </li>
</ul>
<h2 id="project-management">Project Management<a href="#project-management"></a></h2>
<p>
  Emacs comes with a project management package
  named <code>project.el</code> which offers commands to operate on
  projects.  When we use a project management command like <code>C-x p
  f</code> to visit a file in the current project, this package
  automatically detects the top-level directory of the project by
  checking parent directories for version control system artifacts
  (e.g. <code>.git</code> directory) and presents files within that
  top-level directory as autocomplete options.
</p>
<p>
  The following complete key sequences demonstrate the package
  management commands mentioned in the book:
</p>
<ul>
  <li>
    <p>
      <code>C-x p p ... TAB RET ~/git/foo/ RET f README.md</code>:
      This awkward key sequence discovers a new project directory
      at <code>~/git/foo/</code> and then finds the file
      named <code>README.md</code> in it.  As soon as the key
      sequence <code>f</code> is typed above, the new project
      directory is discovered and added
      to <code>~/.emacs.d/projects</code> which is where the list of
      known projects is saved.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p p bar TAB RET f Makefile</code>: Assuming there is
      already a known project with <code>bar</code> in its name
      (say, <code>~/git/bar/</code>) that was discovered earlier, this
      key sequence switches to that project and finds the file named
      in <code>Makefile</code> in it.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p f dev/build.sh RET</code>: Find file
      named <code>dev/build.sh</code> in the current project.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p f build TAB RET</code>: Same as above
      if <code>dev/build.sh</code> is the only match
      for <code>build</code>.  Otherwise, it presents all files in the
      current project containing <code>build</code> anywhere in its
      path name as autocomplete options.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p f bar TAB RET build TAB RET</code>: When we
      type <code>C-x p f</code> while visiting a file that does not
      belong to any project, then its prompts for a project name.  In
      this example, we type <code>bar TAB RET</code> to automatically
      expand it to a known project name such
      as <code>~/git/bar/</code> and enter it.  Then we
      type <code>build TAB RET</code> to automatically expand it to a
      file name such as <code>dev/build.sh</code> and enter it.
    </p>
    <p>
      It is worth noting a general point that whenever we invoke a
      project command while visiting a file that does not belong to a
      project, the project command prompts for the project name.
      After we enter the project name, the project command runs on our
      chosen project.  This general point applies to other project
      commands that come later in this list.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p b Makefile RET</code>: Switch to a buffer
      named <code>Makefile</code> in the current project.  While
      entering the buffer name when <code>TAB</code> is typed,
      completion options present buffer names from the current project
      only.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p k yes RET</code>: Kill all buffers belonging to the
      current project.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p g ^key\&gt; RET</code>: Find all matches for the
      regular expression <code>^key\&gt;</code> in the current
      project.  The matches are found in all files in the project
      regardless of whether they are currently open in Emacs or not.
      The matches are displayed in a buffer named <code>*xref*</code>.
      We can navigate this buffer using key sequences
      like <code>n</code>, <code>p</code>, etc.  Type
      <code>C-h m</code> in this buffer to see a list of key sequences
      supported in this buffer.  As we navigate this buffer and go
      from one match to another using <code>n</code>, <code>p</code>,
      etc. the files containing the match are loaded in a split window
      automatically with the matching lines automatically centred in
      that window.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p r ^key\&gt; RET =key= RET</code>: Find all matches
      for the regular expression pattern <code>^key\&gt;</code> in the
      current project and replace them with <code>=key=</code>.  The
      modified files are not automatically saved though.  They needed
      to be saved later explicitly.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p c RET</code>: Compiles the current project.  By
      default, it offers as <code>make -f</code> as the command to be
      run in the project root.  If a specific <code>make</code> target
      needs to be executed or if another command needs to be executed,
      then the default command offered may be edited before
      typing <code>RET</code>.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p v</code>: Runs VC-Dir in the current project's root
      which in turn shows version control status for the project root.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p s</code>: Start shell in the current project's root
      directory.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p d RET</code>: Start Dired in the current project's
      root directory.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p D</code>: Same as above.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p d doc/tutorial/ RET</code>: Start Dired in
      the <code>doc/tutorial/</code> subdirectory in the current
      project.
    </p>
  </li>
</ul>
<p>
  There are several more project management key bindings.
  Type <code>C-x p C-h</code> to see a complete list of them.
</p>
<h2 id="xref">Xref<a href="#xref"></a></h2>
<p>
  Xref provides a generic framework to support commands for
  cross-referencing in Emacs.  While there are several ways to set it
  up and configure it, the book mentions a particular way to set it up
  using a couple of external tools.  The next two subsections discuss
  the setup work involved before we can use Xref in a modern way.  The
  remaining subsections discuss how to use Xref.
</p>
<h3 id="xref-setup">Xref Setup<a href="#xref-setup"></a></h3>
<p>
  By default when we try to look up a definition of an identifier in,
  say, a C file or Python file, by typing <code>M-.</code>, it
  presents a minibuffer for us to select a tags table file (typically
  named <code>TAGS</code>).  This requires setting up
  a <code>TAGS</code> file with a tool like <code>ctags</code>.  The
  book, however, does not explore this method for good reason.
  Typically the <code>TAGS</code> file needs to be created with a tool
  like <code>ctags</code> or <code>etags</code> for every project we
  work on.  This file contains an index of names found in source code
  files.  We need to periodically update it as the code of our
  projects evolve, so that this index remains up-to-date.  For a long
  time, this was the only way to maintain an index of the names found
  in a source code, so that we could perform cross-referencing in
  editors like Vim and Emacs.  Relying on a tool
  like <code>grep</code> to search the code on the fly was deemed to
  be quite slow.  However, with modern, fast hardware we do not have
  to work like this anymore.  Further, there are search tools
  like <code>ag</code> and <code>rg</code> which are extremely fast.
  Given these modern developments, there are simpler ways to set up
  cross-referencing in Emacs.
</p>
<p>
  The book suggets installing an external package
  named <code>dumb-jump</code>.  It can be installed from MELPA with
  the key sequence <code>M-x package-install dumb-jump RET</code>.
  See <a href="https://github.com/jacktasia/dumb-jump">github.com/jacktasia/dumb-jump</a>
  for more details about this package.  After installing this package,
  add the following code to the Emacs initialisation file:
</p>
<pre><code>(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)</code></pre>
<p>
  Here is a minimal Elisp code that sets up <code>dumb-jump</code>
  from scratch and configures it as mentioned above:
</p>
<pre>
<code>(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
(dolist (package '(dumb-jump))
  (unless (package-installed-p package)
    (package-install package)))
(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)</code>
</pre>
<p>
  The above code configures Emacs to use MELPA, retrieve the latest
  list of packages available there, install <code>dumb-jump</code>
  from it, as well as set up a hook to activate it automatically when
  we use certain Xref commands.
</p>
<h3 id="search-tools-for-xref">Search Tools for Xref<a href="#search-tools-for-xref"></a></h3>
<p>
  Once Xref is set up with <code>dumb-jump</code> as explained in the
  previous section, open a source code file (say, a C file or a Python
  file), move the cursor over to some identifier and
  type <code>M-.</code> to search that identifier in your environment.
  By default, it searches for the identifier in files of the same type
  found under the home directory with a tool like <code>ag</code>,
  <code>rg</code> or <code>grep</code> (the first one it finds).
  There is an exception to this rule though.  If
  neither <code>ag</code> nor <code>rg</code> is found and only GNU
  grep is found, then typing <code>M-.</code> on an indentifier
  searches the identifier in all files in the home directory (as
  opposed to searching for files of a specific type).  If BSD grep is
  found instead, then this is not a problem and only files of the
  current type is searched for the identifier.
</p>
<p>
  Further, while looking up definitions within a Git repository, this
  package invokes the <code>git grep</code> command to restrict
  searches to the repository directory.
</p>
<p>
  Let us now look at a few examples of the actual search commands that
  are executed under the hood when we type <code>M-.</code>.
</p>
<p>
  If neither <code>ag</code> nor <code>rg</code> is installed and we
  only have <code>grep</code> on our system, typing <code>M-.</code>
  while the cursor is on an identifier named <code>foo</code> in a
  Python file leads to the execution of a command like this when BSD
  grep is found:
</p>
<pre><code>grep -REn --include '*.py' -e '\s*\bfoo\s*=[^=\n]+' -e 'def\s*foo\b\s*\(' -e 'class\s*foo\b\s*\(?' /Users/susam</code></pre>
<p>
  If GNU grep is found instead, then all files (not
  just <code>*.py</code> files) are searched with a command like this:
</p>
<pre><code>grep -rEn -e '[[:space:]]*\bfoo[[:space:]]*=[^=\n]+' -e 'def[[:space:]]*foo\b[[:space:]]*\(' -e 'class[[:space:]]*foo\b[[:space:]]*\(?' /home/susam</code></pre>
<p>
  If <code>rg</code> is the only additional search tool installed,
  then the following command is executed:
</p>
<pre><code>rg --color never --no-heading --line-number -U --pcre2 --type py '\s*\bfoo\s*=[^=\n]+|def\s*foo\b\s*\(|class\s*foo\b\s*\(?' /home/susam</code></pre>
<p>
  If <code>ag</code> is installed, then the following command is
  executed:
</p>
<pre><code>ag --nocolor --nogroup --python '\s*\bfoo\s*=[^=\n]+|def\s*foo\b\s*\(|class\s*foo\b\s*\(?' /home/susam</code></pre>
<p>
  When we type <code>M-.</code> in a file that belongs to a Git
  repository, only the repository directory is searched with a command
  like this:
</p>
<pre><code>git grep --color=never --line-number --untracked -E '\s*\bfoo\s*=[^=\n]+|def\s*foo\b\s*\(|class\s*foo\b\s*\(?' -- /home/susam/repo/*.py</code></pre>
<p>
  The book makes a mention of <code>rg</code> and remarks about the
  impressive speed with which it searches the file system.  I
  recommend it too.  Since the <code>M-.</code> command may search the
  whole home directory, if the home directory is very large, having a
  fast search tool like <code>rg</code> or <code>ag</code> makes a
  significant difference.  For example what could normally take 10 to
  20 seconds to search using <code>grep</code> might only take a
  second or two with <code>rg</code> or <code>ag</code>.  I
  use <code>M-.</code> with <code>rg</code>.
</p>
<h3 id="four-most-common-xref-commands">Four Most Common Xref Commands<a href="#four-most-common-xref-commands"></a></h3>
<p>
  The book mentions the following commands as the four most common
  commands we should know about:
</p>
<ul>
  <li>
    <p>
      <code>M-.</code>: Find definitions of the identifier at point.
      If a unique definition is found, then the file containing the
      definition is automatically opened and the definition is centred
      in the window.  If multiple possible candidates are found, then
      they are displayed in an Xref buffer that we can navigate using
      key sequences like <code>n</code> or <code>p</code>.  As we
      navigate the Xref buffer, the source of each match is
      automatically opened in a split window and the matching line is
      centred.
    </p>
  </li>
  <li>
    <p>
      <code>M-,</code>: Go back to where <code>M-.</code> was last
      invoked.
    </p>
  </li>
  <li>
    <p>
      <code>M-? foo RET ~/git/foo/ RET</code>: Find all occurrences of
      the word <code>foo</code> in files of the same type as the
      current file in the project directory <code>~/git/foo/</code>.
      It does not restrict the search to definitions only.  If the
      current file belongs to a project already, then we could simply
      type <code>M-? foo RET</code>.  In fact, since the input to the
      minibuffer prompt is the identifier at the point by default, we
      could simply type <code>M-? RET</code> to search for the current
      identifier in the current project.
    </p>
  </li>
  <li>
    <p>
      <code>C-M-. foo RET</code>: Find symbols matching the given
      pattern.  Although the documentation mentions that this supports
      regular expressions, it seemed to treat the given pattern as an
      identifier and searched for that identifier literally.  In fact,
      the <code>rg</code> commands that were executed under the hood
      were exactly the same as the ones executed by <code>M-.</code>.
      Thus with <code>dumb-jump</code> enabled, both <code>M-.</code>
      and <code>C-M-.</code> behave similarly.  The only difference is
      that <code>M-.</code> searches for the identifier at the point
      whereas <code>C-M-.</code> searches for the identifier we enter
      at the minibuffer as input.
    </p>
  </li>
</ul>
<p>
  When multiple cross-references are displayed in the Xref buffer, we
  can use the following key sequences to work with the Xref buffer.
</p>
<ul>
  <li>
    <p>
      <code>n</code>: Move to the next cross-reference.  The source of
      the cross-reference is automatically displayed in another
      window.
    </p>
  </li>
  <li>
    <p>
      <code>n</code>: Move to the previous cross-reference.  The source
      of the cross-reference is automatically displayed in another
      window.
    </p>
  </li>
  <li>
    <p>
      <code>.</code>: Same as <code>n</code>.
    </p>
  </li>
  <li>
    <p>
      <code>,</code>: Same as <code>p</code>.
    </p>
  </li>
  <li>
    <p>
      <code>RET</code>: Jump to the source of the current
      cross-reference.
    </p>
  </li>
  <li>
    <p>
      <code>TAB</code>: Hide Xref buffer and jump to the source.
    </p>
  </li>
  <li>
    <p>
      <code>C-o</code>: Show the source of the cross-reference at
      point in a separate window but keep the point in the Xref
      window.  This is useful when we navigate the Xref buffer using
      normal Emacs commands like <code>C-p</code>, <code>C-n</code>,
      <code>C-s</code>, etc.  While navigating the Xref buffer with
      these normal Emacs commands, the source of the cross-references at
      the point is not automatically displayed.  The key
      sequence <code>C-o</code> helps us to display the cross-reference
      at the point in this case.
    </p>
  </li>
  <li>
    <p>
      <code>r</code>: Perform search and replace in the names of the
      references displayed in the Xref buffer.  However, I did not
      find this to be working successfully
      with <code>dumb-jump</code>.  Any attempt to use this command
      with <code>dumb-jump</code> always led me to the following
      error: <code>No suitable matches here</code>.  This key sequence
      does work as expected when Xref is invoked from Dired as going
      to be explained in the next section.
    </p>
  </li>
</ul>
<h3 id="xref-and-dired">Xref and Dired<a href="#xref-and-dired"></a></h3>
<p>
  Here are some key sequences that demonstrate how we can use Xref
  with Dired.
</p>
<ul>
  <li>
    <code>C-x d RET</code>: Edit current directory using Dired.
  </li>
  <li>
    <code>n</code>: Move to the next line.  <code>C-n</code> also
    works.
  </li>
  <li>
    <code>p</code>: Move to the previous line.  <code>C-p</code> also
    works.
  </li>
  <li>
    <code>m</code>: Mark the file or subdirectory at the point.
  </li>
  <li>
    <code>u</code>: Unmark the file or subdirectory at the point.
  </li>
  <li>
    <code>A f.. RET</code>: Find all matches for the regular
    expression <code>f..</code> in the marked files and
    subdirectories.  The matches are always displayed in an Xref
    buffer, even when a single match is found.
  </li>
  <li>
    <code>Q f.. RET bar RET</code>: Find all matches for the regular
    expression <code>f..</code> in the marked files and subdirectories
    and replace them with <code>bar</code>.
  </li>
</ul>
<h2 id="working-with-log-files">Working with Log Files<a href="#working-with-log-files"></a></h2>
<p>
  In this section of the book, it discusses a set of commands that are
  useful for working with log files.  Note that some of these commands
  have been already introduced in the previous chapters.  The
  following list presents the commands discussed in this section of
  the book:
</p>
<ul>
  <li>
    <code>C-x C-f</code>: Find a file.
  </li>
  <li>
    <code>C-x C-r</code>: Find file and open in read-only mode.
  </li>
  <li>
    <code>C-x C-q</code>: Toggle read-only mode.
  </li>
  <li>
    <code>M-x flush-lines RET b.. RET</code>: Delete lines in region
    that match the regular expression <code>b..</code>.  If no region
    is active, then delete matching lines between the point and end of
    buffer.  The deleted lines are not copied to kill ring.  See
    section <a href="ch05.html#deleting-and-keeping-lines">Deleting
    and Keeping Lines</a> of chapter 5 notes for more details.
  </li>
  <li>
    <code>M-x keep-lines RET b.. RET</code>: Keep lines in region that
    match the regular expression <code>b..</code> and delete the rest.
    If no region is active, then keep matching lines between the point
    and end of buffer and delete the rest.  The deleted lines are not
    copied to kill ring.  See section
    <a href="ch05.html#deleting-and-keeping-lines">Deleting and
    Keeping Lines</a> of chapter 5 notes for more details.
  </li>
  <li>
    <code>M-s o b.. RET</code>: Show all lines in the current buffer
    matching the regular expression <code>b..</code>.  If the region
    is active, then show matching lines from the region only.  The
    matches are shown in a new Occur mode buffer.  The book makes a
    special mention that we can run <code>M-s o</code> on an Occur
    mode buffer to filter it further and get the results in another
    Occur mode buffer.  See section
    <a href="ch04.html#occur-mode">Occur Mode</a> in chapter 4 notes
    for more details.
  </li>
</ul>
<h2 id="highlighting">Highlighting<a href="#highlighting"></a></h2>
<p>
  Section <em>Working with Log Files</em> of Chapter 6 of the book
  also introduces highlighting commands that can be very useful for
  highlighting certain strings in the log file.  The highlighting
  commands are demonstrated below with an example.
</p>
<ol>
  <li>
    <p>
      First create a buffer with the following content.
    </p>
<pre>
<code>foo bar baz
Foo Bar Baz
FOO BAR BAZ
foo  bar  baz
Foo  Bar  Baz
FOO  BAR  BAZ</code>
</pre>
  </li>
  <li>
    <p>
      Now type <code>M-s h p f.. SPC b.. RET RET</code> to highlight
      the phrases matching the regular expression <code>f.. b..</code>
      in a case-insensitive and whitespace-insensitive manner.  A
      total of six matches will be highlighted because the first two
      words and the whitespace between them in all lines match this
      phrase pattern when we ignore the case of the words and the
      amount of whitespace.  The second <code>RET</code> is meant to
      accept the default face offered to us for highlighting.
    </p>
  </li>
  <li>
    <p>
      Now type <code>M-s h p b.z RET RET</code> to highlight the
      phrases matching the regular expression <code>b.z</code>.  Again
      we select the default face offered to us for highlighting.  At
      this point, we should see two sets of highlighting in two
      different faces.
    </p>
  </li>
  <li>
    <p>
      Now move the cursor to one of the first set of highlights and
      type <code>M-s h u RET</code>.  Those highlights will be
      unhighlighted.  The <code>RET</code> key accepts the default
      unhighlighting pattern offered to us.  It happens to be the
      pattern with which the highlight under the cursor was
      highlighted.  That is why this key sequence ends up
      unhighlighting the highlight under the cursor.
    </p>
    <p>
      If the cursor were not over a highlgiht, then the default
      unhighlighting pattern offered to us would have been the pattern
      we used for the last highlight.  In that case, we could
      type <code>M-s h u f.. b.. RET</code> to explicitly specify the
      unhighlighting pattern.
    </p>
  </li>
  <li>
    <p>
      Now type <code>M-s h u RET</code> again to remove the second set
      of highlights too.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h p F.. SPC B.. RET RET</code> to perform a
      case-sensitive but whitespace-insensitive highlighting.  When
      there is an uppercase letter in the pattern, the highlighting
      becomes case-sensitive.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h u RET</code> to remove the previous
      highlighting.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h r f.. SPC b.. RET RET</code> to perform a
      case-insensitive but whitespace-sensitive highlighting.  This
      time, there are only three matches from the first three lines.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h u RET</code> to remove the previous
      highlighting.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h r F.. SPC B.. RET RET</code> to perform a
      case-sensitive and whitespace-sensitive highlighting.  The
      matching strings are found in the second and third lines.
    </p>
  </li>
  <li>
    <p>
      Move the cursor to lowercase <code>bar</code> and type <code>M-s
      h .</code> to highlight symbol at point.  All six occurrences of
      this symbol are highlighted in a case-insensitive manner because
      the symbol at point is written in all lowercase.
    </p>
  </li>
  <li>
    <p>
      Move the cursor to <code>Baz</code> and type <code>M-s h
      .</code> to highlight symbol at point.  Only two occurrences of
      this symbol get highlighted.  The highlighted symbols match the
      symbol <code>Baz</code> exactly (case-sensitive match).  The
      highlighting is done in case-sensitive manner because the symbol
      at point has at least one uppercase letter.
    </p>
  </li>
</ol>
<h2 id="auto-revert-mode">Auto-Revert Mode<a href="#auto-revert-mode"></a></h2>
<p>
  The following steps demonstrate how to use
  the <code>revert-buffer</code> command and then how to
  use <code>auto-revert-mode</code>.
</p>
<ol>
  <li>
    <p>
      In a terminal, run the following command:
    </p>
    <pre><code>: &gt; /tmp/log.txt &amp;&amp; while true; do date &gt;&gt; /tmp/log.txt; sleep 1; done</code></pre>
    <p>
      You could use <code>ansi-term</code> within Emacs too as the
      terminal if you are familiar with it.
    </p>
  </li>
  <li>
    <p>
      Now within Emacs, type <code>C-x C-f /tmp/log.txt RET</code>.
    </p>
  </li>
  <li>
    <p>
      Wait for a few seconds and type <code>M-x revert-buffer RET yes
      RET</code> to update the buffer with the latest content of the
      file from the file system.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-x auto-revert-mode RET</code> to enable automatic
      update of the buffer as the file changes on the file system.
      Note that this reloads the entire file whenever a change is
      detected, so this could be inefficient while working with very
      large files.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-&gt;</code> to go to the end of the buffer.  This
      moves the cursor to the end of the buffer.  Doing this ensures
      that as the buffer is automatically updated, the cursor
      automatically keeps moving to the end of the file.
    </p>
  </li>
  <li>
    <p>
      Terminate the command of step 1 and run this command in a
      terminal:
    </p>
    <pre><code>echo hello &gt; /tmp/log.txt</code></pre>
    <p>
      The content of the buffer should now automatically truncate and
      update to just the text <code>hello</code>.
    </p>
  </li>
  <li>
    <p>
      Run the command in step 1 again and confirm that the content of
      the buffer in Emacs gets updated automatically.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-x auto-revert-mode RET</code> to disable automatic
      update of the buffer.
    </p>
  </li>
</ol>
<h2 id="auto-revert-tail-mode">Auto Revert Tail Mode<a href="#auto-revert-tail-mode"></a></h2>
<p>
  The mode named <code>auto-revert-tail-mode</code> is similar
  to <code>auto-revert-mode</code>.  However,
  unlike <code>auto-revert-mode</code> which reloads the entire file
  on every update, the <code>auto-revert-tail-mode</code> only follows
  the tail of the buffer and appends any new text found to the buffer.
  The following steps demonstrate this:
</p>
<ol>
  <li>
    <p>
      Like in the previous section, run the following command:
    </p>
    <pre><code>: &gt; /tmp/log.txt &amp;&amp; while true; do date &gt;&gt; /tmp/log.txt; sleep 1; done</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-x auto-revert-tail-mode RET</code>.  Note that this
      command follows the tail of the file only.  It does not reload
      the entire file.  This can be confirmed with the next step.
    </p>
  </li>
  <li>
    <p>
      Terminate the command of step 1 and run this command in a
      terminal:
    </p>
    <pre><code>echo hello &gt; /tmp/log.txt</code></pre>
    <p>
      The buffer for this file in Emacs should automatically update to
      show the text <code>hello</code> at the bottom.  But notice all
      the earlier text remains intact.  The earlier text does not
      disappear from the buffer because Emacs does not reload the
      entire file when <code>auto-revert-tail-mode</code> is enabled.
    </p>
  </li>
  <li>
    <p>
      Run the command in step 1 again and confirm that the content of
      the buffer begins to get updated automatically again.
    </p>
  </li>
  <li>
    <p>
      As of Emacs 28.2, unfortunately running <code>M-x
      auto-revert-tail-mode RET</code> is not sufficient to disable
      automatic updates in the buffer.  This command does disable the
      mode but the buffer continues to be updated everytime the file
      changes.  This is very likely a bug in this mode.
    </p>
    <p>
      As a workaround, disabling <code>auto-revert-mode</code> ends up
      stopping the auto-update behaviour.  There are two ways to do
      this.  You could type <code>M-x auto-revert-mode RET</code>
      twice: once to enable it and a second time to disable it.
      Alternatively, just simply type <code>C-0 M-x auto-revert-mode
      RET</code> which invokes the mode with a prefix argument of zero
      which ends up disabling the mode.
    </p>
  </li>
</ol>
<h2 id="browsing-tarballs">Browsing Tarballs<a href="#browsing-tarballs"></a></h2>
<p>
  The following steps demonstrate how we can not only browse a tarball
  but also edit files in it and save them back to the tarball.
</p>
<ol>
  <li>
    <p>
      First, create a directory of text files with the following shell
      commands:
    </p>
<pre>
<code>mkdir -p foo/bar/baz/
echo hello foo &gt; foo/foo.txt
echo hello bar &gt; foo/bar/bar.txt
echo hello baz &gt; foo/bar/baz/baz.txt
tar -caf /tmp/foo.tgz foo/</code>
</pre>
  </li>
  <li>
    <p>
      Confirm that the tarball looks good with these shell commands:
    </p>
<pre>
<code>tar -tf /tmp/foo.tgz
tar -xOf /tmp/foo.tgz</code>
</pre>
  </li>
  <li>
    <p>
      Within Emacs, type <code>C-x C-f /tmp/foo.tgz RET</code> to open
      the tarball.  A list of all entries in the tarball is displayed
      in a Tar buffer.
    </p>
  </li>
  <li>
    <p>
      Type <code>n</code> and <code>p</code> to navigate the Tar
      buffer down and up respectively.
    </p>
  </li>
  <li>
    <p>
      With the cursor on the line
      containing <code>foo/bar/baz/baz.txt</code>,
      type <code>RET</code>.  The content of this entry is now
      displayed in a new buffer.
    </p>
  </li>
  <li>
    <p>
      Now in the buffer that displays the content
      of <code>baz.txt</code>, edit its content.  Say, type <code>C-a
      !</code> to append an exclamation point to this buffer.
    </p>
  </li>
  <li>
    <p>
      Type <code>C-x C-s</code> to save this buffer.  This updates the
      entry of <code>foo/bar/baz/baz.txt</code> within the buffer
      for <code>foo.tgz</code>.  However, the updated tarball is not
      written to the file system yet.
    </p>
  </li>
  <li>
    <p>
      Type <code>C-x b foo.tgz RET</code> to go back to the buffer
      with the tarball entry listing.
    </p>
  </li>
  <li>
    <p>
      Finally, type <code>C-x C-s</code> to save the tarball to the
      file system.
    </p>
  </li>
  <li>
    <p>
      Now repeat step 2.  The updated content
      of <code>foo/bar/baz/baz.txt</code> should now appear in the
      output.
    </p>
  </li>
</ol>
<h2 id="dired-thumbnail-image-browser">Dired: Thumbnail Image Browser<a href="#dired-thumbnail-image-browser"></a></h2>
<p>
  Assuming there is a directory <code>~/foo/</code> that contains
  several image files as well as files of other types, the
  command <code>M-x image-dired RET ~/foo/ RET</code> creates a
  preview buffer of all images in the directory and displays it along
  with a normal dired buffer showing the directory listing.  Both
  buffers are displayed in two separate windows.
</p>
<p>
  When the preview buffer is first launched, all image files found in
  the directory are automatically <em>marked</em>.  This can be seen
  in the Dired buffer.  However the preview buffer does not reflect
  this immediately.  Type <code>m</code> in the preview buffer to
  force it to pick the current list of marked images and highlight
  them.
</p>
<p>
  As a best practice, remember to type <code>m</code> soon after
  launching <code>image-dired</code> so that the marked images are
  accurately displayed in the preview buffer.
</p>
<p>
  Within the preview buffer, the following key sequences are
  supported:
</p>
<ul>
  <li>
    <code>C-f</code>: Move to next image.
  </li>
  <li>
    <code>C-b</code>: Move to the previous image.
  </li>
  <li>
    <code>C-n</code>: Move to next row of images.
  </li>
  <li>
    <code>C-p</code>: Move to previous row of images.
  </li>
  <li>
    <code>RET</code>: Display the original image in a display buffer.
  <li>
    <code>m</code>: Mark an image file.
  </li>
  <li>
    <code>u</code>: Unmark an image file.
  </li>
  <li>
    <code>d</code>: Flag an image file for deletion.
  </li>
  <li>
    <code>t t</code>: Tag marked thumbnails.  If no thumbnails are
    marked, tag the current thumbnail.
  </li>
  <li>
    <code>t r</code>: Remove tag from marked thumbnails.  If no
    thumbnails are marked, remove tag from the current thumbnail.
  </li>
  <li>
    <code>l</code>: Rotate thumbnail left.
  </li>
  <li>
    <code>r</code>: Rotate thumbnail right.
  </li>
</ul>
<h3 id="preview-buffer-quirks">Preview Buffer Quirks<a href="#preview-buffer-quirks"></a></h3>
<p>
  The <code>m</code>, <code>u</code> or <code>d</code> commands in the
  preview buffer are actually meant to mark, unmark or flag the
  corresponding files in the Dired buffer.  The highlighting or
  unhighlighting that occurs in the preview buffer is merely a
  convenience feature.  The preview buffer may not always accurately
  reflect the most recent list of all marked and flagged files.
  Always keep an eye on the Dired buffer to check the most recent
  state of the files.
</p>
<p>
  Especially, if we go back to the Dired buffer and mark, unmark or
  flag files, the preview buffer does not reflect it automatically.
  We need to go to the preview buffer again and perform at least one
  similar operation (<code>m</code>, <code>u</code> or
  <code>d</code>) in the preview buffer for it to be updated again.
  This is why it is important to keep an eye on the Dired buffer to
  get an accurate account of which files are marked or flagged.
</p>
<h3 id="working-on-marked-files">Working on Marked Files<a href="#working-on-marked-files"></a></h3>
<p>
  Say we have marked some image files using the key
  sequence <code>m</code> in the preview buffer.  Now we can perform
  various operations on these marked files.  For example, to copy the
  marked files to <code>/tmp/</code> directory, in a Dired buffer,
  type <code>C /tmp/ RET</code>.  To move them instead, type <code>R
  /tmp/</code>.
</p>
<h3 id="deleting-images">Deleting Images<a href="#deleting-images"></a></h3>
<p>
  When we flag thumbnails by typing <code>d</code> in the preview
  buffer, the corresponding files are flagged for deletion in the
  Dired buffer.  The first column of the flagged file entries contain
  the letter <code>D</code> in the Dired buffer.  Type <code>x</code>
  in the Dired buffer to permanently delete (expunge) the flagged
  files.
</p>
<h3 id="tagging-and-untagging">Tagging and Untagging<a href="#tagging-and-untagging"></a></h3>
<p>
  If there are marked images, then the tagging and untagging commands
  executed in the preview buffer work on those marked images.
  Otherwise, they work on image corresponding to the current
  thumbnail.  We will refer to these images that the tagging or
  untagging commands work on as <em>target</em> images in the next few
  paragraphs..
</p>
<p>
  The key sequence <code>t t trip;oxford;uk RET</code> tags the target
  images with the tags <code>trip</code>, <code>oxford</code>
  and <code>uk</code>.  The tags must be separated by semicolon as
  shown in the preceding example.  The tags are saved in a path set in
  the <code>image-dired-db-file</code> variable.  Type <code>C-h v
  image-dired-db-file</code> to read this path.  Typically, it is
  something like <code>~/.emacs.d/image-dired/.image-dired_db</code>.
  We will call this the DB file.  This file may be manually inspected
  to see how this command and the next command affect the tags for
  each thumbnail.  Alternatively, type <code>C-t e</code> in a Dired
  buffer to view and edit the tags of the target files.
</p>
<p>
  The key sequence <code>t r trip RET</code> removes the
  tag <code>trip</code> from the target images.  By virtue of how this
  functionality is implemented, a key sequence like <code>t r
  t.*d</code> removes the tags <code>trip;oxford</code>
  and <code>trip;salford</code> (if present) from the DB file but it
  does not remove a tag like <code>trip;cambridge</code> (if present).
</p>
<h3 id="using-tags">Using Tags<a href="#using-tags"></a></h3>
<p>
  Tagging thumbnails could be useful if we want to later mark files by
  tags.  In a Dired buffer, the key sequence <code>C-t f t.*d</code>
  will mark all files whose thumbnails have tags (as they appear in
  the tags file) matching the regular expression <code>t.*d</code>.
  For example, images that have with tags <code>trip;oxford;uk</code>
  as well as <code>trip;london;uk</code> will be marked but images
  with tags <code>trip;bath;uk</code>
  and <code>trip;liverpool;uk</code> will not be marked.
</p>
<h3 id="display-buffer">Display Buffer<a href="#display-buffer"></a></h3>
<p>
  When we type <code>RET</code> in the preview buffer, the original
  image is displayed in a display buffer.  The following key sequences
  are supported in the display buffer:
</p>
<ul>
  <li>
    <code>s</code>: Resize image to fit window.
  </li>
  <li>
    <code>f</code>: Display current image in full size.
  </li>
  <li>
    <code>q</code>: Quit window.
  </li>
</ul>
<p>
  The book makes a note that when we open an image file directly from
  a Dired buffer, the image is opened in <code>image-mode</code> which
  is more powerful than the display buffer we get when we open an
  image from the thumbnail preview window.
</p>
<h2 id="docview">DocView<a href="#docview"></a></h2>
<p>
  When a PDF or another document of a supported format is opened in
  Emacs, they are converted to images on the fly and displayed in
  Emacs.  In this section, we will discuss working with PDFs only.
  The converted images are cached at the directory set in
  the <code>doc-view-cache-directory</code> variable.
</p>
<p>
  Type <code>C-h v auto-mode-alist RET</code> and search
  for <code>doc-view</code> in the help buffer to see the list of file
  formats that Emacs tries to open in DocView.
</p>
<p>
  Ghostscript needs to be installed so that DocView can convert the
  PDF into images.  Further, for some commands where we perform
  text-based operations on the PDF, we need the <code>pdftotext</code>
  command so that DocView can extract text from the PDF.
  Type <code>C-h v doc-view-ghostscript-program RET</code>
  and <code>C-h v doc-view-pdftotext-program RET</code> to see the
  external programs that DocView depends on.  These programs can be
  installed with the following command on a Debian or Debian-based
  Linux distribution:
</p>
<pre><code>apt-get install ghostscript poppler-utils</code></pre>
<p>
  On a macOS system, run the following command instead:
</p>
<pre><code>brew install ghostscript poppler</code></pre>
<p>
  The following list presents some of the key bindings supported by
  DocView:
</p>
<ul>
  <li>
    <code>n</code>: Go to next page.
  </li>
  <li>
    <code>p</code>: Go to previous page.
  </li>
  <li>
    <code>C-x ]</code>: Same as <code>n</code>.
  </li>
  <li>
    <code>C-x [</code>: Same as <code>p</code>.
  </li>
  <li>
    <code>SPC</code>: Scroll up if possible or go to next page.
  </li>
  <li>
    <code>DEL</code>: Scroll down if possible or go to the previous page.
  </li>
  <li>
    <code>S-SPC</code>: Same as above.
  </li>
  <li>
    <code>M-&lt;</code>: View the first page.
  </li>
  <li>
    <code>M-&gt;</code>: View the last page.
  </li>
  <li>
    <code>+</code>: Enlarge the document.
  </li>
  <li>
    <code>-</code>: Shrink the document.
  </li>
  <li>
    <code>0</code>: Reset the document size to the initial one.
  </li>
  <li>
    <code>W</code>: Fit the image width to the window width.
  </li>
  <li>
    <code>H</code>: Fit the image height to the window height.
  </li>
  <li>
    <code>P</code>: Fit the image to the window such that neither the
    document width nor the document height exceed the window width or
    height respectively.
  </li>
  <li>
    <code>F</code>: Resize the window so it just fits the page.  When
    there is only window in the frame, the window cannot be resized
    independently of the frame, so the frame is resized instead.
  </li>
  <li>
    <code>M-x doc-view-presentation RET</code>: Display document in
    presentation mode, i.e. as a full screen slide show.
  </li>
</ul>
<p>
  Although not mentioned in the book, here are some commands that show
  how to perform text-based operations on the PDF.  These commands
  need <code>pdftotext</code> to be installed.
</p>
<ul>
  <li>
    <code>C-s ^f..\&gt; RET</code>: Initiate a new search for lines
    that begin with a three-lettered word beginning with the
    letter <code>f</code>.  The cursor does not move to the first
    match automatically.  To make the cursor move to the first match,
    type <code>C-s</code>.  This is also explained in the next point.
  </li>
  <li>
    <code>C-s</code>: When a search has been initiated, jump to the
    next match for the last search that was initiated.
  </li>
  <li>
    <code>C-u C-s ^b..\&gt; RET</code>: Initiate a new search.  This
    is useful when a search was already initiated and we want to
    abandon that search and start another new search.
  </li>
  <li>
    <code>C-r</code>: Similar to <code>C-s</code> but works in reverse
    direction.  All three commands mentioned above work
    with <code>C-r</code> too.
  </li>
  <li>
    <code>C-t</code>: Show tooltip for the current location.
    Normally, this shows a tooltip like "Page 100 of 314" to describe
    the current page.  When a search is in progress, the tooltip
    includes all the matches from the current page too.
  </li>
  <li>
    <code>C-c C-t</code>: Show the current document's content as text.
    Then type the key sequence <code>C-c C-c</code> to switch to
    editing the document and <code>C-c C-c</code> again to switch to
    viewing the document.  The key sequence <code>C-c C-c</code> is
    elaborated a little more in the next point.
  </li>
  <li>
    <code>C-c C-c</code>: Toggle between editing or viewing the
    document.  In case of PDF, switching to editing the document may
    not be very helpful because the binary code of the document is
    opened for editing in this mode which is quite non-trivial to edit
    directly.
  </li>
</ul>
<h3 id="docview-resolution">DocView Resolution<a href="#docview-resolution"></a></h3>
<p>
  If the text in the document looks pixelated in Emacs, set
  the <code>doc-view-resolution</code> variable to 300 as follows:
</p>
<pre><code>(setq doc-view-resolution 300)</code></pre>
<p>
  This sets the dots per inch resolution used to render the documents
  to 300.  This offers a good trade-off between high quality rendering
  and fast rendering.  After setting this variable, type the following
  key sequences:
</p>
<ul>
  <li>
    <code>M-x doc-view-clear-cache RET</code> to delete the cache
    directory.
  </li>
  <li>
    <code>C-x k</code> to kill the existing DocView buffer (if any).
  </li>
  <li>
    <code>C-x C-f document.pdf RET</code> to open the document
    (say <code>document.pdf</code>) again!
  </li>
</ul>
<p>
  Clearing the cache directory and reopening the document in this
  manner regenerates the images from the documents with the updated
  resolution.
</p>
<h2 id="tramp">TRAMP<a href="#tramp"></a></h2>
<p>
  TRAMP stands for Transparent Remote Access, Multiple Protocol.  The
  general syntax of paths supported by TRAMP is:
</p>
<pre><code>/method:[user@][hostname[#port]]:[path]</code></pre>
<p>
  Here
  are some complete key sequences that demonstrate various ways to
  open a remote file using TRAMP:
</p>
<ul>
  <li>
    <code>C-x C-f /ssh:alice@box:~/foo.txt RET</code>: Edit file in a
    remote host via SSH.
  </li>
  <li>
    <code>C-x C-f /ssh:susam@box#22:~/foo.txt RET</code>: Same as
    above.  However the port is explicitly specified this time.
  </li>
  <li>
    <code>C-x C-f /scp:alice@box:~/foo.txt RET</code>: Edit file in a
    remote host via SCP.
  </li>
  <li>
    <code>C-x C-f /ssh:box:~/foo.txt RET</code>: Edit file in a
    remote host via SSH after logging into it with the username of the
    current user in the current shell.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@:~/foo.txt RET</code>: Edit file in
    localhost via SSH after logging into it as a specific user.
  </li>
  <li>
    <code>C-x C-f /ssh::~/foo.txt RET</code>: Edit file in localhost
    via SSH after logging into it with the username of the current
    user in current shell.
  </li>
  <li>
    <code>C-x C-f /sudo::/etc/hosts</code>: Edit file as superuser.
  </li>
  <li>
    <code>C-x c-f /sudo:alice@:~/foo.txt RET</code>: Edit file as
    a specific user.
  </li>
  <li>
    <code>C-x C-f /sudoedit::/etc/hosts</code>: Edit file as superuser
    but do not keep an open session running in the background for
    security reasons.  This method has worse performance than
    the <code>sudo</code> method.
  </li>
  <li>
    <code>C-x C-f /su::/etc/hosts</code>: Edit file as
    the <code>root</code> user.
  </li>
  <li>
    <code>/su:alice@:~/foo.txt</code>: Edit file as a specific user.
  </li>
  <li>
    <code>/su:alice@localhost:~/foo.txt</code>: Same as above.
  </li>
  <li>
    <code>C-x C-f /sudo:: RET</code>: Browse the <code>root</code>
    user's home directory as superuser.
  </li>
  <li>
    <code>C-x C-f /su:: RET</code>: Browse the <code>root</code>
    user's home directory with Dired.
  </li>
  <li>
    <code>C-x C-f /-:: RET</code>:
    Use <code>tramp-default-method</code> (<code>scp</code> by
    default) to connect to <code>tramp-default-host</code>
    (current <code>hostname</code> by default).  With the default
    values of these variables, this leads to connecting to the local
    system as the current user via SCP and browsing the current user's
    home directory in Dired.
  </li>
</ul>
<p>
  This chapter recommends looking up the info manual
  page <code>(tramp) Internal methods</code> but this is very likely
  an error.  For example, evaluating <code>(info "(tramp)Internal
  methods")</code> leads to the following error:
</p>
<pre><code>user-error: No such node or anchor: Internal methods</code></pre>
<p>
  Instead evaluate <code>(info "(tramp)Inline methods")</code> to
  reach the correct node that describes the various connection
  methods.
</p>
<h3 id="default-directory">Default Directory<a href="#default-directory"></a></h3>
<p>
  The variable <code>default-directory</code> is buffer local.
  Typically, this is automatically set to the directory where Emacs
  was launched or to the directory of the currently visited file.
  Commands like <code>C-x C-f</code> defaults to looking up files in
  this directory.
</p>
<p>
  While editing a remote file via TRAMP, the value for this variable
  may look something like <code>/ssh:alice@box:/home/alice/</code>.
  The <code>@</code> character is displayed in the mode line while
  editng a remote file.
</p>
<p>
  The chapter presents the following examples of commands that work
  seamlessly on a remote machine:
</p>
<ul>
  <li>
    <code>C-x d</code>: Manage remote files and directories.  We can
    even copy files (using the key sequence <code>C</code>) between
    remote and local dired sessions.
  </li>
  <li>
    <code>M-x compile RET RET</code>: Run <code>make -k</code> (the
    default) or an arbitrary command remotely.  The result is shown in
    the <code>*compilation*</code> buffer.
  </li>
  <li>
    <code>M-x rgrep RET f.. RET *.txt RET RET</code>:
    Use <code>find</code> and <code>grep</code> together to search for
    the pattern <code>f..</code> in files matching the
    pattern <code>*.txt</code> in the current remote directory.
  </li>
  <li>
    <code>M-x shell RET</code>: Open shell on the remote system in the
    current remote directory.
  </li>
  <li>
    <code>M-x eshell RET</code>: Open Eshell on the remote system in
    the current remote directory.
  </li>
</ul>
<p>
  With Eshell we can go directly into remote directories seamlessly.
  The following Eshell session illustrates this:
</p>
<pre>
<samp>Welcome to the Emacs shell

~ $ <kbd>uname</kbd>
Darwin
~ $ <kbd>cd /ssh:alice@box:~/foo/</kbd>
/ssh:alice@box:/home/alice/foo $ <kbd>hostname</kbd>
debian
/ssh:alice@box:/home/alice/foo $</samp>
</pre>
<h3 id="multi-hops">Multi-Hops<a href="#multi-hops"></a></h3>
<p>
  Here are some commands that illustrate how multi-hops work:
</p>
<ul>
  <li>
    <code>C-x C-f /ssh:alice@box|ssh:bob@localhost:~/foo.txt
    RET</code>: First log in as <code>alice</code>
    into <code>box</code> and then from there log in
    as <code>bob</code> into the same system.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|sudo:box:/etc/hosts RET</code>: First
    log in as <code>alice</code> into <code>box</code> and then edit
    file as superuser.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|sudo::/etc/hosts RET</code>: Same as
    above.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|sudo:bob@box:~/bar.txt RET</code>:
    First log in as <code>alice</code> into <code>box</code> and then
    use <code>sudo</code> to edit file as <code>bob</code> in the
    latter user's home directory.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|su::/etc/hosts RET</code>: First log
    in as <code>alice</code> into <code>box</code> and then edit file
    as <code>root</code>.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|su:bob@:~/bar.txt RET</code>: First log
    in as <code>alice</code> into <code>box</code> and then edit file
    as <code>bob</code>.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|su:bob@box:~/bar.txt RET</code>: Same
    as above.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:~/foo.txt</code>:
    An example of two hops.
  </li>
</ul>
<p>
  Bookmarks with key sequences like <code>C-x r m</code>
  (<code>bookmark-set</code>), <code>C-x r l</code>
  (<code>bookmark-bmenu-list</code>) and <code>C-x r b</code>
  (<code>bookmark-jump</code>) work seamlessly for remote files
  (including multi-hops).
</p>
<p>
  Eshell works seamlessy too across multi-hops.  Here is an Eshell
  session that illustrates it:
</p>
<pre>
<samp>~ $ <kbd>uname</kbd>
Darwin
~ $ <kbd>cd '/ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:/home/carol/foo/bar/'</kbd>
/ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:/home/carol/foo/bar $ <kbd>uname</kbd>
Linux
/ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:/home/carol/foo/bar $</samp>
</pre>
<h2 id="eww">EWW: Emacs Web Wowser<a href="#eww"></a></h2>
<p>
  The following commands are useful to get started with EWW.
</p>
<ul>
  <li>
    <code>M-x eww RET hello RET</code>: Search for the word "hello"
    with DuckDuckGo.  If the buffer <code>*eww*</code> already exists,
    then reuse that buffer, otherwise create such a buffer.  The
    search engine can be customised by setting the
    variable <code>eww-search-prefix</code> (it
    is <code>"https://duckduckgo.com/html/?q="</code> by default).
  </li>
  <li>
    <code>C-u M-x eww RET hello RET</code>: Like previous command
    except that it creates a new EWW buffer.
  </li>
  <li>
    <code>M-x eww RET example.net RET</code>: Visit the
    URL <a href="http://example.net/">http://example.net</a>.  Reuses
    the <code>*eww*</code> buffer if it exists.
  </li>
  <li>
    <code>M-x eww RET http://example.net/ RET</code>: Same as above.
  </li>
  <li>
    <code>C-u M-x eww RET example.net RET</code>: Like before but
    creates a new EWW buffer.
  </li>
</ul>
<p>
  In the EWW buffer, the following navigation keys work:
</p>
<ul>
  <li>
    <code>TAB</code>: Skip to the next link.
  </li>
  <li>
    <code>S-TAB</code> or <code>C-M-i</code>: Skip to the previous link.
  </li>
  <li>
    <code>RET</code>: Browse the URL under point.
  </li>
  <li>
    <code>C-u RET</code>: Browse the URL under point using an external
    browser.  This is especially useful when we know that the URL we
    want to open does not render well in EWW.
  </li>
  <li>
    <code>&amp;</code>: Open the current page in an external browser.
    Note that unlike the previous command, this command opens
    the <em>current</em> page.  The previous command opens the URL
    under point instead.
  </li>
  <li>
    <code>q</code>: Quit EWW.
  </li>
  <li>
    <code>l</code>: Go to the previously displayed page.
  </li>
  <li>
    <code>r</code>: Go to the next displayed page.
  </li>
  <li>
    <code>b</code>: Bookmark the current page.
  </li>
  <li>
    <code>B</code>: Show bookmarks.
  </li>
  <li>
    <code>H</code>: Show history of the current EWW buffer.  The most
    recently visited URLs are displayed on top and the oldest ones are
    shown at the bottom.  The current URL is not displayed in the
    history.  Only the older URLs are shown in the history.
  </li>
  <li>
    <code>R</code>: View the main "readable" parts of the current
    page.  This command uses heuristics to find the parts of the web
    page that contains the main content and omits the non-content part
    like navigation menus etc.
  </li>
  <li>
    <code>M-s M-w</code>: Search the web for the text in the region.
    If there is no region, then prompt for a search string.
  </li>
  <li>
    <code>M-RET</code>: Open link in a new EWW buffer.
  </li>
  <li>
    <code>s</code>: Prompt for an EWW buffer to display and switch to
    the selected buffer.  This is similar to changing to tabs in a
    desktop web browser.
  </li>
  <li>
    <code>w</code>: If the point is on a URL or just after a URL, then
    copy that URL to the kill ring.  If the point is at any other
    place, copy the URL of the current page.
  </li>
</ul>
<p>
  Further, EWW supports a few semantic browsing methods.  The
  pertaining commands are presented below.  However note that whether
  these commands would work on a page or not depends on whether the
  page provides the relevant navigation aids required by these
  commands.  Here are the key sequences for such commands:
</p>
<ul>
  <li>
    <code>p</code>: Go to the page marked <em>previous</em>.  A page
    is marked <em>previous</em> if there is
    a <code>&lt;link&gt;</code> tag or an <code>&lt;a&gt;</code> tag
    for it with the attribute <code>rel="prev"</code> (a standard
    value for the attribute) or <code>rel="previous"</code>
    (non-standard value supported by EWW).
  </li>
  <li>
    <code>n</code>: Go to the page marked <em>next</em>.  A page is
    marked <em>next</em> if there is a <code>&lt;link&gt;</code> tag
    or an <code>&lt;a&gt;</code> tag for it with the
    attribute <code>rel="next"</code>.
  </li>
  <li>
    <code>u</code>: Go to the page marked <em>up</em>.  A page is
    marked <em>up</em> if there is a <code>&lt;link&gt;</code>
    or an <code>&lt;a&gt;</code> tag for it with the
    attribute <code>rel="up"</code>.
  </li>
  <li>
    <code>t</code>: Go to the page marked <em>top</em>.  A page is
    marked <em>top</em> if there is a <code>&lt;link&gt;</code> tag or
    an <code>&lt;a&gt;</code> tag for it with the
    attribute <code>rel="start"</code> or <code>rel="home"</code>
    or <code>rel="contents"</code>.
  </li>
</ul>
<h2 id="invoking-external-browser">Invoking External Browser<a href="#invoking-external-browser"></a></h2>
<p>
  If we would rather open a URL using our desktop web browser, then we
  can use the <code>browse-url</code> command like this: <code>M-x
  browse-url RET http://example.net/ RET</code>.
</p>
<p>
  This command very conveniently picks up the word or domain name at
  the point or just before the point and uses that as the default
  value for the URL input.  Therefore if the cursor is already on a
  URL, then we can simply type <code>M-x browse-url RET RET</code> to
  visit it.
</p>
<h2 id="dired">Dired<a href="#dired"></a></h2>
<h3 id="dired-getting-started">Dired: Getting Started<a href="#dired-getting-started"></a></h3>
<p>
  There are several ways to start Dired.  Some examples are presented
  below:
</p>
<ul>
  <li>
    <code>C-x C-f ~/foo/bar/ C-d</code>: If IDO or FIDO mode is
    enabled, then this key sequence automatically opens Dired in the
    given directory path.  Essentially, while using <code>C-x
    C-f</code> with IDO/FIDO mode, we can type <code>C-d</code>
    anytime and Dired is opened in the path entered so far.
  </li>
  <li>
    <code>M-x dired RET ~/foo/bar/ RET</code>: Opens Dired in the
    given directory path.
  </li>
  <li>
    <code>M-x dired RET RET</code>: In the previous command, the
    default input is the path of the current directory
    (<code>default-directory</code>), so this key sequence
    conveniently opens Dired in the current directory.
  </li>
  <li>
    <code>C-x d</code>: Same as above.
  </li>
  <li>
    <code>C-x 4 d</code>: Like before but open Dired in another
    window.
  </li>
</ul>
<h3 id="dired-navigation">Dired: Navigation<a href="#dired-navigation"></a></h3>
<p>
  The following keys work in a Dired buffer:
</p>
<ul>
  <li>
    <code>RET</code>: Visit the file or directory on the current line.
  </li>
  <li>
    <code>^</code>: Go up by one directory.  If the parent directory
    is found in an existing buffer, then switch to that buffer.
    Otherwise create a new buffer to show the parent directory in
    Dired.
  </li>
  <li>
    <code>q</code>: Quit Dired window.  The buffer remains intact,
    i.e. the buffer is only buried, not killed.
  </li>
  <li>
    <code>C-u q</code>: Quit Dired window and kill the buffer.
  </li>
  <li>
    <code>p</code> or <code>C-p</code>: Move to the previous line and
    position the point on the filename.
  </li>
  <li>
    <code>n</code> or <code>C-n</code>: Move to the next line and
    position the point on the filename.
  </li>
</ul>
<p>
  Note that when we go from one Dired buffer to another (say, by
  typing <code>RET</code> to enter a subdirectory from a parent
  directory), then typing <code>q</code> or <code>C-u q</code> buries
  or kills (respectively) the current buffer and takes us back to the
  last Dired buffer.
</p>
<h3 id="dired-marking-and-unmarking">Dired: Marking and Unmarking<a href="#dired-marking-and-unmarking"></a></h3>
<p>
  The following list describes marking and unmarking commands of
  Dired:
</p>
<ul>
  <li>
    <code>m</code>: Mark the file or directory at point.  If the
    region is active, mark all files or directories in the region.
    Note that at least one character of the filename or directory name
    must lie within the region for a file to be marked.
  </li>
  <li>
    <code>u</code>: Unmark the file or directory at point.  If the
    region is active, unmark all files or directories in the region.
    Note that this also removes the flag for deletion (introduced
    later in this list).
  </li>
  <li>
    <code>U</code>: Unmark everything.  Note that this also removes
    flags for deletion.
  </li>
  <li>
    <code>d</code>: Flag the file or directory for deletion.  If the
    region is active, flag all files or directories in the region for
    deletion.
  </li>
</ul>
<p>
  The following key sequences describe the effects of prefix arguments
  with marking, unmarking and flagging commands:
</p>
<ul>
  <li>
    <code>C-5 m</code>: Mark 5 files from the current line to 4 more
    lines below.
  </li>
  <li>
    <code>C-5 u</code>: Unmark 5 files from the current line for
    deletion..
  </li>
  <li>
    <code>C-5 d</code>: Flag 5 files from the current line for deletion.
  </li>
  <li>
    <code>C-- C-1 m</code>: Mark the file on the previous line.
  </li>
  <li>
    <code>C-- C-1 u</code>: Unmark the file on the previous line.
  </li>
  <li>
    <code>C-- C-1 d</code>: Flag the file on the previous line for deletion.
  </li>
  <li>
    <code>C-- C-5 m</code>: Mark files in the 5 previous lines.
  </li>
  <li>
    <code>C-- C-5 u</code>: Unmark files in the 5 previous lines.
  </li>
  <li>
    <code>C-- C-5 d</code>: Flag files in the 5 previous lines for
    deletion.
  </li>
</ul>
<p>
  Additionally, the chapter mentions the following commands in a
  separate table but on Emacs 28.2, they seem to have the same effect
  as one of the commands discussed earlier:
</p>
<ul>
  <li>
    <code>* m</code>: Behaves the same as <code>m</code> and marks
    files.
  </li>
  <li>
    <code>* u</code>: Behaves the same as <code>u</code> and unmarks
    files.
  </li>
</ul>
<p>
  However the following commands (also introduced briefly in the same
  table but illustrated with complete key sequences below) provide
  additional marking and unmarking facilities:
</p>
<ul>
  <li>
    <code>* % f.. RET</code>: Mark files with names that match the
    regular expression <code>f..</code>.  If the region is active,
    then only the files in the region that match the pattern are
    marked.  The directories <code>.</code> and <code>..</code> are
    never marked.
  </li>
  <li>
    <code>% m f.. RET</code>: Same as above.
  </li>
  <li>
    <code>C-u * % f.. RET</code>: Unmark files with names that match
    the regular expression <code>f..</code>.  If the region is active,
    then only the files in the region that match the pattern are
    unmarked.  The directories <code>.</code> and <code>..</code> are
    never unmarked.
  </li>
  <li>
    <code>C-u % m f.. RET</code>: Same as above.
  </li>
  <li>
    <code>t</code> or <code>* t</code>: Toggle marks.  The marked
    files become unmarked and vice versa.  If the region is active,
    toggle the marks of only the files in the region.  The
    directories <code>.</code> and <code>..</code> are never toggled.
    Flagged files are not toggled.
  </li>
  <li>
    <code>* c * D</code>: Change all files marked with <code>*</code>
    to be now marked with <code>D</code> (i.e. flagged for deletion).
    Note that unlike the other commands, this command ignores the
    active region.  It performs the change in the whole buffer.
  </li>
  <li>
    <code>* c D SPC</code>: Change all files marked
    with <code>D</code> to be now unmarked.
  </li>
</ul>
<p>
  The chapter also mentions a key sequence <code>* .</code> to mark
  files by extension but this requires <code>dired-x</code>, so this
  is discussed in a later section of this page.
</p>
<h3 id="dired-operations">Dired: Operations<a href="#dired-operations"></a></h3>
<p>
  This section explains some operations we can perform in Dired.  If
  there are one or more items marked in the Dired buffer, then the
  operations work on the marked items.  Otherwise, the operations work
  on the item under the cursor.
</p>
<ul>
  <li>
    <code>C</code>: Copy marked files or copy the current file.  If
    one file is being copied, this command prompts for the target file
    path.  If multiple files are being copied, this command prompts
    for the target directory path.
  </li>
  <li>
    <code>R</code>: Rename marked files or the current file.  If one
    file is being renamed, this command prompts for the target file
    path.  If multiple file are being renamed, this command prompts
    for the target directory path.
  </li>
  <li>
    <code>O</code>: Change owner of the marked files or the current
    file.  A complete key sequence may look like <code>O root
    RET</code>.
  </li>
  <li>
    <code>G</code>: Change group of the marked files or the current
    file.  A complete sequence may look like <code>G wheel RET</code>.
  </li>
  <li>
    <code>M</code>: Change the mode of the marked files or the current
    file.  A complete key sequence may look like <code>M u+x
    RET</code> or <code>M 600 RET</code>.  Both symbolic modes
    like <code>u+x</code> and numeric modes like <code>600</code> are
    supported.
  </li>
  <li>
    <code>D</code>: Delete marked files, i.e. the files that are
    marked with <code>*</code> on the leftmost column of the Dired
    buffer.
  </li>
  <li>
    <code>x</code>: Delete the files flagged for deletion, i.e. the
    files that are marked with <code>D</code> on the leftmost column
    of the Dired buffer.
  </li>
  <li>
    <code>c</code>: Compress marked files or current file into an
    archive.  The archive file name is prompted.  The format of the
    archive is automatically deduced from the extension of the file
    name entered at the prompt.  A complete key sequence may look
    like <code>c foo.tar.gz RET</code> or <code>c foo.zip RET</code>.
  </li>
</ul>
<p>
  Note the difference between <code>D</code> and <code>x</code>.  The
  key <code>D</code> deletes marked files but the key <code>x</code>
  deletes flagged files.  Therefore there are two ways of deleting
  files:
</p>
<ul>
  <li>
    Mark files with <code>m</code> and delete them with <code>D</code>.
  </li>
  <li>
    Flag files with <code>d</code> and delete them with <code>x</code>.
  </li>
</ul>
<p>
  I normally prefer the second way of deleting files.  Since deleting
  file is a destructive operation which is possibly risky, I like to
  flag them first with <code>d</code> before deleting them
  with <code>x</code>.  In other words, I flag files for deletions and
  mark files for everything else.  Since I do not use
  the <code>D</code> key, I can be confident that my marked files are
  always safe and there is no risk of inadvertently deleting them.
</p>
<h3 id="dired-copying-or-renaming-between-buffers">Dired: Copying or Renaming Between Buffers<a href="#dired-copying-or-renaming-between-buffers"></a></h3>
<p>
  The following steps explain how we can copy or move files from one
  Dired buffer to another.  First we will see the default behaviour
  and then we will customise Dired to copy or move files to a
  particular Dired directory.
</p>
<ol>
  <li>
    Type <code>C-x d /usr/ RET</code>.
  </li>
  <li>
    Type <code>C-x 2</code>.
  </li>
  <li>
    Type <code>C-x d /tmp/ RET</code>.
  </li>
  <li>
    Type <code>C-x 2</code> agian.
  </li>
  <li>
    Type <code>C-x d /etc/ RET</code>.
  </li>
  <li>
    Move the cursor on some file in <code>/etc/</code> and then
    type <code>C</code> or <code>R</code> and we will see that the
    default directory to copy/move the file to is <code>/etc/</code>.
  </li>
  <li>
    Now type <code>(setq dired-dwim-target t)</code>.
  </li>
  <li>
    Now type <code>C</code> or <code>R</code> again while the cursor
    is on some file in <code>/etc/</code>.  We will see that the
    default directory to copy/move the file to is <code>/tmp/</code>
    now.  Since <code>dired-dwim-target</code> is set to non-nil,
    Dired picks the directory from the next window with a Dired buffer
    and uses that as the target buffer.
  </li>
</ol>
<h3 id="dired-more-keys">Dired: More Keys<a href="#dired-more-keys"></a></h3>
<p>
  Here are some examples of Dired keys that do not act on marked files
  but does other interesting work:
</p>
<ul>
  <li>
    <code>g</code>: Refresh the Dired buffer.
  </li>
  <li>
    <code>+</code>: Create directory.  A complete key sequence may
    look like <code>+ bar RET</code>.
  </li>
  <li>
    <code>s</code>: Toggle sorting by date.  By default, the items in
    the Dired buffer are sorted by file/directory names.
  </li>
  <li>
    <code>&lt;</code>: Jump to the next directory.
  </li>
  <li>
    <code>&gt;</code>: Jump to the previous directory.
  </li>
  <li>
    <code>j</code>: Jump to a file by name.  A complete sequence may
    look like <code>j hosts RET</code>.  Note that this only moves the
    cursor to the line in Dired buffer with the provided filename.  It
    does not visit the file.
  </li>
  <li>
    <code>M-s a C-s</code>: Perform multi-file incremental search
    through all marked files or the current file.  Marked directories
    are ignored.  Action region is also ignored.  It performs the
    search across all marked files.  A complete key sequence may look
    like <code>M-s a C-s foo</code> and then repeat <code>C-s</code>
    over and over again to jump through all the matches.  When the
    search reaches the end of one file, the next <code>C-s</code>
    automatically jumps to the match in the next file.
  </li>
  <li>
    <code>Q</code>: Perform multi-file regex-based search-and-replace
    operation through all marked files or the current file.  For any
    marked directories, the search-and-replace operation is performed
    in all its files recursively.  The active region is ignored.  A
    complete key sequence may look like <code>Q f.. RET \&amp;\&amp;
    RET</code> which searches for strings matching the
    pattern <code>f..</code>  and duplicates that string.  The key
    sequences supported by <code>C-M-%</code>
    (<code>query-replace-regexp</code>)
    like <code>y</code>, <code>n</code>, etc. work here.  See
    section <a href="ch05.html#search-and-replace">Search and
    Replace</a> for an account of the supported key sequences.  The
    search results are also displayed in a
    separate <code>*xref*</code>
  </li>
  <li>
    <code>A</code>: Find matches for a regular expression pattern in
    all marked files or the current file.  For any marked directories,
    all its files are searched recursively.  The active region is
    ignored.  A complete key sequence may look like <code>A
    f.. RET</code>.  Note that this does not perform incremental
    search.  Instead the search results are displayed in
    <code>*xref*</code> buffer.
  </li>
  <li>
    <code>!</code>: Run a shell command on each marked file or
    directory (or the current file or directory if nothing is marked).
    The command is executed synchronously.  The active region is
    ignored or the current file or directory.  The command works on
    all marked files and directories.  The output is displayed in a
    separate buffer.  If <code>*</code> is present in the command,
    then each <code>*</code> is replaced with the entire file list and
    the command runs only once (not multiple times, once for each
    file).  If <code>?</code> is present in the command, then the
    command runs multiple times, once for each marked file, with
    each <code>?</code> replaced with the name of the file being
    operated on.  It is an error to specify both <code>*</code>
    and <code>?</code>.  If neither is present, then the command runs
    multiple times, once for each marked file.
  </li>
  <li>
    <code>&amp;</code>: Like the previous command but runs the command
    asynchronously.
  </li>
</ul>
<p>
  To understand the usefulness of <code>g</code>, while Dired is open
  create a new file in the current directory with, say, <code>C-x C-f
  foo.txt RET</code> and save it with <code>C-x s</code>.  Then kill
  the buffer for the file with <code>C-x k</code> and return to the
  Dired buffer.  The Dired buffer does not show the new
  file <code>foo.txt</code>.  Now type <code>g</code> to refresh the
  Dired buffer.  As soon as <code>g</code> is typed, the buffer gets
  updated to display the new file.
</p>
<p>
  To understand the difference between <code>!</code> and
  <code>&amp;</code> mark five files and then type the key
  sequence <code>! sleep 1; echo</code>.  Emacs blocks (i.e. does not
  react to our keystrokes) for 5 seconds while it runs the given
  command for each file.  When the <code>echo</code> output for all
  files is obtained after 5 seconds, the output appears and Emacs
  unblocks again.  Now type <code>&amp; sleep 1; echo</code>.  Now
  Emacs remains unblocked while the output of each <code>echo</code>
  command appears at one second intervals in the output buffer.
</p>
<h3 id="dired-x">Dired-X<a href="#dired-x"></a></h3>
<p>
  Dired-X provides extra Dired functionality.  It is not enabled by
  default.  To enable it, add the following line to the Emacs
  initialisation file:
</p>
<pre><code>(require 'dired-x)</code></pre>
<p>
  The following key sequences are supported by Dired-X:
</p>
<ul>
  <li>
    <code>F</code>: Visit the marked files or the current file.  When
    multiple files are visited, they are opened in split windows
    distributed as evenly as possible.
  </li>
  <li>
    <code>C-u F</code>: Visit the marked files or the current file but
    open them in background, i.e. do not show them on any window.
  </li>
  <li>
    <code>* .</code>: Mark files with a certain extension.  If the
    region is active, then mark only the files in the region that have
    the given extension.  A complete key sequence may look
    like <code>* . txt</code>.
  </li>
  <li>
    <code>!</code> and <code>&amp;</code>: These commands still work
    the way they were described in the previous section.  However with
    Dired-X enabled, when <code>!</code> or <code>&amp;</code> is
    invoked on a single file (either a single marked file or no marked
    file in which case it operates on the current file), it
    automatically determines the command to execute for the current
    file type and offers that as the default input.
  </li>
</ul>
<h3 id="dired-working-across-directories">Dired: Working Across Directories<a href="#dired-working-across-directories"></a></h3>
<p>
  The following key sequences offer some support for working across
  multiple directories in the same Dired buffer:
</p>
<ul>
  <li>
    <code>i</code>: While the cursor is on a line for a directory, it
    expands the directory listing for that directory in the same Dired
    buffer.  Now we could use the mark, unmark, etc. commands to
    select files that belong to multiple directories and operate on
    them from the same Dired buffer.
  </li>
  <li>
    <code>$</code>: Collapse or expand the current directory listing.
    If there are multiple directory listings (such as the ones created
    with <code>i</code>), then move to the next directory listing
    after collapsing or expanding the current one.
  </li>
</ul>
<p>
  Using <code>i</code> to insert the directory listing of a
  subdirectory into the current Dired buffer could feel tedious if we
  want to recursively work on multiple directories.  The commands
  (illustrated with complete key sequences below) may be more suitable
  for such operations:
</p>
<ul>
  <li>
    <p>
      <code>M-x find-dired RET RET -name SPC "f*.txt" RET</code>: Find
      all files and directories in the current directory and its
      subdirectories recursively with name matching the
      pattern <code>f*.txt</code> and show the results in the buffer
      named <code>*Find*</code> with Dired mode enabled in it.  Emacs
      runs the following command to get the results:
    </p>
    <pre><code>find . \( -name "f*.txt" \) -ls</code></pre>
  </li>
  <li>
    <p>
      <code>M-x find-name-dired RET RET f*.txt RET</code>: Same as
      above.  Emacs runs the following command to get the results:
    </p>
    <pre><code>find . \( -name f\*.txt \) -l</code></pre>
    <p>
      Further on a system with case-insensitive filenames, Emacs is
      clever enough to use the <code>-iname</code> argument instead
      of <code>-name</code> so that case-insensitive search is
      performed.
    </p>
  </li>
  <li>
    <p>
      <code>M-x find-grep-dired RET RET f.. RET</code>: Find all files
      in the current directory and its subdirectories recursively and
      list the files where lines matching the regular
      expression <code>..</code> is found.  The result is shown in a
      the buffer named <code>*Find</code> with Dired mode enabled in
      it.  Emacs runs the following command to get the results:
    </p>
    <pre><code>find . \( -type f -exec grep -q -e f.. \{\} \; \) -ls</code></pre>
  </li>
  <li>
    <p>
      <code>M-x find-lisp-find-dired RET RET f.. RET</code>: Find all
      files in the current directory and subdirectories recursively
      and list the files with names that match the regular expression
      pattern <code>..</code>.  Note that this is different from
      both <code>find-name-dired</code>
      and <code>find-grep-dired</code>.  The former relies on the
      Unix <code>find</code> command to match filenames using glob
      patterns.  The latter uses both <code>find</code>
      and <code>grep</code> to list files that contain a line with a
      matching regular expression pattern.  However this command lists
      files with names that match a regular expression pattern (not
      glob pattern).  Further this command is implemented purely in
      Elisp and does not have any external dependencies on tools
      like <code>find</code> and <code>grep</code>.
    </p>
  </li>
</ul>
<h2 id="shell-commands">Shell Commands<a href="#shell-commands"></a></h2>
<p>
  The following complete key sequences demonstrate how we can invoke
  shell commands from Emacs.
</p>
<ul>
  <li>
    <code>M-! uname RET</code>: Execute shell command and show output.
  </li>
  <li>
    <code>C-u M-! uname RET</code>: Like above but insert the output
    into the buffer wherever the cursor is.  The cursor remains at the
    same place.  The mark is set to the character just after the last
    character of the output.  Therefore, typing <code>C-x C-x</code>
    (<code>exchange-point-and-mark</code>) is a quick way to highlight
    the output just inserted as an active region.
  </li>
  <li>
    <code>M-! ping SPC -c SPC 4 SPC localhost RET</code>: Execute a
    slightly long running shell command that takes about 4 seconds to
    complete.  Emacs blocks while the command is running because the
    command is executed synchronously.
  </li>
  <li>
    <code>C-u M-! ping SPC -c SPC 4 SPC localhost RET</code>: Like
    before but the output is inserted into the buffer.  Again, Emacs
    blocks while the command is executed.  The output appears in the
    buffer only after the command completes execution.
  </li>
  <li>
    <code>M-&amp; ping SPC -c SPC 4 SPC localhost RET</code>:
    Like <code>M-!</code> but execute shell command asynchronously.
    Emacs remains unblocked and the output appears in the output
    buffer as soon as the output is printed by the command.
  </li>
  <li>
    <code>M-| wc RET</code>: Pipe region to shell command and show
    output.
  </li>
  <li>
    <code>C-u M-| wc RET</code>: Pipe region to shell command and
    replace the region with the output.
  </li>
</ul>
<p>
  The book also mentions that <code>C-u M-&amp;</code> is supposed to
  work like <code>C-u M-!</code> but asynchronously but I did not find
  this to be true.  For example, <code>C-u M-&amp; uname RET</code>
  led to the following error <code>Wrong type argument: stringp,
  (4)</code>.  This may be a bug in Emacs 28.2.
</p>
<h2 id="compiling-in-emacs">Compiling in Emacs<a href="#compiling-in-emacs"></a></h2>
<p>
  The following complete key sequences demonstrate this feature:
</p>
<ul>
  <li>
    <code>M-x compile RET</code>: Runs <code>make -f</code> by
    default.  The default command is offered as a minibuffer input
    before we type <code>RET</code>.  Therefore we can edit the
    command to any arbitrary command before typing <code>RET</code>.
  </li>
  <li>
    <code>M-x recompile RET</code>: Runs the last compile command
    again.
  </li>
  <li>
    <code>C-x p c</code>: Compile in the current project.  See
    section <a href="#project-management">Project Management</a> for
    more details.
  </li>
</ul>
<p>
  The compile commands display the output in
  the <code>*compilation*</code> buffer where the following key
  sequences work:
</p>
<ul>
  <li>
    <code>M-g M-n</code>: Jump to the next error.  The cursor jumps to
    the next error line in the <code>*compilation*</code> and the
    source of the matching error line is opened in a separated window.
  </li>
  <li>
    <code>M-g M-p</code>: Jump to the previous error.
  </li>
  <li>
    <code>g</code>: Recompile, i.e. run the last compile command
    again.
  </li>
</ul>
<h2 id="shells-in-emacs">Shells in Emacs<a href="#shells-in-emacs"></a></h2>
<h3 id="m-x-shell">M-x shell<a href="#m-x-shell"></a></h3>
<p>
  The key sequence <code>M-x shell RET</code> starts a shell with
  input/output done via a buffer.  Some important points to keep in
  mind while using this:
</p>
<ul>
  <li>
    The TAB-completion mechanism of the underlying shell (e.g. Bash,
    Zsh, etc.) does not work.  In fact, <code>TAB</code> invokes
    Emacs's own completion mechanism.
  </li>
  <li>
    Programs like <code>top</code> and <code>man</code> that need to
    control the terminal do not work.  Only programs that perform
    input/output via standard input, standard output and standard
    error, etc. work well.
  </li>
  <li>
    Since the shell buffer is made completely of text, all text
    editing commands of Emacs work seamlessly on the buffer.
  </li>
  <li>
    We can take the cursor to absolutely anywhere in the buffer and
    type <code>RET</code> to execute whatever is on that line as a
    shell command.  Shell prompt on the line is automatically excluded
    from the command to be executed.
  </li>
</ul>
<p>
  Here are some key bindings that work in the shell buffer:
</p>
<ul>
  <li>
    <code>M-p</code>: Cycle backwards through input history.
  </li>
  <li>
    <code>M-n</code>: Cycle forwards through input history.
  </li>
  <li>
    <code>C-&lt;up&gt;</code>: Same as <code>M-p</code>.  May not work
    if the desktop environment gobbles up this keystroke.
  </li>
  <li>
    <code>C-&lt;down&gt;</code>: Same as <code>M-n</code>.  May not
    work if the desktop environment gobbles up this keystroke.
  </li>
  <li>
    <code>M-r f..</code>: Search history backwards for all commands
    that match the pattern <code>f..</code>.  Within the search, we
    can use incremental search key bindings
    like <code>C-r</code>, <code>C-s</code>, etc. to search backward,
    forward, etc. respectively.
  </li>
  <li>
    <code>C-c C-p</code>: Move to the previous prompt.  The cursor
    moves to the place just after the prompt.
  </li>
  <li>
    <code>C-c C-n</code>: Move to the next prompt.
  </li>
  <li>
    <code>C-c C-s out.txt RET</code>: Write output since the last
    input to a file.  Any prompt at the end of the output is not
    written.  Note that by default the output on shell contains the
    input command as well.  The input command is echoed back, so our
    input command appears twice in the buffer: once where we typed it
    and once more echoed just before the beginning of the output.
    This echoed input command is also saved to the file.
  </li>
  <li>
    <code>C-c C-o</code>: Delete all output since the last input.  Any
    prompt is of course left intact.
  </li>
  <li>
    <code>C-u C-c C-o</code>: Delete all output since the last input
    and save it to the kill ring.
  </li>
  <li>
    <code>C-c C-l</code>: Show the list of recent inputs in
    the <code>*Input History*</code> buffer.
  </li>
  <li>
    <code>C-d</code>: If the cursor is at the end of the buffer and
    there is no input, send EOF.  Otherwise delete a character forward.
  </li>
  <li>
    <code>C-c C-z</code>: Suspend the current job.  This performs the
    same function as <code>C-z</code> in the underlying shell.  We can
    then use job control commands like <code>bg</code>
    or <code>fg</code> to resume the job as a background process or
    foreground process.
  </li>
  <li>
    <code>TAB</code>: Perform completion at point.
  </li>
</ul>
<h3 id="m-x-ansi-term">M-x ansi-term<a href="#m-x-ansi-term"></a></h3>
<p>
  The key sequence <code>M-x ansi-term RET RET</code> launches an
  ANSI-capable terminal emulator.  It can run sophisticated programs
  like <code>top</code>, <code>man</code>, etc. that require terminal
  capabilities fine.  The following key sequences are useful in this
  terminal emulator:
</p>
<ul>
  <li>
    <code>C-c C-j</code>: Switch to line ("cooked") sub-mode.  Emacs
    editing key sequences work normally in this mode,
    except <code>RET</code> which sends the current line as a command
    to the underlying shell.
  </li>
  <li>
    <code>C-c C-k</code>: Switch to char ("raw") sub-mode.  By
    default, the terminal starts in this mode.  Each character we type
    in this sub-mode is sent directly to the shell, except for the
    escape character <code>C-c</code> which is used as the prefix keys
    for the key sequences described in this list.
  </li>
  <li>
    <code>C-c C-c</code>: Interrupt the current subjob.
  </li>
</ul>
<h3 id="m-x-eshell">M-x eshell<a href="#m-x-eshell"></a></h3>
<p>
  The key sequence <code>M-x eshell RET</code> creates an interactive
  Eshell buffer if none exists or switches to an existing one.  Eshell
  is implemented in Elisp.  It provides Elisp implementation of Unix
  commands like <code>ls</code>, <code>cp</code>, etc.
</p>
<p>
  The list below provides examples of some commands we can enter
  directly into Eshell:
</p>
<ul>
  <li>
    <code>which ls</code>: The output should show that <code>ls</code>
    is an Elisp function.
  </li>
  <li>
    <code>which which</code>: The output should show
    that <code>which</code> itself is an Elisp function.
  </li>
  <li>
    <code>which top</code>: The output should show the file path of
    the external program <code>top</code>.
  </li>
  <li>
    <code>ls -l</code>: Run Eshell's implementation of <code>ls</code>
    written in Elisp.
  </li>
  <li>
    <code>find-file /etc/hosts</code>: Run the Elisp function
    named <code>find-file</code> with the
    argument <code>/etc/hosts</code> thus opening the file in a
    buffer.
  </li>
  <li>
    <code>/bin/ls -l</code>: Run the external command <code>ls</code>
    available provided by the operating system utilities.
  </li>
  <li>
    <code>python3 --version</code>: Run the external
    program <code>python3</code>.
  </li>
  <li>
    <code>top</code>: Start the program <code>top</code> in a separate
    buffer with <code>term-mode</code> as the major mode.
  </li>
</ul>
<p>
  In the last point we see that for programs like <code>top</code>
  which need terminal capabilities to show output in a visual fashion
  (as opposed to just printing output to standard output or standard
  error), Eshell automatically runs the program in
  a <code>term-mode</code> buffer, so that the output of the visual
  program can be handled and displayed correctly.  Eshell looks at the
  list in the variable <code>eshell-visual-commands</code> to
  determine if a command needs terminal support or not.  By default,
  commands like <code>vi</code>, <code>screen</code>,
  <code>tmux</code>, <code>top</code>, etc. belong to this list.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/ch06.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes on Mastering Emacs: Chapter 5: The Theory of Editing</title>
<link>https://susam.net/cc/mastering-emacs/ch05.html</link>
<guid isPermaLink="false">lhvnj</guid>
<pubDate>Sat, 16 Sep 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The following notes were taken while discussing Chapter 5 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#killing-text">Killing Text</a></li>
  <li><a href="#append-kill">Append Kill</a></li>
  <li><a href="#digit-and-negative-arguments">Digit and Negative Arguments</a></li>
  <li><a href="#yanking-text">Yanking Text</a></li>
  <li><a href="#yank-pop">Yank Pop</a></li>
  <li><a href="#maximum-length-of-kill-ring">Maximum Length of Kill Ring</a></li>
  <li><a href="#killing-lines">Killing Lines</a></li>
  <li><a href="#transpose">Transpose</a></li>
  <li><a href="#filling">Filling</a></li>
  <li><a href="#commenting">Commenting</a></li>
  <li><a href="#search-and-replace">Search and Replace</a></li>
  <li><a href="#regular-expressions">Regular Expressions</a></li>
  <li><a href="#changing-case">Changing Case</a></li>
  <li><a href="#counting">Counting</a></li>
  <li><a href="#deleting-and-keeping-lines">Deleting and Keeping Lines</a></li>
  <li><a href="#splitting-and-joining-lines">Splitting and Joining Lines</a></li>
  <li><a href="#examining-and-fixing-whitespace-issues">Examining and Fixing Whitespace Issues</a></li>
  <li><a href="#keyboard-macros">Keyboard Macros</a></li>
  <li><a href="#text-expansion">Text Expansion</a>
    <ul>
      <li><a href="#abbrev">Abbrev</a></li>
      <li><a href="#dabbrev">DAbbrev</a></li>
      <li><a href="#hippie-expand">Hippie Expand</a></li>
    </ul>
  </li>
  <li><a href="#indenting">Indenting</a>
    <ul>
      <li><a href="#electric-indentation">Electric Indentation</a></li>
      <li><a href="#indenting-current-line">Indenting Current Line</a></li>
      <li><a href="#use-only-spaces-for-indentation">Use Only Spaces for Indentation</a></li>
      <li><a href="#tab-width">Tab Width</a></li>
      <li><a href="#edit-tab-stops">Edit Tab Stops</a></li>
      <li><a href="#indent-regions">Indent Region</a></li>
      <li><a href="#indent-rigidly">Indent Rigidly</a></li>
    </ul>
  </li>
  <li><a href="#sorting">Sorting</a></li>
  <li><a href="#aligning">Aligning</a></li>
  <li><a href="#zap-to-char">Zap to Char</a></li>
  <li><a href="#zap-up-to-char">Zap up to Char</a></li>
  <li><a href="#spell-check">Spell Check</a></li>
  <li><a href="#dictionary-lookup">Dictionary Lookup</a></li>
  <li><a href="#quoted-insert">Quoted Insert</a></li>
  <li><a href="#links">Links</a></li>
</ul>
<h2 id="killing-text">Killing Text<a href="#killing-text"></a></h2>
<p>
  Killing text is equivalent to what we call as cutting text in other
  editors.  Killing some text removes the text from the buffer and
  adds it to the kill ring.  The kill ring is the clipboard of Emacs.
</p>
<p>
  To discover kill commands using the apropos functionality,
  type <code>C-h a ^kill-</code>.
</p>
<p>
  Here is a list of commands introduced in the first section of this
  chapter:
</p>
<ul>
  <li>
    <code>C-d</code>: Delete the next character.
  </li>
  <li>
    <code>&lt;backspace&gt;</code>: Delete the previous character.
  </li>
  <li>
    <code>M-d</code>: Kill until the end of a word.
  </li>
  <li>
    <code>C-&lt;backspace&gt;</code>: Kill backward until the
    beginning of a word.
  </li>
  <li>
    <code>C-k</code>: Kill the rest of the current line.
  </li>
  <li>
    <code>M-k</code>: Kill until the end of sentence.
  </li>
  <li>
    <code>C-M-k</code>: Kill expression following point.
  </li>
  <li>
    <code>C-S-&lt;backspace&gt;</code>: Kill current line.  Does not
    work in terminal Emacs.  Use <code>C-a C-k</code> as alternative.
  </li>
  <li>
    <code>C-w</code>: Kill text between point and mark.
  </li>
  <li>
    <code>M-w</code>: Copy text between point and mark to kill ring.
  </li>
  <li>
    <code>C-M-w</code>: Cause the following command, if it kills, to
    append to the last stretch of text in the kill ring.
  </li>
  <li>
    <code>C-y</code>: Yank (paste) the last stretch of text in the
    kill ring to the buffer.
  </li>
  <li>
    <code>M-y</code>: Cycle through kill ring.
  </li>
</ul>
<p>
  I have observed that some Emacs users do not bother
  using <code>M-w</code> to copy to kill ring.  Instead they
  type <code>C-w C-/</code> to cut the text and immediately undo the
  cut which effectively leaves the buffer unchanged but inserts a copy
  of the text that was cut into the kill ring.  For example,
  while <code>C-a C-SPC C-n C-n M-w</code> copies two lines into the
  kill ring, so does <code>C-a C-SPC C-n C-n C-w C-/</code>.  The
  latter key sequence avoids having to use <code>M-w</code> but it is
  worth noting that this key sequence does not work in a readonly
  buffer while the former does.  To quickly see the difference,
  open <code>/etc/hosts</code> as a non-root and non-privileged user
  and try both the key sequences.  The former key sequence does not
  modify the buffer, so it works perfectly in a readonly buffer.  The
  latter key sequence modifies the buffer when we
  type <code>C-w</code>, so it does not work in a readonly buffer.
</p>
<p>
  I have also observed that many Emacs users do not bother
  learning <code>C-S-&lt;backspace&gt;</code> because they can achieve
  the same results using <code>C-a C-k</code>.
  Further, <code>C-S-&lt;backspace&gt;</code> does not work in
  terminal Emacs due to terminal limitations.  The key
  sequence <code>C-a</code> moves the cursor to the beginning of the
  line and <code>C-k</code> kills everything until the end of the
  line.
</p>
<p>
  There is a difference between <em>deleting</em> and
  <em>killing</em>.  The first two commands <code>C-d</code>
  and <code>&lt;backspace&gt;</code> delete characters but the deleted
  characters are not added to the kill ring.  The remaining commands
  in the list above kill text, i.e. remove the text from the buffer
  and add it to the kill ring.  The killed text can be pasted into the
  buffer using <code>C-y</code>.  For example, <code>M-d M-d M-d C-p
  C-p C-y</code> kills the next three words and pastes them two lines
  above.
</p>
<h2 id="append-kill">Append Kill<a href="#append-kill"></a></h2>
<p>
  The key sequence <code>C-M-w</code> is used to ensure that if the
  next command happens to be a kill command, then the killed text is
  appended to the last stretch of text in the kill ring.
</p>
<p>
  To understand what this command does we must first understand that
  after a kill command adds a new stretch of text to the kill ring,
  subsequent consecutive kills append to the same stretch of text in
  the kill ring, i.e. consecutive kills form a single large stretch of
  text in the kill ring.  This can be tested by performing consecutive
  kills and then pasting with <code>C-y</code>.  For example,
  <code>M-d M-d M-d C-p C-p C-y</code> kills 3 words, creates a single
  stretch of text consisting of those 3 words in the kill ring and
  pastes that text two lines above.
</p>
<p>
  However, the moment a non-kill command is used, it seals the stretch
  of text in the kill ring.  Any subsequent kill command begins a new
  stretch of text.  For example, <code>M-d M-d M-d C-p M-d M-d C-p
  C-y</code> kills 3 words at first but then it moves to the previous
  line sealing that kill text consisting of 3 words.  Then it kills 2
  words and creates a new stretch of text in the kill ring.
  Therefore, the final yank command pastes only those 2 words from the
  kill ring.
</p>
<p>
  This can be a problem if we want to kill text from various parts of
  the buffer and yet create a single stretch of text that we want to
  paste somewhere.  That's when <code>C-M-w</code> comes useful.  For
  example, <code>M-d M-d M-d C-p C-M-w M-d M-d C-p C-y</code> kills 3
  words and creates a single stretch of text in the kill ring
  consisting of those 3 words.  Then it moves one line up and kills 2
  more words but this time it appends those 2 words to the existing
  stretch of text in the kill ring.  Finally, it moves two lines up
  and pastes the entire stretch of text consisting of 5 words into the
  buffer.
</p>
<h2 id="digit-and-negative-arguments">Digit and Negative Arguments<a href="#digit-and-negative-arguments"></a></h2>
<p>
  Here are some complete key sequences that demonstrate digit and
  negative arguments:
</p>
<ul>
  <li>
    <code>M-3 M-d</code>: Kill the next 3 words.
  </li>
  <li>
    <code>M- M-d </code>: Kill the previous word.
  </li>
  <li>
    <code>M-- M-3 M-d </code>: Kill the previous 3 words.
  </li>
  <li>
    <code>C-M-3 C-M-k</code>: Kill the next 3 expressions.
  </li>
  <li>
    <code>C-M-- C-M-k</code>: Kill the previous expression.
  </li>
  <li>
    <code>C-M-- C-M-3 C-M-k</code>: Kill the previous 3 expressions.
  </li>
</ul>
<h2 id="yanking-text">Yanking Text<a href="#yanking-text"></a></h2>
<p>
  There are two key bindings to learn here.  The key
  sequence <code>C-y</code> executes the <code>yank</code> command
  which yanks the last stretch of text from the kill ring.
</p>
<p>
  In the apropos system, <code>paste</code> is a synonym
  of <code>yank</code>.  Type <code>C-h v apropos-synonyms RET</code>
  to see all the synonyms define for the apropos system.
  Thus <code>C-h a paste RET</code> includes the results
  for <code>yank</code> too.
</p>
<h2 id="yank-pop">Yank Pop<a href="#yank-pop"></a></h2>
<p>
  The key sequence <code>M-y</code> executes the <code>yank-pop</code>
  command which replaces a just-yanked kill with an older kill.  This
  key sequence helps us to cycle through the kill ring and fetch older
  and older kills to be pasted into the buffer.
</p>
<p>
  Here is an experiment to see how we can use <code>C-y</code>
  and <code>M-y</code> can be used together:
</p>
<ol>
  <li>
    Open a new buffer and type these five words in a single
    line: <code>foo bar baz qux quux</code>.
  </li>
  <li>
    Then type <code>C-a M-d C-g M-d C-g M-d</code>.  At this point
    three stretches of text have been inserted into the kill ring.
    The <code>C-g</code> between every <code>M-d</code> is there to
    avoid appending kills to the existing stretch of text in the kill
    ring.  This ensures that we have three separate stretches of text
    in the kill ring.
  </li>
  <li>
    Now type <code>C-y</code>.  The last stretched of kill text, i.e.
    <code>baz</code> is now pasted into the buffer.
  </li>
  <li>
    Now without typing any other key sequence, type <code>M-y</code>.
    The earlier pasted text <code>baz</code> is now replaced with an
    older stretch of text from the kill ring.  Thus <code>baz</code>
    is replaced with <code>bar</code>.
  </li>
  <li>
    Now once again type <code>M-y</code>.  The earlier pasted
    text <code>bar</code> is now replaced with a further older stretch
    of text from the kill ring.  Thus <code>bar</code> is replaced
    with <code>foo</code>.
  </li>
</ol>
<p>
  Note in the previous steps how we are not supposed to type any other
  key between the first <code>C-y</code> and <code>M-y</code>.
  Similarly, while cycling through the kill ring, we must not type any
  other key between the consecutive <code>M-y</code> key sequences.
  While cycling through the kill ring, when we reach the oldest kill,
  the next <code>M-y</code> wraps around and brings back the newest
  kill.
</p>
<p>
  Since Emacs 28, the key sequence <code>M-y</code> also supports
  browsing the kill ring and yanking any arbitrary entry from the kill
  ring.  For example, after trying the above experiment,
  type <code>C-g</code> just to make sure that we are breaking any
  existing <code>C-y</code> or <code>M-y</code> cycle.  Then
  type <code>M-y</code> and a minibuffer prompt appears to yank an
  arbitrary kill from the kill ring.  If we remember the previous
  kill, we can type it out partially and type <code>TAB</code> to
  autocomplete it.  Alternatively, we could also type <code>TAB</code>
  initially itself to browse all the kills in the kill ring.
</p>
<h2 id="maximum-length-of-kill-ring">Maximum Length of Kill Ring<a href="#maximum-length-of-kill-ring"></a></h2>
<p>
  Type <code>C-h v kill-ring-max RET</code> to see the maximum length
  of the kill ring.  It is <code>60</code> by default.
</p>
<h2 id="killing-lines">Killing Lines<a href="#killing-lines"></a></h2>
<p>
  Since <code>C-S-&lt;backspace&gt;</code> works only in GUI Emacs and
  not in terminal Emacs due to terminal limitations, in the
  section <em>Killing Lines</em> the author recommends installing the
  package <code>whole-line-or-region</code> which modifies the
  behaviour of <code>C-w</code> to kill the current line if there is
  no active region.
</p>
<p>
  This package can be installed with the following command:
</p>
<pre><code>M-x package-install whole-line-or-region RET</code></pre>
<p>
  Then a mode offered by this package can be enabled by adding this
  line to the Emacs initialisation file:
</p>
<pre><code>(whole-line-or-region-global-mode)</code></pre>
<p>
  After Emacs is started with the updated initialisation file,
  typing <code>C-w</code> kills the current line if there is no active
  region.  However, if there is an active region then <code>C-w</code>
  retains the default behaviour of killing the region.
</p>
<p>
  Although the author recommends this package, I do not use this
  package.  I have found <code>C-a C-k</code> to be very effective for
  killing the current line.  However, it is worth noting that for
  non-empty lines, <code>C-k</code> does not include the newline in
  the kill by default.  If we want to remove the newline too, we must
  type <code>C-k</code> another time.  Therefore, to faithfully
  reproduce the behaviour of <code>C-w</code>
  (of <code>whole-line-or-region</code>) or that
  of <code>C-S-&lt;backspace&gt;</code>, we need to type <code>C-a C-k
  C-k</code>.
</p>
<p>
  It is possible to change the default behaviour of <code>C-k</code>
  such that when we type it at the beginning of a line, the trailing
  newline is included in the kill.  To do so, add this to the Emacs
  initialisation file:
</p>
<pre><code>(setq kill-whole-line t)</code></pre>
<p>
  After Emacs is started with this initialisation
  file, <code>C-k</code> kills a whole line along with the trailing
  newline only if cursor is at the start of a line.  In other words,
  with this setting, <code>C-a C-k</code> always kills a whole line
  along with the trailing newline.
</p>
<h2 id="transpose">Transpose<a href="#transpose"></a></h2>
<p>
  Here are some transpose commands:
</p>
<ul>
  <li>
    <code>C-t</code>: Interchange characters around point.
  </li>
  <li>
    <code>M-t</code>: Interchange words around point.
  </li>
  <li>
    <code>C-M-t</code>: Interchange expressions around point.
  </li>
  <li>
    <code>C-x C-t</code>: Exchange current line and previous line.
  </li>
  <li>
    <code>M-x transpose-paragraphs RET</code>: Interchange current
    paragraph with next one.
  </li>
  <li>
    <code>M-x transpose-sentences RET</code>: Interchange the current
    sentence with the next one.
  </li>
</ul>
<p>
  While using <code>C-t</code> remember that the point is the logical
  place between two characters.  For example if the cursor blinking on
  the letter <code>e</code> of the word <code>hello</code>, then the
  point is between the letters <code>h</code> and <code>e</code>.
  When we type a new character, the new character is inserted where
  the point is.  The key sequence <code>C-t</code> interchanges the
  characters on both sides of the point, i.e. it exchanges the
  character the cursor is blinking on with the character just before
  it.
</p>
<p>
  There is a subtle difference between the way <code>C-x C-t</code>
  works and the way the other commands work.  The other commands
  exchange the current or previous object with the next one.
  However, <code>C-x C-t</code> exchanges the current line with the
  previous one.
</p>
<p>
  Note that the cursor moves to the end of the next object after
  performing an exchange.  This allows the object that moved forward
  to be dragged further forward by repeated application of the same
  command.  Note again that while the other commands drag the thing at
  point forward, <code>C-x C-t</code> drags the previous line forward.
</p>
<p>
  If the cursor is on a space between <code>"foo" :: "bar"</code>,
  note that <code>M-t</code> will transpose it to <code>"bar" ::
  "foo"</code> because it ignores symbols.
</p>
<h2 id="filling">Filling<a href="#filling"></a></h2>
<p>
  Here are some complete key sequences that perform paragraph filling:
</p>
<ul>
  <li>
    <code>M-q</code>: Refill paragraph.
  </li>
  <li>
    <code>C-u M-q</code>: Refill paragraph and justify text too.
  </li>
  <li>
    <code>C-x f 40 RET</code>: Set <code>fill-column</code> to 40.
  </li>
  <li>
    <code>C-x .</code>: Set the fill prefix to the current line up to
    point.  On performing a fill operation, the fill prefix is
    inserted at the beginning of every new line created.
  </li>
  <li>
    <code>C-a C-x .</code>: To cancel the fill prefix, type <code>C-x
    .</code> at the beginning of a line.  Thus <code>C-a C-x .</code>
    cancels the fill prefix.
  </li>
  <li>
    <code>M-x auto-fill-mode RET</code>: Toggle auto-filling.
  </li>
</ul>
<h2 id="commenting">Commenting<a href="#commenting"></a></h2>
<p>
  Here are some key bindings to add comments to code in various ways:
</p>
<ul>
  <li>
    <code>M-;</code>: Insert or remove comment in a <em>do what I
    mean</em> (DWIM) fashion.  If the line is empty, a comment is
    inserted at the beginning of the line.  If the line is not empty,
    a comment is inserted at the end of the line and then indented to
    the column numbered <code>comment-column</code> if it can.  If a
    region is selected, it comments or uncomments that region.
  </li>
  <li>
    <code>C-x C-;</code>: Comment out or uncomment the current line.
  </li>
  <li>
    <code>M-x comment-box RET</code>: Comment a region by drawing a
    box made of comment characters around the selected region.
    Running this command repeatedly on the same region creates
    multiple nested comment boxes.
  </li>
  <li>
    <code>M-j</code>: Insert a new line and continue with the comment
    if the current line has an open comment.  If there is no open
    comment in the current line, then create a new line and indent.
  </li>
  <li>
    <code>C-M-j</code>: Same as above.
  </li>
</ul>
<p>
  Here are some variables that control the behaviour of
  comment-related commands:
</p>
<ul>
  <li>
    <code>comment-style</code>: The default is <code>indent</code>
    which ensures that new comments created with the comment commands
    are correctly indented.
  </li>
  <li>
    <code>comment-styles</code>: An association list with all the
    available comment styles.
  </li>
  <li>
    <code>comment-start</code>: String to insert to start a new
    comment.
  </li>
  <li>
    <code>comment-end</code>: String to insert to end a new comment.
  </li>
  <li>
    <code>comment-padding</code>: Extra spacing between the comment
    characters and the comment text.  This is the minimum number of
    spaces (only if the value of this variable is made of spaces) that
    Emacs tries to keep between the comment characters and comment
    text.  No spaces are inserted if <code>comment-start</code>
    and <code>comment-end</code> already
    provide <code>comment-padding</code> number of spaces or more to
    separate the comment text.
  </li>
</ul>
<p>
  To demonstrate how changing <code>comment-style</code> changes the
  commenting behaviour try <code>M-x (setq comment-style 'indent)
  RET</code>, then select a region and type <code>M-;</code>.  The
  selected region will be commented out with a comment box.
</p>
<p>
  However running <code>M-x (setq comment-style 'aligned) RET</code>,
  selecting a region in a C buffer and typing <code>M-;</code> does
  not seem to do anything interesting.
</p>
<h2 id="search-and-replace">Search and Replace<a href="#search-and-replace"></a></h2>
<p>
  Here are some complete key sequences that demonstrate search and
  replace commands:
</p>
<ul>
  <li>
    <code>M-% foo RET bar RET</code>: Replace the
    string <code>foo</code> with <code>bar</code> while prompting for
    instruction at every match.
  </li>
  <li>
    <code>C-M-% f.. RET bar RET</code>: Replace matches for regular
    expression <code>f..</code> with <code>bar</code> while prompting
    for instruction at every match.
  </li>
  <li>
    <code>M-x query-replace RET foo RET bar RET</code>: Same
    as <code>M-% foo RET bar RET</code>.
  </li>
  <li>
    <code>M-x query-replace-regexp RET f.. RET bar RET</code>: Same
    as <code>C-M-% f.. RET bar RET</code>.
  </li>
  <li>
    <code>M-x replace-string RET foo RET bar RET</code>: Replace the
    string <code>foo</code> with <code>bar</code> but do not prompt
    for instruction at every match.
  </li>
  <li>
    <code>M-x replace-string RET f.. RET bar RET</code>: Replace
    matches for regular expression <code>f..</code>
    with <code>bar</code> but do not prompt for instruction at every
    match.
  </li>
</ul>
<p>
  The following key bindings work while a query replace operation is
  in progress:
</p>
<ul>
  <li>
    <code>y</code>: Replace one match and continue.
  </li>
  <li>
    <code>SPC</code>: Same as <code>y</code>.
  </li>
  <li>
    <code>n</code>: Skip to next match.
  </li>
  <li>
    <code>DEL</code>: Same as <code>n</code>.
  </li>
  <li>
    <code>q</code>: Exit query replace.
  </li>
  <li>
    <code>RET</code>: Same as <code>q</code>.
  </li>
  <li>
    <code>.</code>: Replace one match and exit.
  </li>
  <li>
    <code>,</code>: Replace and stay at current match.
  </li>
  <li>
    <code>!</code>: Replace all remaining matches in the buffer with
    no more questions.
  </li>
  <li>
    <code>^</code>: Move point back to the previous match.
  </li>
  <li>
    <code>u</code>: Undo previous replacement.
  </li>
  <li>
    <code>U</code>: Undo all replacements.
  </li>
  <li>
    <code>E</code>: Edit replacement string and replace next match.
  </li>
</ul>
<p>
  Just like incremental search (<code>C-s</code> or
  <code>C-M-s</code>), search and replace performs case folding,
  i.e. performs case-insensitive match if the search string is a
  lowercase string.  However, the moment we include an uppercase
  character in the search string, search and replace performs
  case-sensitive search and replace.
</p>
<h2 id="regular-expressions">Regular Expressions<a href="#regular-expressions"></a></h2>
<p>
  This section presents some examples of regular-expression-based
  search as well as search-and-replace.  Here is a simple text buffer
  where the commands to be presented later can be tried out.
</p>
<pre>
<code>foo-bar-baz
foo-baar-baz
foo-baaar-baz
foo-baaaar-baz
foo-baaaaar-baz
foo-baaaaaar-baz

web
server
webserver
web server
web_server
web-&gt;server
web::server
web.server
securewebserver
secure web server
web server port 80

web-server
web-api-server
secure-web-server
web-server-port-80
web-server-port-http
web-server-port-HTTP-80

(1, 2, 3)
[4, 5, 6]
{7, 8, 9}
((10 + 20) * 30)
&lt;40, 50, 60&gt;

"hello, world"
'hello, world'

; comment
# comment
// comment
/* comment */</code>
</pre>
<p>
  Here are some complete key sequences that demonstrate regular
  expressions in search operations:
</p>
<ul>
  <li>
    <code>C-M-s f..</code>: Search for the letter <code>f</code>
    followed by two characters.
  </li>
  <li>
    <code>C-M-s foo\|bar</code>: Search for the
    string <code>foo</code> or <code>bar</code>.
  </li>
  <li>
    <code>C-M-s ba\{3\}r</code>: Search for the letter <code>b</code>
    followed by the string <code>aaa</code> and the
    letter <code>r</code>.
  </li>
  <li>
    <code>C-M-s ba\{3,5\}r</code>: Search for the
    letter <code>b</code> followed by 3 to 5 repetitions of the
    letter <code>a</code> followed by the letter <code>r</code>.
  </li>
  <li>
    <code>C-M-s port-[0-9]+</code>: Search for the
    string <code>port-</code> followed by one or more digits.
  </li>
  <li>
    <code>C-M-s port-[[:digit:]]+</code>: Same as above.
  </li>
  <li>
    <code>C-M-s port-[[:alnum:]]+</code>: Search for the
    string <code>port-</code> followed by one or more alphanumeric
    characters.
  </li>
  <li>
    <code>C-M-s port-[[:upper:][:digit:]-]+</code>: Search for the
    string <code>port-</code> followed by consecutive sequence of one
    or more upper-case letters, digits or hyphen.
  </li>
  <li>
    <code>C-M-s \&lt;web</code>: Search for the
    string <code>web</code> at the beginning of a word.
  </li>
  <li>
    <code>C-M-s web\&gt;</code>: Search for the
    string <code>web</code> at the end of a word.
  </li>
  <li>
    <code>C-M-s \&lt;web.+server\&gt;</code>: Search for the
    string <code>web</code> at the beginning of a word followed by one
    or more characters and the string <code>server</code> at the end
    of a word.
  </li>
  <li>
    <code>C-M-s \_&lt;web.+server\_&gt;</code>: Search for the
    string <code>web</code> at the beginning of a symbol followed by
    one or more characters and the string <code>server</code> at the
    end of a symbol.
  </li>
  <li>
    <code>C-M-s web\s server</code>: Search for the
    string <code>web</code> followed by one whitespace character and
    the string <code>server</code>.
  </li>
  <li>
    <code>C-M-s web\s-server</code>: Same as above.
  </li>
  <li>
    <code>C-M-s \s </code>: Search for whitespace character.
  </li>
  <li>
    <code>C-M-s \s-</code>: Same as above.
  </li>
  <li>
    <code>C-M-s \sw</code>: Search for word constituent character.
    Typically uppercase letters, lowercase letters and digits are
    considered word constituents.
  </li>
  <li>
    <code>C-M-s \s_</code>: Search for a symbol character that is used
    in variable names or command names.
  </li>
  <li>
    <code>C-M-s \s.</code>: Search for punctuation character.
  </li>
  <li>
    <code>C-M-s \s(</code>: Search for opening pair of a grouping
    character, e.g. <code>(</code>, <code>[</code>, <code>{</code>.
  </li>
  <li>
    <code>C-M-s \s)</code>: Search for closing pair of a grouping
    character, e.g. <code>)</code>, <code>]</code>, <code>}</code>,
    etc.
  </li>
  <li>
    <code>C-M-s \s"</code>: Search for string delimiter.  This does
    not work in text mode but does work in programming modes.
  </li>
  <li>
    <code>C-M-s \s&lt;</code>: Search for opening comment delimiter.
    This too does not work in text mode but does work in programming
    modes.
  </li>
  <li>
    <code>C-M-s \s&gt;</code>: Search for closing comment delimiter.
    This too does not work in text mode but does work in programming
    modes.
  </li>
  <li>
    <code>C-M-s \Sw</code>: Search for character that is not a word
    constituent.  The pattern <code>\S</code> matches any character
    whose syntax code is not the given syntax code (<code>w</code> in
    this example).
  </li>
</ul>
<p>
  All examples above that contain the regular
  expression <code>\s</code> followed by a character matches a
  character that belongs to a specific syntax class.  For
  example <code>\s.</code> matches characters that belong to the
  punctuation syntax class.  The syntax class for each character is
  decided by the current major mode.  Thus the same character may
  belong to different syntax classes in different modes.  For example,
  while the character <code>#</code> belongs to the punctuation syntax
  class in text mode, it belongs to the comment syntax class in Python
  mode.
</p>
<p>
  To find out which syntax class a particular character belongs to,
  place the cursor on the character and type <code>C-u C-x =</code>.
  The <em>syntax</em> field in the output buffer shows the syntax
  class of the character.
</p>
<p>
  Here are some complete key sequences that demonstrate various
  search-and-replace features:
</p>
<ul>
  <li>
    <code>C-M-% \(web\)\(\s-\)\(server\) RET \3\2\1 RET</code>: Search
    for the string <code>web</code> followed by a whitespace and the
    string <code>server</code> and swap <code>web</code>
    with <code>server</code>.
  </li>
  <li>
    <code>C-M-% \(foo-\)\sw+\(-baz\) RET \1\?\2 RET</code>: Search for
    the string <code>foo-</code> followed by a word and the
    string <code>baz</code> and replace the middle word with text
    input provided by the user.  Before each replace operation, Emacs
    will prompt the user to edit the replacement pattern by putting
    the point where <code>\?</code> was in the original replacement
    string.
  </li>
  <li>
    <code>C-M-% foo RET \# RET</code>: Search for the
    string <code>foo</code> and replace each match with an
    autoincrementing number.  The first match is replaced
    with <code>0</code>, the second one with <code>1</code>, the third
    one with <code>2</code> and so on.  Precisely speaking, the
    backreference <code>\#</code> refers to the count of the
    replacements already made in the current search and replace
    operation.
  </li>
  <li>
    <code>C-M-% foo RET \&amp;\&amp; RET</code>: Search for the
    string <code>foo</code> and duplicate it.  The replacement
    pattern <code>\&amp;</code> stands for the whole match.
  </li>
  <li>
    <code>C-M-% f.. RET \,(upcase \&amp;) RET</code>: Search for the
    letter <code>f</code> followed by two characters and replace the
    match with an uppercase form of the match.  The
    syntax <code>\,(<em>form</em>)</code> is used to evaluate an Elisp
    form and use its result in the replacement string.  The
    backreference <code>\&amp;</code> refers to the whole match as a
    string in the Elisp expression.
  </li>
  <li>
    <code>C-M-% [0-9]+ RET \,(+ 1000 \#&amp;)</code>: Search for
    numbers and add 1000 to each match.  The
    backreference <code>\#&amp;</code> refers to the whole match as a
    number within the Elisp expression.
  </li>
  <li>
    <code>C-M-% \(\sw+\)-\(\sw+\) RET \,(upcase \2)-\1 RET</code>:
    Search for two words separated by a hyphen and then swap them but
    convert the second word in each match to uppercase.  The
    backreference <code>\2</code> refers to the string matched by the
    second capturing group as a string within the Elisp expression.
  </li>
  <li>
    <code>C-M-% port-\([0-9]+\) RET port-\,(+ 1000 \#1) RET</code>:
    Search for the string <code>port-</code> followed by a number and
    add 1000 to the number.  The backreference <code>\#1</code> refers
    to the string matched by the first capturing group as a string
    within the Elisp expression.
  </li>
</ul>
<h2 id="changing-case">Changing Case<a href="#changing-case"></a></h2>
<p>
  Here are some commands to change case of text:
</p>
<ul>
  <li>
    <code>M-l</code>: Convert string from point to the end of word to
    lowercase.
  </li>
  <li>
    <code>M-u</code>: Convert string from point to the end of word to
    uppercase.
  </li>
  <li>
    <code>M-c</code>: Capitalise string from point to the end of word.
  </li>
  <li>
    <code>C-x C-l</code>: Convert region to lower case.
  </li>
  <li>
    <code>C-x C-u</code>: Convert region to upper case.
  </li>
  <li>
    <code>M-x upcase-initials-region RET</code>: Capitalise region.
  </li>
</ul>
<p>
  Note that the commands <code>C-x C-l</code>
  (<code>downcase-region</code>) and <code>C-x C-u</code>
  (<code>upcase-region</code>) are disabled by default.  Follow the
  prompts to try it or enable it.  A quick way to try it is to
  type <code>SPC</code>.  Also, adding the following to the Emacs
  initialisation file permanently enables it.
</p>
<pre>
<code>(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)</code>
</pre>
<h2 id="counting">Counting<a href="#counting"></a></h2>
<p>
  Here are some commands to count lines, words, characters, patterns,
  etc:
</p>
<ul>
  <li>
    <code>M-=</code>: Count lines, words and characters in region.
  </li>
  <li>
    <code>M-x count-words-region RET</code>: Same as above.
  </li>
  <li>
    <code>M-x count-words RET</code>: Similar to above.  If no region
    is selected, then counts in the entire buffer.
  </li>
  <li>
    <code>M-x how-many RET f.. RET</code>: Show the number of matches
    for the regular expression <code>f..</code> following point.  If
    region is selected, then show the number of matches in the region.
  </li>
  <li>
    <code>M-x count-matches RET f.. RET</code>: Same as above.
  </li>
</ul>
<h2 id="deleting-and-keeping-lines">Deleting and Keeping Lines<a href="#deleting-and-keeping-lines"></a></h2>
<p>
  The commands that are presented in this section can be tested with a
  buffer like this:
</p>
<pre>
<code>foo
bar

foo
bar

foo
foo

bar
foo



baz
baz
baz</code>
</pre>
<p>
  Here are the commands:
</p>
<ul>
  <li>
    <code>M-x delete-duplicate-lines RET</code>: Delete all but one
    copy of duplicate lines in region.  When executed on the whole of
    the example buffer presented above, it leaves us with three
    non-empty lines and one blank line.  When duplicate lines are
    encountered, the first instance of each line is kept intact and
    the others are deleted.
  </li>
  <li>
    <code>C-u M-x delete-duplicate-lines RET</code>: Like the previous
    command but search backwards.  Thus effectively, the last instance
    of each repeated line is left intact while the other duplicates
    are deleted.
  </li>
  <li>
    <code>C-u C-u M-x delete-duplicate-lines RET</code>: Delete only
    those duplicate lines that are adjacent to each other.  In every
    contiguous group of duplicate lines, the first one is left intact
    and the rest are deleted.
  </li>
  <li>
    <code>C-u C-u C-u M-x delete-duplicate-lines RET</code>: Like the
    first command in this list but repeated blank lines are left
    intact.  When executed on the whole of the example buffer
    presented above, it leaves us with three non-empty lines and six
    blank lines.
  </li>
  <li>
    <code>M-x flush-lines RET b.. RET</code>: Delete lines in region
    that match the regular expression <code>b..</code>.  If no region
    is active, then delete matching lines between the point and end of
    buffer.  The deleted lines are not copied to kill ring.
  </li>
  <li>
    <code>M-x keep-lines RET b.. RET</code>: Keep lines in region that
    match the regular expression <code>b..</code> and delete the rest.
    If no region is active, then keep matching lines between the point
    and end of buffer and delete the rest.  The deleted lines are not
    copied to kill ring.
  </li>
  <li>
    <code>M-x copy-matching-lines RET b.. RET</code>: Copy lines in
    region that match the regular expression <code>b..</code> to the
    kill ring.  If no region is active, then copy matching lines
    between the point and end of buffer.  (Available since Emacs 28.1)
  </li>
  <li>
    <code>M-x kill-matching-lines RET b.. RET</code>: Kill lines in
    region that match the regular expression <code>b..</code> to the
    kill ring.  If no region is active, then kill matching lines
    between the point and end of buffer.  (Available since Emacs 28.1)
  </li>
</ul>
<p>
  To try each command on the entire buffer, first type <code>C-x
  h</code> to select the entire buffer as the region and then type a
  command mentioned above.
</p>
<h2 id="splitting-and-joining-lines">Splitting and Joining Lines<a href="#splitting-and-joining-lines"></a></h2>
<p>
  Here is a list of commands that help with splitting and joining
  lines:
</p>
<ul>
  <li>
    <code>C-o</code>: Insert a newline after the point but do not move
    the point.
  </li>
  <li>
    <code>C-x C-o</code>: On blank line, delete all surrounding blank
    lines, leaving just one.  On isolated blank line, delete the blank
    line.  On non-blank line, delete all consecutive blank lines that
    follow the non-blank lines.  While deleting blank lines it also
    deletes lines that consist only of whitespaces.
  </li>
  <li>
    <code>C-M-o</code>: Split current line at the next non-whitespace
    character after the point while maintaining its indentation.
    Everything from the next non-whitespace character after the point
    to the end of the line moves down by one line but the new line is
    indented so that the column numbers of all the characters that
    moved down remain the same.  If a fill-prefix has been set, say
    with <code>C-x .</code>, then the fill-prefix is inserted in the
    new line.
  </li>
  <li>
    <code>M-^</code>: Join current line with previous line and leave
    exactly one space between the joined lines.  If a fill-prefix is
    set, say with <code>C-x .</code>, then the fill-prefix is removed
    while joining lines.
  </li>
</ul>
<p>
  The key sequence <code>C-x C-o</code> is very useful for removing
  spurious blank lines between paragraphs.
</p>
<p>
  Note that <code>M-^</code> also works on a region.  When a region is
  active, it joins all lines in the region.
</p>
<h2 id="examining-and-fixing-whitespace-issues">Examining and Fixing Whitespace Issues<a href="#examining-and-fixing-whitespace-issues"></a></h2>
<p>
  Here is a list of commands that are useful in examining whitespace
  in the current buffer:
</p>
<ul>
  <li>
    <code>M-x whitespace-mode RET</code>: Toggle visualisation of
    spaces, tabs, newlines and lines longer
    than <code>whitespace-line-column</code> number of columns (80 by
    default) with special glyphs and colour.
  </li>
  <li>
    <code>M-x whitespace-newline-mode RET</code>: Toggle visualisation
    of newlines.
  </li>
  <li>
    <code>M-x whitespace-toggle-options RET</code>: Toggle local
    options for <code>whitespace-mode</code>.
  </li>
</ul>
<p>
  After typing <code>M-x whitespace-toggle-options RET</code>, type a
  key to tell it what to do.  For example, type <code>N</code> and it
  will start or restart <code>whitespace-mode</code> with the
  visualisation of newline toggled.  Type <code>?</code> to see the
  list of all key inputs it supports.
</p>
<p>
  The key sequence <code>M-x whitespace-toggle-options RET</code> may
  be typed anytime regardless of whether <code>whitespace-mode</code>
  is currently enabled or not.  If <code>whitespace-mode</code> is not
  enabled, running <code>whitespace-toggle-options</code>
  automatically enables it.  If <code>whitespace-mode</code> is
  already enabled, then running <code>whitespace-toggle-options</code>
  and toggling an option, restarts local <code>whitespace-mode</code>
  with the updated option setting.
</p>
<p>
  Here are some commands to report and clean up whitespace issues:
</p>
<ul>
  <li>
    <code>M-x whitespace-report RET</code>: Shows a report of
    whitespace issues.  The "Current setting" column on left shows the
    current settings found in the
    variable <code>whitespace-style</code>.  The "Whitespace Problem"
    column on the right shows the whitespace problems found in the
    buffer.
  </li>
  <li>
    <code>M-x whitespace-report-region RET</code>: Like the previous
    command but reports problems in a region.
  </li>
  <li>
    <code>M-x whitespace-cleanup RET</code>: Cleans up whitespace
    issues in the buffer.  This command checks
    the <code>whitespace-style</code> variable to decide which issues
    to fix.  See <code>C-h f whitespace-cleanup RET</code> for
    complete details.
  </li>
  <li>
    <code>M-x whitespace-cleanup-region RET</code>: Cleans up
    whitespace issues in a region.  Unlike the previous command, this
    command does not fix empty lines at the beginning or end of
    buffer.  See <code>C-h f whitespace-cleanup-region RET</code> for
    complete details.
  </li>
</ul>
<p>
  As mentioned in the list above, the whitespace cleanup functions
  read the variable <code>whitespace-style</code> to decide which
  whitespace issues to fix.  Say, we do not want to fix trailing
  whitespace issue but do want to fix other whitespace issues selected
  by default (e.g. empty lines at the beginning or end of buffer,
  spaces before tab, etc.), then we need to update
  the <code>whitespace-style</code> variable as follows:
</p>
<pre>
<code>(setq whitespace-style (delete 'trailing whitespace-style))</code>
</pre>
<p>
  Now running <code>whitespace-cleanup</code>
  or <code>whitespace-cleanup-region</code> is going to skip fixing
  trailing spaces but it will perform the other cleanups determined by
  the value of <code>whitespace-style</code>.
</p>
<h2 id="keyboard-macros">Keyboard Macros<a href="#keyboard-macros"></a></h2>
<p>
  The behaviour of keyboard macro key sequences depend on the current
  context.  So they are presented as table below.
</p>
<table class="grid">
  <tr>
    <th>
      Key
    </th>
    <th>
      Command
    </th>
    <th>
      While not recording
    </th>
    <th>
      While recording
    </th>
  </tr>
  <tr>
    <td>
      <code>F3</code>
    </td>
    <td>
      <code>kmacro-start-macro-or-insert-counter</code>
    </td>
    <td>
      Start recording
    </td>
    <td>
      Insert counter
    </td>
  </tr>
  <tr>
    <td>
      <code>F4</code>
    </td>
    <td>
      <code>kmacro-end-or-call-macro</code>
    </td>
    <td>
      Call macro
    </td>
    <td>
      End recording
    </td>
  </tr>
  <tr>
    <td>
      <code>C-x&nbsp;(</code>
    </td>
    <td>
      <code>kmacro-start-macro</code>
    </td>
    <td>
      Start recording
    </td>
    <td>
      Do nothing
    </td>
  </tr>
  <tr>
    <td>
      <code>C-x&nbsp;)</code>
    </td>
    <td>
      <code>kmacro-end-macro</code>
    </td>
    <td>
      End recording
    </td>
    <td>
      Do nothing
    </td>
  </tr>
  <tr>
    <td>
      <code>C-x&nbsp;e</code>
    </td>
    <td>
      <code>kmacro-end-and-call-macro</code>
    </td>
    <td>
      Call macro
    </td>
    <td>
      End recording and call macro
    </td>
  </tr>
</table>
<p>
  The key sequences in the table above can be divided into three
  groups:
</p>
<ul>
  <li>
    <code>C-x (</code> and <code>C-x )</code>: These invoke simple
    commands that start and stop macro recording.
  </li>
  <li>
    <code>F3</code> and <code>F3</code>: These are wrappers around the
    simple commands.
  </li>
  <li>
    <code>C-x e</code>: This is a slightly high level command too that
    wraps around simpler macro commands and functions that end
    recording and calls a macro.
  </li>
</ul>
<p>
  Given these details, there are broadly two ways these macro key
  sequences can be used.  They are shown in the table below.
</p>
<table class="grid">
  <tr>
    <th>Operation</th>
    <th>Using Function Keys</th>
    <th>Using Control Keys</th>
  </tr>
  <tr>
    <td>Start recording</td>
    <td><code>F3</code></td>
    <td><code>C-x (</code></td>
  </tr>
  <tr>
    <td>Stop recording</td>
    <td><code>F4</code></td>
    <td><code>C-x )</code></td>
  </tr>
  <tr>
    <td>Call macro</td>
    <td><code>F4</code></td>
    <td><code>C-x e</code></td>
  </tr>
  <tr>
    <td>Stop recording and call macro</td>
    <td><code>F4 F4</code></td>
    <td><code>C-x e</code></td>
  </tr>
  <tr>
    <td>Repeat call macro</td>
    <td><code>F4</code></td>
    <td><code>e</code></td>
</table>
<p>
  If you are comfortable using function keys, you might want to follow
  the second column in the table above.  Otherwise, you might want to
  follow the third column in the table above.
</p>
<p>
  The last row is not mentioned in the book but the fact
  that <code>e</code> may be used to repeat a macro call performed
  with <code>C-x e</code> is documented in the Emacs
  manual: <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Basic-Keyboard-Macro.html">Keyboard
  Macros: Basic Use</a>.
</p>
<p>
  Note that <code>F3</code> inserts a counter value and increments the
  counter value by 1 or by the number specified via a digit argument.
  Here is an example key sequence that may be typed in a buffer with
  multiple lines to demonstrate this:
</p>
<ol>
  <li>
    Type <code>C-x (</code> to start macro recording.
  </li>
  <li>
    Type <code>C-a F3 . SPC M-c C-n</code> to insert macro counter
    which <code>0</code> by default, followed by dot and space at the
    beginning of the line, capitalise the first word and move to the
    next line.
  </li>
  <li>
    Type <code>C-x e</code> to stop macro recording and call the
    recorded macro.  Now <code>1</code>, dot and space is inserted at
    the beginning of the line.  The first word of the current line is
    capitalised and the cursor moves to the next line.
  </li>
  <li>
    Type <code>e</code> to repeat the macro call.  Keep
    typing <code>e</code> to repeat the macro call.
  </li>
</ol>
<p>
  The behaviour of the the macro commands change with universal
  arguments and digit arguments as follows:
</p>
<ul>
  <li>
    <code>C-u F3</code>: Execute the last macro, then record new macro
    and append it to the last macro.  Set
    <code>kmacro-execute-before-append</code> to <code>nil</code>
    (it is <code>t</code> by default) to prevent executing the last
    macro before appending a new macro to the last macro.
  </li>
  <li>
    <code>C-u C-x (</code>: Same as above.
  </li>
  <li>
    <code>C-5 F3</code>: Start recording but set counter to 5, i.e.
    while a macro is being recorded, typing <code>F3</code> inserts 5
    the first time, 6 the second time and so on.  The numeric prefix
    argument sets the counter value.
  </li>
  <li>
    <code>C-5 C-x (</code>: Same as above.
  </li>
  <li>
    <code>C-u F4</code>: Execute the second macro in the ring.
  </li>
  <li>
    <code>C-7 F4</code>: Repeat the last macro 7 times.
  </li>
  <li>
    <code>C-7 C-x e</code>: Repeat the last macro 7 times.
  </li>
  <li>
    <code>C-0 F3</code>: Repeat macro until there is an error (e.g.
    reaching the end of a buffer).
  </li>
  <li>
    <code>C-0 C-x e</code>: Same as above.
  </li>
</ul>
<p>
  Type <code>C-x C-k C-h</code> to discover keyboard macro commands
  and their key bindings.  The list below shows some of the
  interesting ones mentioned in the book.  In the list below, complete
  key sequences are used, so that they serve as a demonstration of the
  macro commands.
</p>
<ul>
  <li>
    <code>C-x C-k C-a 20 RET</code>: Add 20 value to the counter.
  </li>
  <li>
    <code>C-x C-k TAB</code>: Insert counter.  Note that we saw earlier
    that this can also be done with <code>F3</code>.
  </li>
  <li>
    <code>C-x C-k C-c</code>: Set counter.
  </li>
  <li>
    <code>C-x C-k C-f %02x</code>: Set macro counter format to
    zero-padded two-digit hexadecimal numbers with a minimum width of
    2.
  </li>
</ul>
<p>
  Note that all of the above commands work fine even when no macro
  recording is in progress.  For example, earlier we saw
  that <code>F3</code> inserts the macro counter value only when a
  macro recording is in progress.  However, <code>C-x C-k TAB</code>
  inserts the macro counter value even when a macro recording is not
  in progress.
</p>
<p>
  Another interesting feature mentioned in the book is querying for
  user input while recording a keyboard macro.  The key sequence to
  query the user is <code>C-x C-k q</code> or <code>C-x q</code>.
  Here are a few complete key sequences that may be used to
  demonstrate this feature:
</p>
<ul>
  <li>
    <code>F3 C-n C-a foo: C-x q C-e :bar F4</code>: This defines a
    macro such that when we execute the macro by
    typing <code>F4</code> one more time, the macro first
    inserts <code>foo</code> at the beginning of the next line, then
    it prompts us to decide if we want to continue with macro
    execution.  If we type type <code>y</code>, then it continues with
    the remainder of the macro execution.  If we type <code>n</code>,
    it skips the rest of the macro iteration and continue with the
    next iteration of the macro (such as when we are replaying the
    macro multiple times with a digit argument).  If we
    type <code>RET</code>, it skips the rest of the macro execution as
    well as skip any further iterations of the macro (in case we are
    replaying the macro multiple times).
  </li>
  <li>
    <code>F3 C-a foo: C-x C-k q C-e :bar F4</code>: Same as above but
    slightly longer key sequence.  The key sequence in the previous
    point is easier to remember and type.
  </li>
</ul>
<p>
  In the above examples, when the macro playback prompts queries for
  user input, we can also type <code>C-l</code> to recentre the
  screen, <code>C-r</code> to enter recursive edit or
  <code>C-M-c</code> to exit recursive edit.
</p>
<p>
  Note that the key sequence <code>C-l</code> behaves a little
  differently from the regular <code>C-l</code>.  Unlike the
  regular <code>C-l</code>, successive invocations of this key
  sequence during macro query does not cause the window to reposition
  at various places (centre, top and bottom by default) in a cyclical
  order.  Successive invocations of <code>C-l</code> during macro
  query, leaves the screen centred.
</p>
<p>
  Here are some key sequences to save and recall macros:
</p>
<ul>
  <li>
    <code>C-x C-k C-p</code>: Move to the previous keyboard macro in
    the keyboard macro ring.
  </li>
  <li>
    <code>C-x C-k C-n</code>: Move to the next keyboard macro in the
    keyboard macro ring.
  </li>
  <li>
    <code>C-x C-k n foo RET</code>: Assign the name <code>foo</code>
    to the current keyboard macro in the keyboard macro ring.  Now the
    macro can be executed by simply typing <code>M-x foo RET</code>.
  </li>
  <li>
    <code>M-x insert-kbd-macro foo RET</code>: Insert the definition
    of the named keyboard macro <code>foo</code> as Elisp code into
    the current buffer.
  </li>
  <li>
    <code>C-x C-k b C-c 1</code>: Assign the key sequence <code>C-c
    1</code> to the current keyboard macro in the keyboard macro ring.
    Now the macro can be executed by simply typing <code>C-c 1</code>.
  </li>
</ul>
<p>
  Finally, here are some commands to edit keyboard macros:
</p>
<ul>
  <li>
    <code>C-x C-k e C-x e</code>: Edit the current keyboard macro.
  </li>
  <li>
    <code>C-x C-k e M-x foo RET</code>: Edit the keyboard macro
    named <code>foo</code>.
  </li>
  <li>
    <code>C-x C-k e C-c 1</code>: Edit the keyboard macro
    bound to <code>C-c 1</code>.
  </li>
  <li>
    <code>C-x C-k l</code>: View the most recent 300 keystrokes and
    edit it to create a new keyboard macro.
  </li>
  <li>
    <code>M-x kmacro-edit-lossage RET</code>: Same as above.
  </li>
</ul>
<p>
  A few additional commands:
</p>
<ul>
  <li>
    <code>C-h l</code>: See the last 300 characters typed (lossage).
  </li>
  <li>
    <code>M-x open-dribble-file foo.txt RET</code>: Write input events
    to a dribble file named <code>foo.txt</code>.
  </li>
  <li>
    <code>M-: (open-dribble-file nil) RET</code>: Close the dribble file.
  </li>
</ul>
<h2 id="text-expansion">Text Expansion<a href="#text-expansion"></a></h2>
<h3 id="abbrev">Abbrev<a href="#abbrev"></a></h3>
<p>
  Here are some Abbrev commands:
</p>
<ul>
  <li>
    <code>C-x a l</code>: Take the word before the cursor and define a
    mode-specific abbreviation for it.
  </li>
  <li>
    <code>C-x a g</code>: Take the word before the cursor and define a
    global abbreviation for it.
  </li>
  <li>
    <code>C-x a i l</code>: Take the abbreviated word before the
    cursor and define a mode-specific expansion for it.
  </li>
  <li>
    <code>C-x a i l</code>: Take the abbreviated word before the
    cursor and define a global expansion for it.
  </li>
</ul>
<p>
  Note that for the expansions to work Abbrev mode should be enabled,
  say with <code>M-x abbrev-mode RET</code>.
</p>
<p>
  Here are some complete key sequences that demonstrate how we can use
  Abbrev to define an abbreviation, i.e. text that automatically gets
  replaced by another text:
</p>
<ul>
  <li>
    <code>Use SPC Debian C-x a l deb RET</code>: Define a
    mode-specific abbreviation <code>deb</code> such that whenever we
    type <code>deb</code>, it automatically expands
    to <code>Debian</code>.
  </li>
  <li>
    <code>Use SPC Linux C-x a g lnx RET</code>: Define a global
    abbreviation <code>lnx</code> such that whenever we
    type <code>lin</code>, it automatically expands
    to <code>Linux</code>.
  </li>
  <li>
    <code>Hello SPC wld C-x a i l World RET</code>: Define a
    mode-specific abbreviation <code>wld</code> such that whenever we
    type <code>wld</code>, it automatically expands
    to <code>World</code>.
  </li>
  <li>
    <code>Hello SPC evry C-x a i g Everyone RET</code>: Define a
    global abbreviation <code>evry</code> such that whenever we
    type <code>evry</code>, it automatically expands
    to <code>Everyone</code>.
  </li>
</ul>
<p>
  Although not mentioned in the book, these commands can be used with
  a numeric prefix argument to specify the number of words before the
  cursor to be picked for expansion for the abbreviation we are about
  to define.  Here are some complete key sequences that demonstrate
  this:
</p>
<ul>
  <li>
    <code>I use Debian GNU/Linux C-3 C-x a l dgl</code>: Define a
    mode-specific abbreviation <code>dgl</code> such that whenever we
    type <code>dgl</code>, it automatically expands to <code>Debian
    GNU/Linux</code>.
  </li>
  <li>
    <code>I use Debian GNU/Linux C-3 C-x a g dgl</code>: Similar to
    above but define a global abbreviation.
  </li>
</ul>
<h3 id="dabbrev">DAbbrev<a href="#dabbrev"></a></h3>
<p>
  There are two key bindings discussed in the book:
</p>
<ul>
  <li>
    <code>M-/</code>: Expand the word just before the cursor to the
    nearest preceding word for which the current word is a prefix.  If
    no suitable preceding word is found, expand it to the nearest
    succeeding word for which the current word is a prefix.  Repeating
    this command cycles between the other matches found.
  </li>
  <li>
    <code>C-M-/</code>: Find all words in the buffer that has the
    current word before the cursor as the prefix and expand the
    current word to the longest common prefix of all these matching
    words.  However, if the longest common prefix of the matching
    words is same as the word before the cursor, then present them as
    suggestions for completion.  If there is exactly one matching
    word, expand the word before the cursor to that word.
  </li>
</ul>
<p>
  The last command above takes a little while to get used to it.  The
  following steps demonstrate how it works.
</p>
<ol>
  <li>
    <p>
      Create a text buffer with the following line:
    </p>
    <pre><code>abacus apple appliance application</code></pre>
  </li>
  <li>
    Type <code>ap</code> followed by <code>C-M-/</code>, the word
    expands to <code>appl</code> since that is the longest common
    prefix among the matching words.
  </li>
  <li>
    Type <code>C-M-/</code> again.  The matching
    words <code>apple</code>, <code>appliance</code>
    and <code>application</code> are presented as possible completions
    in a temporary buffer named <code>*Completions*</code>.
  </li>
  <li>
    Now type <code>ic</code>, so that the word before the cursor
    becomes <code>applic</code> and type <code>C-M-/</code> again.
    Now the word before the cursor expands to <code>application</code>
    because that is the only possible completion now.
  </li>
</ol>
<p>
  Note that by default DAbbrev looks for matching words in other open
  buffers too and offers them as completions.
</p>
<h3 id="hippie-expand">Hippie Expand<a href="#hippie-expand"></a></h3>
<p>
  Unlike DAbbrev, Hippie Expand goes beyond open buffers to look for
  expansions.  The variable
  <code>hippie-expand-try-functions-list</code> contains a list of
  expansion functions that <code>hippie-expand</code> uses to look for
  completions.  The book suggests remapping <code>M-/</code> to
  invoke <code>hippie-expand</code> with this Elisp code:
</p>
<pre><code>(global-set-key [remap dabbrev-expand] 'hippie-expand)</code></pre>
<p>
  By default, Hippie Expand can complete file names, complete lines,
  etc.  For example, if there is a line for which the current line is
  a prefix (leading whitespace is ignored while checking for matches),
  then the current line is expanded to the other matchine line.
</p>
<p>
  Repeated invocations of this command cycles between the matches.
</p>
<p>
  As mentioned earlier, the
  variable <code>hippie-expand-try-functions-list</code> determines
  which expansion algorithms are used.  Here is an example that
  demonstrates how we can alter this variable:
</p>
<pre><code>(setq hippie-expand-try-functions-list '(try-complete-lisp-symbol))</code></pre>
<p>
  The above rather unrealistic example severely restricts the
  expansions Hippie Expand can perform.  With the above example, word
  expansion, line expansion, file name completion, etc. are disabled.
  Only Elisp symbols are expanded.  For example,
  typing <code>white</code> followed by <code>M-/</code> first expands
  the word to <code>whitespace</code> because all matching Elisp
  symbols have that as the longest common prefix.
  Typing <code>M-/</code> over and over again, completes the expansion
  further with various Elisp symbols.
</p>
<p>
  As mentioned before, the above example is highly atypical.  The
  above example is only meant for demonstrating how this variable can
  be set.  Typically, users add more functions to this variable to add
  more expansion capabilities.
</p>
<h2 id="indenting">Indenting<a href="#indenting"></a></h2>
<h3 id="electric-indentation">Electric Indentation<a href="#electric-indentation"></a></h3>
<p>
  Emacs automatically indents code as we type.  The major mode decides
  the automatic indentation behaviour.  The automatic identation is
  provided by a global minor mode named
  <code>electric-indent-mode</code> which is enabled by default.
</p>
<h3 id="indenting-current-line">Indenting Current Line<a href="#indenting-current-line"></a></h3>
<p>
  Typing <code>TAB</code> indents the current line.  In many modes
  like <code>emacs-lisp-mode</code>, <code>python-mode</code>,
  <code>text-mode</code>, etc. the command
  <code>indent-for-tab-command</code> is bound to it.  But there are
  modes that bind another command to <code>TAB</code>.  For example,
  in <code>c-mode</code>, the command
  <code>c-indent-line-or-region</code> is bound to <code>TAB</code>.
</p>
<p>
  The behaviour of <code>indent-for-tab-command</code> is determined
  by the variables <code>tab-always-indent</code>.  It
  is <code>t</code> by default which causes <code>TAB</code> to just
  indent the current line.  If set to <code>nil</code>,
  hitting <code>TAB</code> indents the current line only if the point
  is before the first non-whitespace character of the line.  Otherwise
  it inserts tabs or spaces to move the point to the next tab stop
  column.  If set to <code>'complete</code>, typing <code>TAB</code>
  first tries to indent the current line but if the line is already
  correctly indented, then it tries to complete the thing at point.
</p>
<p>
  When <code>indent-for-tab-command</code> is bound
  to <code>TAB</code> and when <code>indent-for-tab-command</code>
  decides to indent the current line, it calls the function in the
  variable <code>indent-line-function</code> to perform the
  indentation.  Here is a table that shows
  what <code>indent-line-function</code> contains in a few major modes
  where <code>indent-for-tab-command</code> command is bound
  to <code>TAB</code>:
</p>
<table class="grid">
  <tr>
    <th><code>major-mode</code></th>
    <th><code>indent-line-function</code></th>
  </tr>
  <tr>
    <td><code>emacs-lisp-mode</code></td>
    <td><code>lisp-indent-line</code></td>
  </tr>
  <tr>
    <td><code>python-mode</code></td>
    <td><code>python-indent-line-function</code></td>
  </tr>
  <tr>
    <td><code>text-mode</code></td>
    <td><code>indent-relative</code></td>
  </tr>
</table>
<p>
  While <code>lisp-indent-line</code> and
  <code>python-indent-line</code> attempt to indent the current line
  according to the syntax of the language,
  <code>indent-relative</code> inserts tabs and spaces to move the
  point to the next indentation point where the indentation point is
  defined as the next non-whitespace character following whitespace.
  This can be useful in aligning the point with words in the previous
  line.  If the previous line has no indentation point (e.g. the
  previous line is an empty line or does not have whitespace),
  then <code>tab-to-tab-stop</code> is invoked which inserts tabs or
  spaces to move the point to the next tab stop column.
</p>
<p>
  The command <code>tab-to-tab-stop</code> command introduced in the
  previous paragraph can also be invoked with <code>M-i</code>.
</p>
<h3 id="use-only-spaces-for-indentation">Use Only Spaces for Indentation<a href="#use-only-spaces-for-indentation"></a></h3>
<p>
  By default, Emacs uses a mix of tabs and spaces for indentation and
  alignment.  When it needs to align the first non-whitespace
  character of a line with a certain token in the previous line, it
  would insert as many tabs as it can followed by a few spaces if
  necessary to attain the desired alignment.  To force Emacs to always
  use spaces for indentation and alignment, add the following Elisp
  code to the Emacs initialisation file:
</p>
<pre><code>(setq-default indent-tabs-mode nil)</code></pre>
<h3 id="tab-width">Tab Width<a href="#tab-width"></a></h3>
<p>
  The variable <code>tab-width</code> is used in various contexts
  while performing indentation and alignment.  For example,
  when <code>indent-tabs-mode</code> is enabled, for
  every <code>tab-width</code> columns of indentation required, Emacs
  inserts a tab to indent the code.
</p>
<p>
  Also, when <code>indent-tabs-mode</code> is set to <code>nil</code>,
  typing <code>M-i</code> inserts as many spaces as necessary to move
  the point to the next tab stop column where the distance between two
  tab stops is assumed to be <code>tab-width</code>.
</p>
<h3 id="edit-tab-stops">Edit Tab Stops<a href="#edit-tab-stops"></a></h3>
<p>
  The behaviour of <code>M-i</code> can be customised further by
  manually defining tab stop columns.  Type <code>M-x edit-tab-stops
  RET</code> first.  A buffer named <code>*Tab Stops*</code> appears.
  The second and third line of this buffer contains a ruler to
  indicate the column numbers.  Type <code>:</code> (i.e. colon) in
  the first line whereever you want to define tab stops.  Then
  type <code>C-c C-c</code> to install the changes.  Now
  when <code>M-i</code> is typed in a text buffer, each time it
  inserts as many tabs (if <code>indent-tabs-mode</code>
  is <code>t</code>) or spaces as necessary to move the point to the
  next tab stop column as defined earlier in the <code>*Tab
  Stops*</code> buffer.
</p>
<h3 id="indent-regions">Indent Region<a href="#indent-regions"></a></h3>
<p>
  Typing <code>TAB</code> when a region is active indents the region
  according to the major mode's indentation rules.  It invokes the
  same command as the one invoked when we type <code>TAB</code> to
  indent a line.  The command bound to it takes care of indenting
  region.  For example, if <code>TAB</code> is bound
  to <code>indent-for-tab-command</code>, the latter checks if a
  region is active and if it is, then it simply
  calls <code>indent-region</code>.
</p>
<p>
  The <code>indent-region</code> command can be invoked explicitly
  using <code>C-M-\</code>.  If <code>fill-prefix</code> has been set,
  say with <code>C-x .</code>, then it is added to every line in the
  region being indented.  With a numeric prefix argument, each line in
  the region is indented to the column indicated by the argument.  For
  example, <code>C-M-1 C-M-0 C-M-\</code> indents each line of the
  region to column 10.
</p>
<h3 id="indent-rigidly">Indent Rigidly<a href="#indent-rigidly"></a></h3>
<p>
  When we want to rigidly control how a region must be indented, we
  can type <code>C-x TAB</code> to perform rigid indentation.  Doing
  so allows us to bypass the indentation rules of the major mode.
  Instead we control exactly how the indentation must be done.  The
  following complete key sequences demonstrates a few examples of
  rigid indentation:
</p>
<ul>
  <li>
    <code>C-x TAB</code>: Interactively indent region.
    Type <code>&lt;right&gt;</code> or <code>&lt;left&gt;</code> to
    increase or decrease indentation by one space respectively.
    Type <code>&lt;right&gt;</code> or <code>&lt;left&gt;</code> to
    increase or decrease indentation by one tab stop respectively.
  </li>
  <li>
	<code>C-6 C-x TAB</code>: Indent region by 6 spaces.  Appropriate
	number of tabs and spaces are inserted to achieve an apparent 6
	spaces of indentation.  Whether tabs are inserted or not and how
	many tabs are inserted depend on the values
	of <code>indent-tabs-mode</code> and <code>tab-width</code> as
	explained in the previous sections.
  </li>
  <li>
	<code>C-- C-6 C-x TAB</code>: Reduce indentation of region by 6
	spaces.
  </li>
</ul>
<h2 id="sorting">Sorting<a href="#sorting"></a></h2>
<p>
  Assuming a region is active, here are some complete key sequences
  for various sorting commands:
</p>
<ul>
  <li>
    <code>M-x sort-lines RET</code>: Sort lines alphabetically.
  </li>
  <li>
    <code>C-u M-x sort-lines RET</code>: Reverse sort lines
    alphabetically.
  </li>
  <li>
    <code>M-x sort-fields RET</code>: Sort lines alphabetically by the
    first field alphabetically.  Fields are separated by whitespace.
  </li>
  <li>
    <code>M-2 M-x sort-fields RET</code>: Sort lines alphabetically
    by the second field.
  </li>
  <li>
    <code>M-2 M-x sort-numeric-fields RET</code>: Sort lines
    numerically by the second field.
  </li>
  <li>
    <code>M-x sort-columns RET</code>: Sort columns between the column
    position of mark and column position of point.
  </li>
  <li>
    <code>M-x sort-regexp-fields RET [A-Z]*-&gt;\(.*\) RET \1 RET</code>:
    Sort the strings in each line matched by the given regular
    expression by the field matched by the first (and the only)
    capturing group in the regular expression.  The part of each line
    that is not matched by the regular expression remains intact.
    They never move.  Only the part of each line that is matched by
    the regular expression moves around during the sorting operation.
  </li>
  <li>
    <code>M-x sort-regexp-fields RET</code>: Sort paragraphs
    alphabetically.
  </li>
</ul>
<h2 id="aligning">Aligning<a href="#aligning"></a></h2>
<p>
  The two simple commands for aligning text introduced first in the
  book are:
</p>
<ul>
  <li>
    <code>M-x align RET</code>: Aligns current region.
  </li>
  <li>
    <code>M-x align-current RET</code>: Aligns current section.  A
    section is a group of consecutive lines both below, above and
    including the current line for which the first alignment rule
    (according to the major mode) applies.
  </li>
</ul>
<p>
  Consider the following Elisp buffer:
</p>
<pre>
<code>(defvar person '(("name" . "Alice")
                 ("city" . "London")
                 ("country" . "UK")))</code>
</pre>
<p>
  If we type <code>C-x h</code> followed by <code>M-x align RET</code>
  or if we put the cursor on any line of the above code and
  type <code>M-x align-current RET</code>, we get the following
  result:
</p>
<pre>
<code>(defvar alice '(("name"    . "Alice")
                ("city"    . "London")
                ("country" . "UK")))</code>
</pre>
<p>
  There is also an <code>align-regexp</code> command that allows us to
  parts of lines by regular expressions.  The following experiments
  demonstrate this command.
</p>
<ol>
  <li>
    First create a buffer with the following text:
<pre>
<code>Alice:London:UK
Bob:Paris:France
Carol:Tokyo:Japan</code>
</pre>
  </li>
  <li>
    <p>
      Type <code>C-x h</code> followed by <code>C-u M-x align-regexp
        \(\s-*\): RET 1 RET 1 RET y RET</code>.  The result looks like
        this:
    </p>
<pre>
<code>Alice :London :UK
Bob   :Paris  :France
Carol :Tokyo  :Japan</code>
</pre>
    <p>
      Note that the regular expression capturing
      group <code>\(\s-*\)</code> appears as the default in the
      minibuffer.  We only add <code>:</code> to it.  Similarly the
      two occurrences of <code>1</code> appear as default values.  The
      first <code>1</code> is the default for determining which
      parenthesis group to modify.  The second <code>1</code> is the
      default for amount of spacing to be used during alignment.
      The <code>y</code> in the end specifies that we want to repeat
      the alignment throughout the line.
    </p>
  </li>
  <li>
      Type <code>C-/</code> to undo the changes done in the last step.
      Then type <code>C-x h</code> followed by <code>M-x align-regexp
      : RET</code>.  This is a shorter equivalent to the previous
      command.  The output is same as before.
  </li>
  <li>
    <p>
      Type <code>C-/</code> to undo the changes done in the last step.
      Then type <code>C-x h</code> followed by <code>C-u M-x
      align-regexp :\(\s-*\) RET 1 RET 1 y RET</code>.  Note that the
      only difference this time is that we place the colon before the
      parenthesis group.  The result looks like this:
    </p>
<pre>
<code>Alice: London: UK
Bob:   Paris:  France
Carol: Tokyo:  Japan</code>
</pre>
  </li>
  <li>
    <p>
      Type <code>C-/</code> to undo the changes done in the last step.
      Then type <code>C-x h</code> followed by <code>C-u M-x
      align-regexp \(\s-*\): RET 1 RET 0 y RET</code>.  Note that the
      only difference this time is that we place the colon before the
      parenthesis group.  We specify <code>0</code> as the amount of
      spacing this time, so a minimum of zero spacing is used for
      alignment when possible.  The result looks like the following.
      Notice the lack of space after <code>Alice</code>
      and <code>Carol</code>.
    </p>
<pre>
<code>Alice:London:UK
Bob  :Paris :France
Carol:Tokyo :Japan</code>
</pre>
  </li>
  <li>
    <p>
      Type <code>C-/</code> to undo the changes done in the last step.
      Then type <code>C-x h</code> followed by <code>C-u M-x
      align-regexp \(\s-*\): RET 1 RET 5 y RET</code>.  Note that the
      only difference this time is that we place the colon before the
      parenthesis group.  We specify <code>5</code> as the amount of
      spacing this time, so a minimum of 5 spaces are used for
      alignment.
    </p>
<pre>
<code>Alice     :London     :UK
Bob       :Paris      :France
Carol     :Tokyo      :Japan</code>
</pre>
  </li>
</ol>
<h2 id="zap-to-char">Zap to Char<a href="#zap-to-char"></a></h2>
<p>
  The steps below demonstrate the <code>zap-to-char</code> command
  that is bound to the key sequence <code>M-z</code>.  This command
  kills up to and including the given character.
</p>
<ol>
  <li>
    <p>
      Create a buffer with the following text:
    </p>
    <pre><code>foo bar baz qux quux</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-&lt;</code> to go to the beginning of the buffer
      and then type <code>M-z r</code> to kill text up to and
      including the first occurrence of the letter <code>r</code>.
      The buffer now looks like this:
    </p>
    <pre><code>  baz qux quux</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-&lt;</code> to go to the beginning of the buffer
      and then type <code>M-z x</code> to kill text up to and
      including the first occurrence of the letter <code>x</code>.
      The buffer now looks like this:
    </p>
    <pre><code> quux</code></pre>
  </li>
  <li>
    <p>
      Now type <code>C-e SPC C-y</code> to reinsert the killed text at
      the end of the line.  The buffer now looks like this:
    </p>
    <pre><code> quux foo bar baz qux</code></pre>
    <p>
      Note that the last step yanks both chunks of text that were
      killed in the previous two steps.  This is due to the fact that
      consecutive kills append to the same stretch of text in the kill
      ring.  This fact was discussed earlier in
      section <a href="#append-kill">Append Kill</a>
    </p>
  </li>
  <li>
    <p>
      Now type <code>M-&lt;</code> to go back to the beginning of the
      buffer again.  Then type <code>M-2 M-z a</code>.  The numeric
      argument <code>2</code> specifies that we want to zap up to the
      second occurrence of the letter <code>a</code>.  The buffer
      looks like this:
    </p>
    <pre><code>z qux</code></pre>
  </li>
  <li>
    <p>
      Type <code>C-e SPC C-y</code> to reinsert the text killed in the
      previous step at the end of the line.  The buffer looks like
      this now:
    </p>
    <pre><code>z qux quux foo bar ba</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-- M-2 M-z x</code> to zap backward up to the second
      occurrence of the letter <code>x</code>.  The buffer looks like
      this now:
    </p>
    <pre><code>z qu</code></pre>
  </li>
</ol>
<h2 id="zap-up-to-char">Zap up to Char<a href="#zap-up-to-char"></a></h2>
<p>
  Here are some steps that demonstrate the <code>zap-up-to-char</code>
  command.  This command kills text up to, but not including, the
  given character.
</p>
<ol>
  <li>
    <p>
      Create a buffer with the following text:
    </p>
    <pre><code>foo bar baz qux quux</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-&lt;</code> to go to the beginning of the buffer.
      Then type <code>M-x zap-up-to-char RET b</code>.  The result now
      looks like this:
    </p>
    <pre><code>bar baz qux quux</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-2 M-x zap-up-to-char RET q</code>.  The result now
      looks like this:
    </p>
    <pre><code>quux</code></pre>
  </li>
  <li>
    <p>
      Type <code>C-e SPC C-y</code> to reinsert the killed text at the end
      of the buffer:
    </p>
    <pre><code>quux foo bar baz qux </code></pre>
  </li>
  <li>
    <p>
      Type <code>M-- M-2 M-x zap-up-to-char RET b</code>.  The buffer
      now looks like this:
    </p>
    <pre><code>quux foo b</code></pre>
  </li>
</ol>
<p>
  The author of the book suggests binding this command
  to <code>M-S-z</code> with the following Elisp code:
</p>
<pre><code>(global-set-key (kbd "M-S-z") 'zap-up-to-char)</code></pre>
<p>
  The above code, however, does not create the binding successfully.
  Therefore, use the following Elisp code instead:
</p>
<pre><code>(global-set-key (kbd "M-Z") 'zap-up-to-char)</code></pre>
<p>
  Now the commands presented in this section above can be typed as
  follows:
</p>
<ul>
  <li><code>M-Z b</code></li>
  <li><code>M-2 M-Z q</code></li>
  <li><code>M-- M-Z b</code></li>
</ul>
<h2 id="spell-check">Spell Check<a href="#spell-check"></a></h2>
<p>
  The spell checking commands of Emacs require a spell checking
  program to be installed on the system.  Emacs supports the spell
  checking programs <code>aspell</code>, <code>ispell</code>,
  <code>hunspell</code> and <code>enchant-2</code>.  If multiple
  programs are present, it looks for them one by one in the order
  specified in the previous sentence and picks the first one that is
  found.  The following spell checking commands are introduced in the
  book:
</p>
<ul>
  <li>
    <code>M-$</code>: Check spelling of word under or before the
    cursor.  Possible corrections are offered in a new window.  If the
    word under or before the cursor is already correct, a message
    like <code>APPLE is correct</code> appears in the echo area.  When
    corrections are offered, each correction is numbered.
    Type <code>SPC</code> to leave the word unchanged or type a number
    to choose a numbered correction.  Type <code>x</code> to exit the
    the spelling buffer (the one that shows corrections).
    Type <code>q</code> to quit the spelling session (kills the
    spelling program process).  To see the list of all key bindings
    supported, type <code>C-h f ispell-help RET</code>.
  </li>
  <li>
    <code>M-x flyspell-mode RET</code>: Toggle on-the-fly spell
    checking.  Misspelled words are underlined with squiggly lines.
    Type <code>C-M-i</code> or <code>C-.</code> to correct a
    misspelled word under or before the cursor.  All possible
    corrections appear in the echo area.  Repeat <code>C-M-i</code>
    or <code>C-.</code> to cycle through the possible corrections.
  </li>
  <li>
    <code>M-x flyspell-prog-mode RET</code>: Turns
    on <code>flyspell-mode</code> for comments and strings only.  This
    is useful while working in a buffer with a programming mode
    enabled.
  </li>
  <li>
    <code>M-x ispell-buffer RET</code>: Check the current buffer for
    spelling errors interactively.  Each misspelled word is
    highlighted and corrections are offered in a new window.  The
    interface and key sequences for making corrections are the same as
    the ones for <code>M-$</code> introduced above.
  </li>
  <li>
    <code>M-x ispell-region RET</code>: Like the previous command but
    checks the current region for spelling errors.
  </li>
</ul>
<h2 id="dictionary-lookup">Dictionary Lookup<a href="#dictionary-lookup"></a></h2>
<p>
  The following complete key sequences demonstrate some of the
  dictionary commands introduced in the book:
</p>
<ul>
  <li>
    <code>M-x dictionary-lookup-definition RET</code>: Look up
    definitions of the word at or before the cursor.
  </li>
  <li>
    <code>M-x dictionary-search RET programming RET</code>: Search
    definitions of the word <code>programming</code>.
  </li>
  <li>
    <code>M-x dictionary-select-dictionary RET</code>: This command
    presents a list of available dictionaries in a new buffer.
    Navigate the buffer and click on a dictionary or
    type <code>RET</code> while the cursor is on a dictionary entry to
    select it.  For example, move the cursor down to the entry that
    begins with the text <code>jargon:</code> and
    type <code>RET</code> and then type <code>M-x dictionary-search
    RET programming RET</code> to see the definition of the
    word <code>programming</code> from the Jargon File only.
  </li>
</ul>
<p>
  The dictionary commands first attempt to connect to a locally
  running dictionary server.  If the connection does not succeed, it
  prompts for consent to connect to
  <a href="https://dict.org/">dict.org</a>.  Typing <code>y</code> at
  the prompt allows the command to proceed and complete the command.
</p>
<h2 id="quoted-insert">Quoted Insert<a href="#quoted-insert"></a></h2>
<p>
  Here are some complete key sequences that demonstrate quoted insert:
</p>
<ul>
  <li>
    <code>C-q C-l</code>: Insert form feed character.  This is
    displayed as <samp>^L</samp> in Emacs using the face
    named <code>escape-glyph</code>.  Emacs treats each form feed
    character as a page break and we can navigate back and forth
    between pages with <code>C-x [</code> and <code>C-x ]</code>
    respectively.
  </li>
  <li>
    <code>C-q (</code>: Insert a literal open parenthesis.  Useful
    in <code>paredit-mode</code> where the key sequence <code>(</code>
    is bound to <code>paredit-open-round</code> which inserts a
    balanced pair of parentheses.  To insert a single parenthesis
    instead, we can perform a quoted insert with <code>C-q (</code>.
  </li>
  <li>
    <code>C-q TAB</code>: Insert a literal tab character.
  </li>
  <li>
    <code>C-q C-j</code>: Insert a literal line feed character, i.e.
    a newline character.
  </li>
  <li>
    <code>C-q RET</code>: Insert a literal carriage return.  This is
    displayed as <samp>^M</samp> in Emacs.
  </li>
  <li>
    <code>C-q ESC</code>: Insert a literal escape character.  This is
    displayed as <samp>^[</samp> in Emacs.
  </li>
  <li>
    <code>C-q C-[</code>: Same as above.
  </li>
</ul>
<h2 id="links">Links<a href="#links"></a></h2>
<p>
  The following list includes some links that were discussed during
  the book discussion group meetings:
</p>
<ul>
  <li>
    <a href="https://battlepenguin.com/tech/aspell-and-hunspell-a-tale-of-two-spell-checkers/">Aspell and Hunspell: A Tale of Two Spell Checkers</a>
  </li>
  <li>
    <a href="https://www.reddit.com/r/emacs/comments/fxs92h/">Spell
      checkers in Emacs in 2020</a>
  </li>
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/ch05.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Sorting in Emacs</title>
<link>https://susam.net/sorting-in-emacs.html</link>
<guid isPermaLink="false">umnyp</guid>
<pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  In this article, we will perform a series of hands-on experiments
  that demonstrate the various Emacs commands that can be used to sort
  text in different ways.  There is sufficient documentation available
  for these commands in the Emacs and Elisp manuals.  In this article,
  however, we will take a look at some concrete examples to illustrate
  how they work.
</p>
<h2 id="sorting-lines">Sorting Lines<a href="#sorting-lines"></a></h2>
<p>
  Our first set of experiments demonstrates different ways to sort
  lines.  Follow the steps below to perform these experiments.
</p>
<ol>
  <li> <!-- 1. Create buffer -->
    <p>
      First create a buffer that has the following text:
    </p>
<pre>
<code>Carol  200  London  LHR-&gt;SFO
Dan    20   Tokyo   HND-&gt;LHR
Bob    100  London  LCY-&gt;CDG
Alice  10   Paris   CDG-&gt;LHR
Bob    30   Paris   ORY-&gt;HND</code>
</pre>
    <p>
      Let us pretend that each line is a record that represents some
      details about different persons.  From left to right, we have
      each person's name, some sort of numerical ID, their current
      location and their upcoming travel plan.  For example, the first
      line says that Carol from London is planning to travel from
      London Heathrow (LHR) to San Francisco (SFO).
    </p>
  </li>
  <li> <!-- 2. sort-lines -->
    <p>
      Type <code>C-x h</code> to mark the whole buffer and
      type <code>M-x sort-lines RET</code> to sort lines
      alphabetically.  The buffer looks like this now:
    </p>
<pre>
<code>Alice  10   Paris   CDG-&gt;LHR
Bob    100  London  LCY-&gt;CDG
Bob    30   Paris   ORY-&gt;HND
Carol  200  London  LHR-&gt;SFO
Dan    20   Tokyo   HND-&gt;LHR</code>
</pre>
  </li>
  <li> <!-- 3. sort-lines (reverse) -->
    <p>
      Type <code>C-x h</code> followed by <code>C-u M-x sort-lines
      RET</code> to reverse sort lines alphabetically.  The key
      sequence <code>C-u</code> specifies a prefix argument that
      indicates that a reverse sort must be performed.  The buffer
      looks like this now:
    </p>
<pre>
<code>Dan    20   Tokyo   HND-&gt;LHR
Carol  200  London  LHR-&gt;SFO
Bob    30   Paris   ORY-&gt;HND
Bob    100  London  LCY-&gt;CDG
Alice  10   Paris   CDG-&gt;LHR</code>
</pre>
  </li>
  <li> <!-- 4. sort-fields (first) -->
    <p>
      Type <code>C-x h</code> followed by <code>M-x sort-fields
      RET</code> to sort the lines by the first field only.  Fields
      are separated by whitespace.  Note that the result now is
      slightly different from the result of <code>M-x sort-lines
      RET</code> presented in point 2 earlier.  Here Bob from Paris
      comes before Bob from London because the sorting was performed
      by the first field only.  The sorting algorithm ignored the rest
      of each line.  However in point 2 earlier, Bob from London came
      before Bob from Paris because the sorting was performed by
      entire lines.
    </p>
<pre>
<code>Alice  10   Paris   CDG-&gt;LHR
Bob    30   Paris   ORY-&gt;HND
Bob    100  London  LCY-&gt;CDG
Carol  200  London  LHR-&gt;SFO
Dan    20   Tokyo   HND-&gt;LHR</code>
</pre>
  </li>
  <li> <!-- 5. sort-fields (second) -->
    <p>
      Type <code>C-x h</code> followed by <code>M-2 M-x sort-fields
      RET</code> to sort the lines alphabetically by the second field.
      The key sequence <code>M-2</code> here specifies a numeric
      argument that identifies the field we want to sort by.  Note
      that <code>100</code> comes before <code>20</code> because we
      performed an alphabetical sort, not numerical sort.  The result
      looks like this:
    </p>
<pre>
<code>Alice  10   Paris   CDG-&gt;LHR
Bob    100  London  LCY-&gt;CDG
Dan    20   Tokyo   HND-&gt;LHR
Carol  200  London  LHR-&gt;SFO
Bob    30   Paris   ORY-&gt;HND</code>
</pre>
  </li>
  <li> <!-- 6. sort-numeric-fields -->
    <p>
      Type <code>C-x h</code> followed by <code>M-2 M-x
      sort-numeric-fields RET</code> to sort the lines numerically by
      the second field.  The result looks like this:
    </p>
<pre>
<code>Alice  10   Paris   CDG-&gt;LHR
Dan    20   Tokyo   HND-&gt;LHR
Bob    30   Paris   ORY-&gt;HND
Bob    100  London  LCY-&gt;CDG
Carol  200  London  LHR-&gt;SFO</code>
</pre>
  </li>
  <li> <!-- 7. sort-fields (third) -->
    <p>
      Type <code>C-x h</code> followed by <code>M-3 M-x sort-fields
      RET</code> to sort the lines alphabetically by the third field
      containing city names.  The result looks like this:
    </p>
<pre>
<code>Bob    100  London  LCY-&gt;CDG
Carol  200  London  LHR-&gt;SFO
Alice  10   Paris   CDG-&gt;LHR
Bob    30   Paris   ORY-&gt;HND
Dan    20   Tokyo   HND-&gt;LHR</code>
</pre>
    <p>
      Note that we cannot supply the prefix argument <code>C-u</code>
      to this command to perform a reverse sort by a specific field
      because the prefix argument here is used to identify the field
      we need to sort by.  If we do specify the prefix
      argument <code>C-u</code>, it would be treated as the numeric
      argument <code>4</code> which would sort the lines by the fourth
      field.  However, there is a little trick to reverse sort lines
      by a specific field.  The next point shows this.
    </p>
  </li>
  <li> <!-- 8. reverse-region -->
    <p>
      Type <code>C-x h</code> followed by <code>M-x reverse-region
      RET</code>.  This reverses the order of lines in the region.
      Combined with the previous command, this effectively
      reverse sorts the lines by city names.  The result looks like
      this:
    </p>
<pre>
<code>Dan    20   Tokyo   HND-&gt;LHR
Bob    30   Paris   ORY-&gt;HND
Alice  10   Paris   CDG-&gt;LHR
Carol  200  London  LHR-&gt;SFO
Bob    100  London  LCY-&gt;CDG</code>
</pre>
  </li>
  <li> <!-- 9. sort-fields (negative) -->
    <p>
      Type <code>C-x h</code> followed by <code>M-- M-2 M-x
      sort-fields RET</code> to sort the lines alphabetically by the
      second field from the right (third from the left).  Note that
      the first two key combinations are <kbd>meta</kbd>+<kbd>-</kbd>
      and <kbd>meta</kbd>+<kbd>2</kbd>.  They specify the negative
      argument <code>-2</code> to sort the lines by the second field
      from the right.  The result looks like this:
    </p>
<pre>
<code>Carol  200  London  LHR-&gt;SFO
Bob    100  London  LCY-&gt;CDG
Bob    30   Paris   ORY-&gt;HND
Alice  10   Paris   CDG-&gt;LHR
Dan    20   Tokyo   HND-&gt;LHR</code>
</pre>
  </li>
  <li> <!-- 10. sort-columns -->
    <p>
      Type <code>M-&lt;</code> to move the point to the beginning of
      the buffer.  Then type <code>C-s London RET</code> followed
      by <code>M-b</code> to move the point to the beginning of the
      word <code>London</code> on the first line.  Now
      type <code>C-SPC</code> to set a mark there.
    </p>
    <p>
      Then type <code>C-4 C-n C-e</code> to move the point to the end
      of the last line.  An active region should be visible in the
      buffer now.
    </p>
    <p>
      Finally type <code>M-x sort-columns RET</code> to sort the
      columns bounded by the column positions of mark and point (i.e.
      the last two columns).  The result looks like this:
    </p>
<pre>
<code>Bob    100  London  LCY-&gt;CDG
Carol  200  London  LHR-&gt;SFO
Alice  10   Paris   CDG-&gt;LHR
Bob    30   Paris   ORY-&gt;HND
Dan    20   Tokyo   HND-&gt;LHR</code>
</pre>
  </li>
  <li> <!-- 11. sort-columns (reverse) -->
    <p>
      Like before, type <code>M-&lt;</code> to move the point to the
      beginning of the buffer.  Then type <code>C-s London RET</code>
      followed by <code>M-b</code> to move the point to the beginning
      of the word <code>London</code> on the first line.  Now
      type <code>C-SPC</code> to set a mark there.
    </p>
    <p>
      Again, like before, type <code>C-4 C-n C-e</code> to move the
      point to the end of the last line.  An active region should be
      visible in the buffer now.
    </p>
    <p>
      Now type <code>C-u M-x sort-columns RET</code> to reverse sort
      the last two columns.
    </p>
<pre>
<code>Dan    20   Tokyo   HND-&gt;LHR
Bob    30   Paris   ORY-&gt;HND
Alice  10   Paris   CDG-&gt;LHR
Carol  200  London  LHR-&gt;SFO
Bob    100  London  LCY-&gt;CDG</code>
</pre>
  </li>
  <li> <!-- 12. sort-regexp-fields (warning) -->
    <p>
      Warning: This step shows how <em>not to</em> use
      the <code>sort-regexp-fields</code> command.  In most cases you
      probably do not want to do this.  The next point shows a typical
      usage of this command that is correct in most cases.
    </p>
    <p>
      Type <code>C-x h</code> followed by <code>M-x sort-regexp-fields
      RET [A-Z]*-&gt;\(.*\) RET \1 RET</code> to sort by the
      destination airport.  This command first matches the destination
      aiport in each line in a regular expression capturing group
      (<code>\(.*\)</code>).  Then we ask this command to sort the
      lines by the field matched by this capturing group
      (<code>\1</code>).  The result looks like this:
    </p>
<pre>
<code>Dan    20   Tokyo   LCY-&gt;CDG
Bob    30   Paris   ORY-&gt;HND
Alice  10   Paris   HND-&gt;LHR
Carol  200  London  CDG-&gt;LHR
Bob    100  London  LHR-&gt;SFO</code>
</pre>
    <p>
      Observe how all our travel records are messed up in this result.
      Now Dan from Tokyo is travelling from LCY to CDG instead of
      travelling from HND to LHR.  Compare the results in this point
      with that of the previous point.  This command has sorted the
      destination fields fine and it has maintained the association
      between the source airport and destination airport fine too.
      But the association between the other fields (first three
      columns) and the last field (source and destination airports) is
      broken.  This happened because the regular expression matches
      only the last column and we sorted by only the destination field
      of the last column, so the association of the fields in the last
      column is kept intact but the rest of the association is broken.
      Only the part of each line that is matched by the regular
      expression moves around while the sorting is performed;
      everything else remains unchanged.  This behaviour may be useful
      in some limited situations but in most cases, we want to keep
      the association between all the fields intact.  The next point
      shows how to do this.
    </p>
    <p>
      Now type <code>C-/</code> (or <code>C-x u</code>) to undo this
      change and revert the buffer to the previous good state.  After
      doing this, the buffer should look like the result presented in
      the previous point.
    </p>
  </li>
  <li> <!-- 13. sort-regexp-fields (correct) -->
    <p>
      Assuming the state of the buffer is same as that of the result
      in point 11, we will now see how to alter the previous step such
      that when we sort the lines by the destination field, entire
      lines move along with the destination fields.  The trick is to
      ensure that the regular expression matches entire lines.  To do
      so, we make a minor change in the regular expression.
      Type <code>C-x h</code> followed by <code>M-x sort-regexp-fields
      RET .*-&gt;\(.*\) RET \1 RET</code>.
    </p>
<pre>
<code>Bob    100  London  LCY-&gt;CDG
Bob    30   Paris   ORY-&gt;HND
Dan    20   Tokyo   HND-&gt;LHR
Alice  10   Paris   CDG-&gt;LHR
Carol  200  London  LHR-&gt;SFO</code>
</pre>
    <p>
      Now the lines are sorted by the destination field and Dan from
      Tokyo is travelling from HND to LHR.
    </p>
  </li>
  <li> <!-- 14. sort-regexp-fields (reverse) -->
    <p>
      Type <code>C-x h</code> followed by <code>M-- M-x
      sort-regexp-fields RET .*-&gt;\(.*\) RET \1 RET</code> to
      reverse sort the lines by the destination airport.  Note that
      the first key combination is <kbd>meta</kbd>+<kbd>-</kbd> here.
      This key combination specifies a negative argument that results
      in a reverse sort.  The result looks like this:
    </p>
<pre>
<code>Carol  200  London  LHR-&gt;SFO
Dan    20   Tokyo   HND-&gt;LHR
Alice  10   Paris   CDG-&gt;LHR
Bob    30   Paris   ORY-&gt;HND
Bob    100  London  LCY-&gt;CDG</code>
</pre>
  </li>
  <li> <!-- 15. shell-command-on-region -->
    <p>
      Finally, note that we can always invoke shell commands on a
      region and replace the region with the output of the shell
      command.  To see this in action, first prepare the buffer by
      typing <code>M-&lt;</code> followed by <code>C-k C-k C-y
      C-y</code> to duplicate the first line of the buffer.
    </p>
    <p>
      Then type <code>C-x h</code> followed by <code>C-u M-| sort -u
      RET</code> to sort the lines but remove duplicate lines during
      the sort operation.  The <code>M-|</code> key sequence invokes
      the command <code>shell-command-on-region</code> which prompts
      for a shell command, executes it and usually displays the output
      in the echo area.  If the output cannot fit in the echo area,
      then it displays the output in a separate buffer.  However, if a
      prefix argument is supplied, say with <code>C-u</code>, then it
      replaces the region with the output.  As a result, the buffer
      now looks like this:
    </p>
    <pre>
<code>Alice  10   Paris   CDG-&gt;LHR
Bob    100  London  LCY-&gt;CDG
Bob    30   Paris   ORY-&gt;HND
Carol  200  London  LHR-&gt;SFO
Dan    20   Tokyo   HND-&gt;LHR</code>
</pre>
    <p>
      This particular problem of removing duplicates while sorting can
      be also be accomplished by typing <code>C-x h</code> followed
      by <code>M-x sort-lines RET</code> and then <code>C-x h</code>
      followed by <code>M-x delete-duplicate-lines</code>.
      Nevertheless, it is useful to know that we can execute arbitrary
      shell commands on a region.
    </p>
  </li>
</ol>
<h2 id="sorting-paragraphs-and-pages">Sorting Paragraphs and Pages<a href="#sorting-paragraphs-and-pages"></a></h2>
<p>
  We have covered most of the sorting commands mentioned in the Emacs
  manual in the previous section.  Now we will switch gears and
  discuss a few more of the remaining ones.  We will no longer sort
  individual lines but paragraphs and pages instead.
</p>
<ol>
  <li> <!-- 1. Create buffer -->
    <p>
      First create a buffer with the content provided below.  Note
      that the text below contains three form feed characters.  In
      Emacs, they are displayed as <code class="hl">^L</code>.  Many
      web browsers generally do not display them.
      The <code class="hl">^L</code> symbols that we see in the text
      below have been overlayed with CSS.  But there are actual form
      feed characters next to those overlays.  If you are viewing this
      post with any decent web browser, you can copy the text below
      into your Emacs and you should be able to see the form feed
      characters in Emacs.  In case you do not, insert them yourself
      by typing <code>C-q C-l</code>.
    </p>
<pre>
<code>Emacs is an advanced, extensible, customisable,
self-documenting editor.

Emacs editing commands operate in terms of
characters, words, lines, sentences, paragraphs,
pages, expressions, comments, etc.
<span class="ctrl-l hl">&#12;</span>
We will use the term frame to mean a graphical
window or terminal screen occupied by Emacs.

At the very bottom of the frame is an echo area.
The main area of the frame, above the echo area,
is called the window.
<span class="ctrl-l hl">&#12;</span>
The cursor in the selected window shows the
location where most editing commands take effect,
which is called point.

If you are editing several files in Emacs, each in
its own buffer, each buffer has its own value of
point.
<span class="ctrl-l hl">&#12;</span></code>
</pre>
  </li>
  <li> <!-- 2. sort-pages -->
    <p>
      Our text has six paragraphs spread across three pages.  Each
      form feed character represents a page break.  Type <code>C-x
      h</code> followed by <code>M-x sort-pages RET</code> to sort the
      pages alphabetically.  Note how the second page moves to the
      bottom because it begins with the letter "W".  The buffer now
      looks like this now:
    </p>
<pre>
<code>Emacs is an advanced, extensible, customisable,
self-documenting editor.

Emacs editing commands operate in terms of
characters, words, lines, sentences, paragraphs,
pages, expressions, comments, etc.
<span class="ctrl-l hl">&#12;</span>
The cursor in the selected window shows the
location where most editing commands take effect,
which is called point.

If you are editing several files in Emacs, each in
its own buffer, each buffer has its own value of
point.
<span class="ctrl-l hl">&#12;</span>
We will use the term frame to mean a graphical
window or terminal screen occupied by Emacs.

At the very bottom of the frame is an echo area.
The main area of the frame, above the echo area,
is called the window.
<span class="ctrl-l hl">&#12;</span></code>
</pre>
  </li>
  <li> <!-- 3. sort-paragraphs -->
    <p>
      Finally, type <code>C-x h</code> followed by <code>M-x
      sort-paragraphs</code> to sort the paragraphs alphabetically.
      The buffer looks like this now:
    </p>
<pre>
<code>At the very bottom of the frame is an echo area.
The main area of the frame, above the echo area,
is called the window.

Emacs editing commands operate in terms of
characters, words, lines, sentences, paragraphs,
pages, expressions, comments, etc.
<span class="ctrl-l hl">&#12;</span>
Emacs is an advanced, extensible, customisable,
self-documenting editor.

If you are editing several files in Emacs, each in
its own buffer, each buffer has its own value of
point.
<span class="ctrl-l hl">&#12;</span>
The cursor in the selected window shows the
location where most editing commands take effect,
which is called point.

We will use the term frame to mean a graphical
window or terminal screen occupied by Emacs.
<span class="ctrl-l hl">&#12;</span></code>
</pre>
  </li>
</ol>
<h2 id="references">References<a href="#references"></a></h2>
<p>
  To read and learn more about the sorting commands described above
  refer to the following resources:
</p>
<ul>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Sorting.html">Emacs Manual: Sorting Text</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Sorting.html">Elisp Manual: Sorting Text</a></li>
</ul>
<p>
  Within Emacs, type the following commands to read these manuals:
</p>
<ul>
  <li><code>M-: (info "(emacs) Sorting") RET</code></li>
  <li><code>M-: (info "(elisp) Sorting") RET</code></li>
</ul>
<p>
  Further, the documentation strings for these commands have useful
  information too.  Use the key sequence <code>C-h f</code> to look up
  the documentation strings.  For example, type <code>C-h f
  sort-regexp-fields RET</code> to look up the documentation string
  for the <code>sort-regexp-fields</code> command.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/sorting-in-emacs.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a>
</p>
]]>
</description>
</item>
<item>
<title>From Lunar Phases to Yank-Pop</title>
<link>https://susam.net/from-lunar-phases-to-yank-pop.html</link>
<guid isPermaLink="false">lerie</guid>
<pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<h2 id="tiny-book-club">Tiny Book Club<a href="#tiny-book-club"></a></h2>
<p>
  We have a <a href="cc/mastering-emacs/">tiny book
  club</a> that meets every weekend to read and discuss the
  book <em><a href="https://www.masteringemacs.org/">Mastering
  Emacs</a></em>, 2022 edition written by Mickey Petersen.  We go
  through a few pages of the book every time we meet, do some demos
  and talk about the concepts we learn from the book.  In
  the <a href="cc/mastering-emacs/log.html#36">36 meetings</a> that we
  have had so far, we have spent approximately 26 hours together
  carefully reading every line of the book, trying out the lessons on
  an actual editor and experimenting with the new concepts.  In the
  last 3&half; months, we have completed four chapters of the book.
  We are currently reading the fifth chapter.  In this post, I'll
  share what the journey has been like so far and a few interesting
  things we have learnt.
</p>
<p>
  A big thanks to Mickey Petersen who very graciously granted me the
  permission to share his book on screen while we discuss the lessons
  from the book and try out the examples on the editor.
</p>
<p>
  This is the second series of such meetings I have been hosting.  The
  first one was about <a href="cc/iant/">analytic number
  theory</a> that began in March 2021.  It ran for seven months and
  finally <a href="final-iant-meeting.html">concluded</a> in October
  2021 after 120 meetings.  I chose Emacs as the topic for the next
  series.  The book <em>Mastering Emacs</em> by Mickey Petersen seemed
  like a great choice for it.
</p>
<p>
  Our new discussion group for Emacs began on 16 Dec 2022.  We have
  been meeting over Jitsi during the weekends.  Each meeting is
  approximately 40 minutes long.  With my desktop shared via Jitsi, I
  demonstrate all the concepts we find in the book in my Emacs editor.
  On an average, we see about 7 participants in each meeting.  Some
  participants are regulars who join the meetings every weekend,
  follow the lessons, share their comments, etc.  It has been a fun
  experience so far.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#tiny-book-club">Tiny Book Club</a></li>
  <li><a href="#variety-of-professions">Variety of Professions</a></li>
  <li><a href="#lunar-phases">Lunar Phases</a></li>
  <li><a href="#returning-to-mark">Returning to Mark</a></li>
  <li><a href="#working-with-other-windows">Working With Other Windows</a></li>
  <li><a href="#tab-bars">Tab Bars</a></li>
  <li><a href="#back-to-indentation">Back to Indentation</a></li>
  <li><a href="#exchange-point-and-mark">Exchange Point and Mark</a></li>
  <li><a href="#search-toggles">Search Toggles</a></li>
  <li><a href="#word-sequence-search">Word Search Mode</a></li>
  <li><a href="#occur-mode">Occur Mode</a></li>
  <li><a href="#imenu">Imenu</a></li>
  <li><a href="#helm">Helm</a></li>
  <li><a href="#appending-kills">Appending Kills</a></li>
  <li><a href="#yank-pop">Yank-Pop</a></li>
  <li><a href="#join-us">Join Us</a></li>
</ul>
<h2 id="variety-of-professions">Variety of Professions<a href="#variety-of-professions"></a></h2>
<p>
  Most members of our discussion group come from
  the <code>#emacs</code> channels of Libera and Matrix networks.  An
  interesting thing I noticed in our Emacs book discussion group is
  that we have a good mix of members from diverse backgrounds.  In the
  previous series of meetings on analytic number theory, almost every
  participant had a career in software engineering.  But in this
  discussion group about Emacs, we have members from various types of
  professions such as physics, molecular biology, finance, literature,
  etc.  It is interesting how we had mostly software engineers in a
  mathematics discussion group but a variety of professionals in a
  software discussion group!
</p>
<p>
  Some participants of our meetings have several years of experience
  with Emacs.  Others are beginners.  However, even those who are
  quite experienced with Emacs have found that they learnt many new
  techniques and concepts from the book.  In the next few sections,
  I'll present some of those Emacs functions that were initially not
  known to some of the experienced Emacs users of our group but were
  found to be very useful after having learnt them from the book.
</p>
<h2 id="lunar-phases">Lunar Phases<a href="#lunar-phases"></a></h2>
<p>
  Yes, we can see the lunar phases calendar right within Emacs!  I
  don't know if this was interesting to other members of our group, so
  I can only speak for myself here.  As someone who has been
  interested in astronomy <a href="dark-night-skies.html">since my
  childhood days</a>, I found this very exciting.  Type <code>M-x
  lunar-phases RET</code> in your Emacs and a new buffer appears with
  an output like this:
</p>
<pre>
<code>Tuesday, March 7, 2023: Full Moon 12:39pm (UTC)
Wednesday, March 15, 2023: Last Quarter Moon 2:14am (UTC)
Tuesday, March 21, 2023: New Moon 5:27pm (UTC)
Wednesday, March 29, 2023: First Quarter Moon 2:33am (UTC)
Thursday, April 6, 2023: Full Moon 4:33am (UTC)
Thursday, April 13, 2023: Last Quarter Moon 9:17am (UTC)
Thursday, April 20, 2023: New Moon 4:16am (UTC) ** Solar Eclipse **
Thursday, April 27, 2023: First Quarter Moon 9:21pm (UTC)
Friday, May 5, 2023: Full Moon 5:32pm (UTC) ** Lunar Eclipse **
Friday, May 12, 2023: Last Quarter Moon 2:34pm (UTC)
Friday, May 19, 2023: New Moon 3:56pm (UTC)
Saturday, May 27, 2023: First Quarter Moon 3:24pm (UTC)</code>
</pre>
<p>
  It also shows the upcoming eclipses!  In fact, there is one coming
  up this month!  Isn't this nice?  I knew that Emacs has all sorts of
  fun stuff like <code>M-x zone RET</code> to zone out with a built-in
  screensaver, <code>M-x tetris RET</code> to play a clone of the
  famous puzzle game, <code>M-: (animate-string "hello" 0) RET</code>
  to display a string in a fun manner starting off as scattered pieces
  spread randomly across the buffer that then slide and come together
  to join and form the string.  But to have something as obscure as
  lunar phases and eclipses available within the editor was a nice
  surprise!  Thanks to the book, I now use this function often.
</p>
<p>
  For people who are not familiar with Emacs notation for key binding,
  note that <code>M-x lunar-phases RET</code> means
  typing <kbd>alt</kbd>+<kbd>x</kbd> followed by
  typing <code>lunar-phases</code> and then pressing <kbd>enter</kbd>.
  The notation <code>M-</code> represents the meta modifier key which
  is mapped to <kbd>alt</kbd> on modern systems.
</p>
<h2 id="returning-to-mark">Returning to Mark<a href="#returning-to-mark"></a></h2>
<p>
  Most members knew that we can set a mark with <code>C-SPC</code>
  (i.e. <kbd>ctrl</kbd>+<kbd>space</kbd>) and then move around in the
  buffer with motion keys to highlight a region that we can cut
  with <code>C-w</code> or copy with <code>M-w</code> and paste it
  elsewhere with <code>C-y</code>.  However, what was new to some
  members is the fact that we can also return to a mark just as
  easily.  The key sequence to return to mark is <code>C-u
  C-SPC</code>.  But there is a problem.
</p>
<p>
  When we set a <em>mark</em> with <code>C-SPC</code> and start moving
  around with motion keys, the text between the mark and the current
  position of the cursor (known as <em>point</em> in Emacs) becomes a
  highlighted region in modern Emacs.  This highlighted region can be
  annoying while browsing some code.  So how do we use the mark as a
  place to return to?  Barring unusual workarounds like
  disabling <code>transient-mark-mode</code>, is there a simple way?
  Yes, there is a simple trick.  Type <code>C-SPC C-SPC</code> to set
  the mark!  Typing <code>C-SPC</code> the first time sets the mark
  and activates the region.  Typing it the second time deactivates the
  region.  But Emacs remembers the mark that was set.  Now continue
  with normal editing.  Finally, type <code>C-u C-SPC</code> to return
  to mark.
</p>
<p>
  The key sequences involved are pretty convenient.
  Typing <code>C-SPC C-SPC</code> involves holding down
  the <kbd>ctrl</kbd> key, then typing <kbd>space</kbd> twice and
  finally releasing the <kbd>ctrl</kbd> key.  Similarly,
  typing <code>C-u C-SPC</code> involves holding down
  the <kbd>ctrl</kbd> key, typing <kbd>u</kbd>, then <kbd>space</kbd>
  and then releasing the <kbd>ctrl</kbd> key.  Three keystrokes for
  each command.  They become muscle memory in no time!
</p>
<h2 id="working-with-other-windows">Working With Other Windows<a href="#working-with-other-windows"></a></h2>
<p>
  In Chapter 4, <em>The Theory of Movement</em>, there is a section
  about working with other windows.  There are a number of key
  bindings available under the prefix key <code>C-x 4</code> that
  perform operations on another window instead of the current window.
  For example, <code>C-x 4 C-f</code> opens a file in another window.
  This could be a faster alternative to splitting the current window
  with <code>C-x 2</code> or <code>C-x 3</code> and then opening a
  file with <code>C-x C-f</code>.  The single key sequence <code>C-x 4
  C-f</code> takes care of splitting the current window into two if
  another window does not exist and opening the file there.  Moreover
  if another window does exist, this key sequence just reuses that
  window to open the file there.  Pretty nifty!
</p>
<p>
  To see all the commands under the <code>C-x 4</code> prefix key,
  type <code>C-x 4 C-h</code>.  Yet another such command that I found
  quite convenient is <code>C-x 4 d</code> which opens Dired in
  another window.  This can be useful when we need to browse a
  directory without hiding the current buffer.
</p>
<h2 id="tab-bars">Tab Bars<a href="#tab-bars"></a></h2>
<p>
  One of the many features of Emacs that most of us did not bother
  paying attention to earlier was the tab bar mode.  Turns out it is
  pretty useful in managing multiple window configurations
  side-by-side.  Each tab can be used as a workspace with a specific
  arrangement of windows that suits our workflow in that workspace.
  For example, we could arrange one tab to have three windows to
  display source code, a debugger and the current directory in Dired
  mode.  Then we could have another tab with two windows beside each
  other, perhaps one to display some source code and another to run
  the terminal.
</p>
<p>
  The tab management commands are very similar to window management
  commands.  Just like <code>C-x 2</code> splits a window to create a
  new window, <code>C-x t 2</code> creates a new tab.  Just
  like <code>C-x 0</code> deletes a window, <code>C-x t 0</code>
  deletes a tab.  Similarly, <code>C-x t o</code> switches to the next
  tab.  Tabs can be renamed and moved too with some more key bindings.
  Chapter 4 has a section called <em>Tab Bar Mode</em> that introduces
  these operations in detail.
</p>
<h2 id="back-to-indentation">Back to Indentation<a href="#back-to-indentation"></a></h2>
<p>
  Almost everyone knew that <code>C-a</code> moves the cursor to the
  beginning of the current line.  But not many of us knew
  about <code>M-m</code> which invokes the
  command <code>back-to-indentation</code>.  This command moves the
  cursor to the first non-whitespace character on the current line.
  This is another new thing some of us learnt from the book.  This can
  be quite useful while editing code.
</p>
<h2 id="exchange-point-and-mark">Exchange Point and Mark<a href="#exchange-point-and-mark"></a></h2>
<p>
  Let us say we set a mark somewhere with <code>C-SPC</code> and then
  move around to select a region.  However, then we get distracted,
  possibly by some typo in our buffer and we begin fixing that.  At
  this point, the highlighted region disappears.  Say after fixing
  that typo, we want to resume with the region selection again.  What
  do we do now?  Do we go back to set the mark and begin selecting the
  region again?  Not really.  There is an easier way.  We can just
  type <code>C-x C-x</code> to exchange the point and the mark and
  highlight the region in between.  This has the effect of
  reactivating the region.
</p>
<p>
  Note that <code>C-x C-x</code> <em>exchanges</em> the point and the
  mark, so although it conveniently reactivates the region, the point
  jumps to where the mark was set earlier.  This could be quite far
  from where we want the cursor to be right now.  If you don't like
  that the cursor moves far way to the mark, just type <code>C-x
  C-x</code> once again to exchange the point and mark one more time.
  This has the effect of returning the cursor back to wherever it was
  while keeping the region activated.
</p>
<h2 id="search-toggles">Search Toggles<a href="#search-toggles"></a></h2>
<p>
  Say, we begin an incremental search of the literal
  string <code>f..</code> in the current buffer with <code>C-s
  f..</code> but then we change our mind and decide that we want to
  perform a regular-expression-based search using the regular
  expression <code>f..</code>?  Do we cancel the incremental search
  and begin a new regular-expression-based search
  using <code>C-M-s</code>?  That's not necessary.  Instead we can
  toggle the currently ongoing incremental search into a
  regular-expression-based search using the toggle key <code>M-s
  r</code>.
</p>
<p>
  Another such nice toggle is <code>M-%</code>.  You are likely aware
  of the global key binding <code>M-%</code> used to invoke
  the <code>query-replace</code> command that performs
  search-and-replace operation.  However, when typed during an ongoing
  incremental search, <code>M-%</code> converts the ongoing
  incremental search to a search-and-replace operation.  This is
  really useful sometimes.  If we are searching for a complicated
  string, say, <code>C-s std::vector&lt;int&gt;</code> but then we
  suddenly realise that we want to perform a search-and-replace
  operation instead with the same string, we don't really have to quit
  the current incremental search and start a new search-and-replace
  operation.  Instead we can simply change the current incremental
  search to a search-and-replace operation by typing <code>M-%</code>.
</p>
<p>
  Similarly, we can toggle the case-sensitivity of the search
  using <code>M-s c</code>.  If we type our search string in all
  lowercase (e.g. <code>C-s foo</code>), then Emacs performs a
  case-sensitive search by default.  I think this is a reasonable
  default behaviour.  This is what we want most of the time.  When we
  do want case-sensitive search for a lowercase string, we can switch
  from the currently ongoing case-insensitive search to a
  case-sensitive search with the <code>M-s c</code> toggle.
</p>
<p>
  The moment we introduce an uppercase character in our search string
  (e.g. <code>C-s Foo</code>), Emacs switches to case-sensitive mode.
  Although this behaviour may appear peculiar at first, it makes sense
  if you think about it.  If we have bothered to type an uppercase
  character in our search string, we probably care about the case, so
  Emacs switches to case-sensitive search in this case.  Once again,
  if this is not what we want, it is trivial to change the
  case-sensitive search to a case-insensitive one using the <code>M-s
  c</code> toggle.
</p>
<p>
 There are a number of other toggles available.  Chapter 4 has a
 pretty long subsection on incremental search.  That section discusses
 these toggles among many other things.
</p>
<h2 id="word-sequence-search">Word Search Mode<a href="#word-sequence-search"></a></h2>
<p>
  Say, we start searching for the string <code>web_server</code> in
  some code buffer with the key sequence <code>C-s web_server</code>.
  But we soon realise that the code has the words <code>web</code>
  and <code>server</code> written together in all kinds of notation
  like <code>web-&gt;server</code>, <code>web::server</code>,
  <code>web-server</code> and even <code>web server</code> (perhaps in
  inline comments).  We now decide that we want to match all of them.
  In most other editors, we'll probably have to cancel the current
  search and resort to a clever regular-expression-based search.  In
  Emacs, thanks to the toggles available in incremental search, we can
  type <code>M-s w</code> and the currently ongoing incremental search
  will change itself to word search mode where it now matches all
  these other ways those two words are written.  In word search mode,
  Emacs searches for a sequence of words while ignoring any delimiters
  in between.
</p>
<h2 id="occur-mode">Occur Mode<a href="#occur-mode"></a></h2>
<p>
  A very useful feature that has been in Emacs for a long time and yet
  was unknown to many of us is the occur mode.  Type <code>M-s o foo
  RET</code> and it will pull up all matches for the regular
  expression <code>foo</code> in the current buffer and display the
  matches in a new buffer.  Now we can stay in the same buffer where
  we have our text and jump to the places where the matches are found
  using <code>M-g M-n</code> and <code>M-g M-p</code>.
</p>
<p>
  It is also possible to convert an ongoing incremental search into an
  occur mode search using the toggle <code>M-s o</code>.  For example,
  type <code>C-s foo</code> to start an incremental search for the
  string <code>foo</code>, then type <code>M-s o</code> and, lo and
  behold, we are now in occur mode searching for the
  string <code>foo</code>.
</p>
<h2 id="imenu">Imenu<a href="#imenu"></a></h2>
<p>
  Right after the section on occur mode, the book presents a section
  about Imenu which was also new to some of us.  Type <code>M-x imenu
  RET</code> and then type <code>TAB</code> to invoke auto-completion
  and it shows a list of all interesting places in the buffer to jump
  too.  For example, if the current buffer is a Python source code
  file, then the output of this command includes all functions in the
  Python file we can jump to.  Use auto-completion to complete a
  function name and Imenu takes us to the place where the function is
  defined.
</p>
<p>
  After completing the sections on occur mode and Imenu, I remember
  multiple members of our group mentioning that they now want to adopt
  occur mode and Imenu into their workflow.  In fact, it may make
  sense to bind Imenu to a convenient key binding.  The author of the
  book recommends binding it to <code>M-i</code>.  However, I do
  use <code>M-i</code> sometimes to insert spaces until the next
  tab-stop column, so I'll suggest a different key binding that is
  more consistent with Emacs
  <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html">key binding conventions</a>.
  These conventions suggest that key bindings of the
  form <code>C-c <em>letter</em></code> are reserved for the users.
  Therefore, I suggest the key binding <code>C-c i</code> to invoke
  Imenu.  Here is some Elisp code to create this key binding:
</p>
<pre><code>(global-set-key (kbd "C-c i") 'imenu)</code></pre>
<h2 id="helm">Helm<a href="#helm"></a></h2>
<p>
  Helm is a powerful <em>filter-as-you-type</em> framework.  Most of
  us already knew about this package.  It does too many things and has
  too many key bindings.  We can barely scratch the surface in a small
  section like this.  But since we discussed Imenu in the previous
  section, I'll mention here that Helm provides a rather nice
  interface to Imenu.  Helm can be enabled with <code>M-x helm-mode
  RET</code> or with <code>(helm-mode)</code> in an Emacs
  initialisation file.  Once enabled, <code>C-x c i</code> runs
  the <code>helm-imenu</code> command which provides an interactive
  interface with all options laid out in a vertical format.  We can
  use the motion keys to select an option.  We can then
  type <kbd>enter</kbd> to activate the selection and jump to the
  corresponding place in the buffer.
</p>
<p>
  Helm also provides a nice interface for occur mode in the form
  of <code>helm-occur</code> command.  The key sequence for it
  is <code>C-x c M-s o</code>, which one might argue is not a very
  convenient key binding.  Nevertheless, the user interface to
  navigate the matches is pretty good.
</p>
<h2 id="appending-kills">Appending Kills<a href="#appending-kills"></a></h2>
<p>
  The key sequence <code>C-M-w</code> is used to ensure that if the
  next command happens to be a kill command, then the killed text is
  appended to the last stretch of text in the kill ring.  This key
  sequence prevents the next kill from creating a new entry in the
  kill ring.
</p>
<p>
  To understand what this command does we must first understand that
  after a kill command adds some new text to the kill ring, subsequent
  consecutive kills append to the same stretch of text in the kill
  ring, i.e. consecutive kills form a single large stretch of text in
  the kill ring.  This can be tested by performing consecutive kills
  and then pasting with <code>C-y</code>.  For example, <code>M-d M-d
  M-d</code> kills 3 words and creates a single stretch of text
  consisting of those 3 words.  The consecutive kills keep adding to
  the same kill entry in the kill ring.  If we type <code>C-y</code>
  now, it would yank the newest entry consisting of those 3 words from
  the kill ring and paste it into the buffer.
</p>
<p>
  However, the moment a non-kill command is used, it seals the current
  entry in the kill ring.  Any subsequent kill command creates a new
  entry in the kill ring.  For example, <code>M-d M-d M-d C-p M-d M-d
  C-p C-p C-y</code> kills 3 words at first but then it moves to the
  previous line sealing that kill entry consisting of 3 words.  Then
  it kills 2 more words and adds them to a new entry in the kill ring.
  Therefore, the final yank command pastes only those 2 words from the
  kill ring.
</p>
<p>
  This can be a problem if we want to kill text from various parts of
  the buffer and yet create a single entry in the kill ring.  That's
  when <code>C-M-w</code> comes useful.  For example, <code>M-d M-d
  M-d C-p C-M-w M-d M-d C-p C-p C-y</code> kills 3 words and creates a
  single entry in the kill ring consisting of those 3 words.  Then it
  moves one line up and kills 2 more words but this time it appends
  those 2 words to the existing entry in the kill ring.  Finally, it
  moves two lines up and pastes the entire kill entry consisting of 5
  words into the buffer.
</p>
<h2 id="yank-pop">Yank-Pop<a href="#yank-pop"></a></h2>
<p>
  Although most beginners and experienced users of Emacs know that
  killed text goes into the kill ring and we can yank the last kill
  from kill ring and paste it into the buffer using <code>C-y</code>,
  for many that's where the usage of kill ring stops.  The kill ring,
  however, has much more utility than that.  It is a <em>ring</em>,
  after all!  We can keep killing text as we edit text and all killed
  text gets added to the kill ring.  Now <code>C-y</code> always yanks
  the newest kill in the kill ring and pastes it in the buffer?  Can
  we recall an older kill?  Yes, using the <code>M-y</code> key
  sequence.  This key sequence invokes the <code>yank-pop</code>
  command that replaces a just-yanked stretch of killed text with an
  older kill.  It takes a little bit of getting used to but once this
  becomes muscle memory, the kill ring becomes a very powerful tool.
  We can keep dumping text to the kill ring and keep recalling text
  from it while performing our editing activities.  The following
  exercise shows how <code>C-y</code> and <code>M-y</code> can be used
  together.
</p>
<ol>
  <li>
    Open a new file, say, with <code>C-x C-f foo.txt RET</code> and
    type these five words in a single line: <code>foo bar baz qux
    quux</code>.
  </li>
  <li>
    Then type <code>C-a M-d C-g M-d C-g M-d</code>.  At this point
    three stretches of text have been inserted into the kill ring.
    The <code>C-g</code> between every <code>M-d</code> is there only
    to avoid appending kills to the existing stretch of text in the
    kill ring.  This ensures that we have three separate kills in the
    kill ring.
  </li>
  <li>
    Now type <code>C-y</code>.  The last kill, i.e. <code>baz</code>
    is now pasted into the buffer.
  </li>
  <li>
    Now without typing any other key sequence, type <code>M-y</code>.
    The earlier pasted text <code>baz</code> is now replaced with an
    older stretch of text from the kill ring.  Thus <code>baz</code>
    is replaced with <code>bar</code>.
  </li>
  <li>
    Now once again type <code>M-y</code>.  The earlier pasted
    text <code>bar</code> is now replaced with a further older stretch
    of text from the kill ring.  Thus <code>bar</code> is replaced
    with <code>foo</code>.
  </li>
</ol>
<p>
  Note in the previous steps how we are not supposed to type any other
  key between the first <code>C-y</code> and <code>M-y</code>.
  Similarly, while cycling through the kill ring, we must not type any
  other key between the consecutive <code>M-y</code> key sequences.
  While cycling through the kill ring, when we reach the oldest kill,
  the next <code>M-y</code> wraps around and brings back the newest
  kill.
</p>
<p>
  Since Emacs 28, the key sequence <code>M-y</code> also supports
  browsing the kill ring and yanking any arbitrary entry from the kill
  ring.  For example, after trying the above experiment,
  type <code>C-g</code> just to make sure that we are breaking any
  existing <code>C-y</code> or <code>M-y</code> cycle.  Then
  type <code>M-y</code> and a minibuffer prompt appears to yank an
  arbitrary kill from the kill ring.  If we remember the previous
  kill, we can type it out partially and type <code>TAB</code> to
  autocomplete it.  Alternatively, we could also type <code>TAB</code>
  initially itself to browse all the kills in the kill ring.
</p>
<h2 id="join-us">Join Us<a href="#join-us"></a></h2>
<p>
  That was an account of our Mastering Emacs book club discussions so
  far and a few interesting things we learnt.  We have only recently
  begun reading Chapter 5 that introduces several editing and text
  manipulation commands.  This chapter is 75 pages long and it could
  take a month or two to complete this chapter.  There are two more
  chapters after that which are shorter in their lengths.  They
  discuss some practical aspects of Emacs along with a discussion on
  some popular packages.  We still have a long way to go before we can
  complete this book.
</p>
<p>
  If all of this sounds like fun, you are very welcome to join our
  meetings.  Just head over to
  <a href="cc/mastering-emacs/">cc/mastering-emacs/</a>
  and there you'll find everything you need to know in order to be a
  part of our book discussion group and join our meetings.  Looking
  forward to seeing you in our next meeting!
</p>
<hr>
<p>
  <strong>Update on 30 Dec 2023:</strong> Our discussions of this book
  concluded on 30 Dec 2023 after 72 meetings.  See the post
  <a href="from-fill-prefix-to-tramp.html">From Fill Prefix to Tramp</a>
  for more highlights from these meetings.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/from-lunar-phases-to-yank-pop.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes on Mastering Emacs: Chapter 4: The Theory of Movement</title>
<link>https://susam.net/cc/mastering-emacs/ch04.html</link>
<guid isPermaLink="false">rqlgn</guid>
<pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The following notes were taken while discussing Chapter 4 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#basics">Basics</a></li>
  <li><a href="#major-mode-load-order">Major Mode Load Order</a>
    <ul>
      <li><a href="#file-local-variables">File-Local Variables</a></li>
    </ul>
  </li>
  <li><a href="#occur-mode">Occur Mode</a></li>
</ul>
<h2 id="basics">Basics<a href="#basics"></a></h2>
<p>
  The following complete key sequences illustrate a few basic
  commands:
</p>
<ul>
  <li>
    <code>C-x C-f foo.txt RET</code>: Edit file
    named <code>foo.txt</code>.
  </li>
  <li>
    <code>C-x C-s</code>: Save current buffer to file.
  </li>
  <li>
    <code>C-x b *scratch* RET</code>: Switch to the buffer
    named <code>*scratch*</code>.
  </li>
  <li>
    <code>C-x k *scratch* RET</code>: Kill the buffer
    named <code>*scratch*</code>.
  </li>
  <li>
    <code>C-x k RET</code>: Kill current buffer.  In fact, like the
    previous key sequence above, typing <code>C-x k</code> first
    prompts for the buffer name.  However, the current buffer name is
    selected as the default value already.  As a result,
    typing <code>RET</code> kills the current buffer.
  </li>
  <li>
    <code>C-x C-b</code>: List buffers.
  </li>
  <li>
    <code>C-x C-c</code>: Exit Emacs.  This command offers to save all
    unsaved buffers before exiting Emacs.
  </li>
  <li>
    <code>ESC ESC ESC</code>: This command exits the current context.
    What that means depends very much on the context.  It performs
    exactly one of the following actions: If there is an active
    region, then it is deactivated; if a minibuffer is open, it gets
    rid of it; if recursive edit is in progress, it quits one level of
    recursive editing; if multiple windows are open, it deletes other
    windows so that the current window becomes the only window in the
    frame.  The aforementioned conditions are tested one by one and as
    soon as one of the conditions is met, the corresponding action is
    executed and the other conditions are skipped.
  </li>
  <li>
    <code>C-/</code>: Undo changes.
  </li>
  <li>
    <code>F10</code>: Activate the menu bar.
  </li>
</ul>
<p>
  In my experience, I have found that <code>ESC ESC ESC</code> is most
  useful when a stray minibuffer is open but the cursor is on some
  other buffer instead of the minibuffer and I need to close the
  minibuffer.  Here are some steps that demonstrate this usage:
</p>
<ol>
  <li>
    <p>
      Type <code>M-x white</code> and pause.  We now have a partially
      typed command in the minibuffer.
    </p>
  </li>
  <li>
    <p>
      Now pretend that we get distracted by some imperfections in the
      text buffer that was open earlier and we want to fix those
      first.  Type <code>C-x o</code> to move away from the minibuffer
      and go back to the text buffer to perform some editing tasks.
    </p>
    <p>
      In this step, we could have typed <code>C-g</code> to quit the
      minibuffer first but we did not do that.  We pretended to get
      distracted by the text buffer and went straight to it from the
      minibuffer by typing <code>C-x o</code>.  At this point, the
      cursor is in the text buffer and the minibuffer remains open at
      the bottom.  The open minibuffer can be distracting while
      performing the text editing tasks.  Typing <code>C-g</code> now
      will not get rid of the minibuffer because the cursor is no
      longer in the minibuffer.
    </p>
  </li>
  <li>
    <p>
      Now one way to close the open minibuffer could be to
      type <code>C-x o</code> to go back to the minibuffer window and
      type <code>C-g</code>.  However, there is a more direct way to
      do this as explained in the next point.
    </p>
  </li>
  <li>
    <p>
      Type <code>ESC ESC ESC</code> to get rid of the minibuffer at
      the bottom.  This works even when the cursor is not in the
      minibuffer but is in the text buffer instead.
    </p>
  </li>
</ol>
<h2 id="major-mode-load-order">Major Mode Load Order<a href="#major-mode-load-order"></a></h2>
<p>
  The chapter mentions the following order for detecting major mode:
</p>
<ul>
  <li>File-local variables</li>
  <li>Program loader directives</li>
  <li>Magic mode detection</li>
  <li>Automatic mode detection</li>
</ul>
<p>
  Let us start from the bottom of the list and share some experimental
  results that illustrate how the major mode detection works.
</p>
<h3 id="file-local-variables">File-Local Variables<a href="#file-local-variables"></a></h3>
<ol>
  <li>
    <p>
      Create a text file named <code>foo.txt</code> with the following
      content:
    </p>
    <pre>
<code>#include &lt;iostream&gt;

int main() {
  std::cout << "hello, world\n";
  return 0;
}</code>
</pre>
    <p>
      Then open this file in Emacs (say, with <code>C-x C-f foo.txt
      RET</code>).  Emacs sets the major mode to <code>Text</code>
      (i.e. <code>text-mode</code>).
    </p>
    <p>
      Type <code>M-: major-mode RET</code> to confirm that indeed the
      value of <code>major-mode</code> is <code>text-mode</code>.
      This happens due to automatic mode detection which determines
      the major mode based on the file name.  In this case it sees
      that the file name ends with <code>.txt</code> and
      enables <code>text-mode</code>.  We will discuss automatic mode
      detection further in the
      section <a href="#automatic-mode-detection">Automatic Mode
      Detection</a>.
    </p>
  </li>
  <li>
    <p>
      Now edit the previous file to add file-local variables in the
      header as follows:
    </p>
    <pre>
<code>// -*- mode: c++; c-basic-offset: 4 -*-

#include &lt;iostream&gt;

int main() {
  std::cout << "hello, world\n";
  return 0;
}</code>
</pre>
    <p>
      Now reload the buffer.  You could simply kill the buffer
      with <code>C-x k</code> and reopen the file with <code>C-x C-f
      foo.txt RET</code> or alternatively, reload the buffer
      with <code>M-x revert-buffer RET yes RET</code>.
    </p>
    <p>
      After reloading the buffer, you should see that
      the <code>C++</code> mode (i.e. <code>c++-mode</code>) is
      enabled.  As a result, C++ syntax highlighting should be
      visible.  Further <code>C-x h TAB</code> should reformat the
      code to use 4 spaces for each level of indentation.
    </p>
  </li>
  <li>
    <p>
      File-local variables may be specified in the footer too as shown
      below:
    </p>
    <pre>
<code>#include &lt;iostream&gt;

int main() {
    std::cout << "hello, world\n";
    return 0;
}

// Local Variables:
// mode: c++
// c-basic-offset: 6
// End:</code>
</pre>
    <p>
      Now reloading the buffer should show that <code>c++-mode</code>
      is enabled and typing <code>C-x h TAB</code> should reformat the
      code to use 6 spaces for each level of indentation.
    </p>
  </li>
  <li>
    <p>
      What happens if the file-local variables in the header and
      footer contradict each other?  To test this out, edit the buffer
      to have the following content:
    </p>
    <pre>
<code>// -*- mode: c++; c-basic-offset: 4 -*-

#include &lt;iostream&gt;

int main() {
      std::cout << "hello, world\n";
      return 0;
}

// Local Variables:
// mode: python
// c-basic-offset: 6
// End:</code>
</pre>
    <p>
      Reloading the buffer should show that <code>c++-mode</code> is
      active.  Typing <code>C-x h TAB</code> should reformat the code
      to use 6 spaces for each level of indentation.  Therefore the
      mode specified in the header remains effective.  For other
      variables, the ones specified in the footer have precedence.
    </p>
    <p>
      Of course, the example above is intended for curiosity and
      exploration.  In practical use, however, it is best to avoid
      assigning conflicting values to file-local variables in both the
      header and footer.  Such inconsistencies can lead to confusion
      and make the effect of the variables difficult to understand.
    </p>
  </li>
</ol>
<h2 id="occur-mode">Occur Mode<a href="#occur-mode"></a></h2>
<p>
  TODO: More notes coming up here soon!
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/ch04.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes on Mastering Emacs: Chapter 3: First Steps</title>
<link>https://susam.net/cc/mastering-emacs/ch03.html</link>
<guid isPermaLink="false">glnrh</guid>
<pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The following notes were taken while discussing Chapter 3 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#starting-emacs">Starting Emacs</a></li>
  <li><a href="#emacs-client-server">Emacs Client-Server</a></li>
  <li><a href="#the-emacs-interface">The Emacs Interface</a></li>
  <li><a href="#keys">Keys</a></li>
  <li><a href="#terminal-limitations">Terminal Limitations</a></li>
  <li><a href="#definitions-for-key-sequences">Definitions for Key Sequences</a></li>
  <li><a href="#key-examples">Key Examples</a></li>
  <li><a href="#ctrl-g">C-g: Universal Bail Me Out</a></li>
  <li><a href="#caps-lock-as-control">Caps Lock as Control</a></li>
  <li><a href="#M-x-execute-extended-command">M-x: Execute Extended Command</a></li>
  <li><a href="#interactive-commands">Interactive Commands</a></li>
  <li><a href="#m-x-execute-extended-command-for-buffer">M-X: Execute Extended Command for Buffer</a></li>
  <li><a href="#universal-arguments">Universal Arguments</a></li>
  <li><a href="#discovering-and-remembering-keys">Discovering and Remembering Keys</a></li>
  <li><a href="#true-colour">True Colour</a></li>
  <li><a href="#the-customise-interface">The Customise Interface</a></li>
  <li><a href="#customise-commands">Customise Commands</a></li>
  <li><a href="#evaluating-elisp-code">Evaluating Elisp Code</a></li>
  <li><a href="#info">Info</a></li>
  <li><a href="#apropos">Apropos</a></li>
  <li><a href="#describe">Describe</a></li>
  <li><a href="#links">Links</a></li>
</ul>
<h2 id="starting-emacs">Starting Emacs<a href="#starting-emacs"></a></h2>
<p>
  Here are some frequently used commands to start Emacs:
</p>
<ul>
  <li>
    <code>emacs -nw</code>: Tell Emacs not to create a graphical
    frame, i.e. run Emacs within a terminal instead.
  </li>
  <li>
    <code>emacs -q</code>: Do not load an init file, i.e. do not
    load <code>~/.emacs</code>, <code>~/.emacs.d/init.el</code>, etc.
  </li>
  <li>
    <code>emacs -Q</code>: Do not load init file, site-wide startup
    file or X resources.
  </li>
</ul>
<h2 id="emacs-client-server">Emacs Client-Server<a href="#emacs-client-server"></a></h2>
<p>
  The key sequence <code>M-x server-start RET</code> turns the current
  instance of Emacs into a server.  If we kill this instance of Emacs,
  it kills the server too.
</p>
<p>
  Another way to start an Emacs server is to enter the
  command <code>emacs --daemon</code>.  This too internally
  invokes <code>server-start</code> to start an Emacs server but this
  command ensures that Emacs runs in background mode.  Therefore,
  killing any particular instance of Emacs window does not end up
  killing the Emacs server.
</p>
<p>
  To open files, say <code>foo.txt</code> and <code>bar.txt</code> in
  an already running Emacs server, enter the command <code>emacsclient
  foo.txt bar.txt</code>.  This command blocks the terminal and waits
  for us to finish editing the files.  While editing the files, we
  need to type <code>C-x #</code> to tell Emacs that we are done
  editing the current file.  Emacs then switches to the next file we
  are editing.  When we are done editing all the files
  opened, <code>emacsclient</code> quits and returns control to the
  terminal.
</p>
<p>
  The book does not mention how to stop an Emacs daemon.  One of the
  several ways to stop an Emacs daemon is the
  command <code>emacsclient -e '(kill-emacs)'</code>.
</p>
<p>
  Here are some commands to run <code>emacsclient</code>:
</p>
<ul>
  <li>
    <code>emacsclient -c</code>: Create a frame.  A graphical frame is
    created if graphics is available, otherwise a terminal frame is
    created.
  </li>
  <li>
    <code>emacsclient -nw</code>: Create a terminal frame.
  </li>
  <li>
    <code>emacsclient -n</code>: Client returns immediately without
    waiting for us to finish editing the file.
  </li>
</ul>
<h2 id="the-emacs-interface">The Emacs Interface<a href="#the-emacs-interface"></a></h2>
<p>
  The book mentions that many Emacs users disable the menu bar, tool
  bar and the splash screen.  The following Elisp code shows how these
  UI elements can be disabled:
</p>
<pre>
<code>(menu-bar-mode 0)
(when (display-graphic-p)
  (tool-bar-mode 0)
  (scroll-bar-mode 0))
(setq inhibit-startup-screen t)</code>
</pre>
<p>
  After saving the code in the initialisation file (such
  as <code>~/.emacs</code>, <code>~/.emacs.d/init.el</code>, etc.) and
  restarting Emacs, these UI elements disappear.
</p>
<p>
  It is worth mentioning here that disabling the menu bar may not be a
  good idea, especially, for beginners to Emacs.  The menu bar
  contains a lot of helpful shortcuts that could be useful to
  beginners.  Further, the menu bar often displays certain menus that
  are specific to the current buffer.  Therefore, it may be a good
  idea to leave the menu bar enabled.
</p>
<p>
  Regardless of whether the menu bar is enabled or disabled, the menu
  bar can accessed easily by typing <kbd>F10</kbd>.
</p>
<h2 id="keys">Keys<a href="#keys"></a></h2>
<p>
  The book mentions the following notation for modifier keys:
</p>
<ul>
  <li><code>C-</code>: Control</li>
  <li><code>M-</code>: Meta</li>
  <li><code>S-</code>: Shift</li>
  <li><code>s-</code>: Super</li>
  <li><code>H-</code>: Hyper</li>
  <li><code>A-</code>: Alt</li>
</ul>
<p>
  Although not mentioned in the book, here is a quick way to test out
  all of these modifier keys:
</p>
<pre>
<code>(global-set-key (kbd "C-j") (lambda () (interactive) (message "You typed C-j")))
(global-set-key (kbd "M-j") (lambda () (interactive) (message "You typed M-j")))
(global-set-key (kbd "C-S-j") (lambda () (interactive) (message "You typed C-S-j")))
(global-set-key (kbd "s-j") (lambda () (interactive) (message "You typed s-j")))
(global-set-key (kbd "H-j") (lambda () (interactive) (message "You typed H-j")))
(global-set-key (kbd "A-j") (lambda () (interactive) (message "You typed A-j")))</code>
</pre>
<p>
  Go to some buffer, say, the scratch buffer with
  <code>C-x b *scratch* RET</code>, then copy the above code to it,
  then place the cursor at the end of each line of code and
  type <code>C-x e</code> to evaluate each line.
</p>
<p>
  Then open a new buffer, say with <code>C-x b foo RET</code> and
  type <kbd>ctrl</kbd>+<kbd>j</kbd>, <kbd>alt</kbd>+<kbd>j</kbd>
  and <kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>j</kbd> to test the first
  three key bindings.
</p>
<p>
  The fourth key-binding <code>s-j</code> can usually be invoked by
  typing <kbd>command</kbd>+<kbd>j</kbd>
  or <kbd>win</kbd>+<kbd>j</kbd> depending on the type of keyboard you
  have.
</p>
<p>
  The <code>H-</code> and <code>A-</code> modifier keys are generally
  not mapped to any actual key in modern systems.  However, it is
  possible to invoke the <code>H-j</code> and <code>A-j</code> key
  bindings with the key sequences <code>C-x @ h j</code> and <code>C-x
  @ a j</code> respectively, i.e.
  <kbd>ctrl</kbd>+<kbd>x</kbd> <kbd>@</kbd> <kbd>h</kbd> <kbd>j</kbd>
  and <kbd>ctrl</kbd>+<kbd>x</kbd> <kbd>@</kbd> <kbd>a</kbd> <kbd>j</kbd>
  respectively.
</p>
<p>
  In fact, similarly, <code>s-j</code> too can be invoked
  with <code>C-x @ s j</code>, i.e.
  <kbd>ctrl</kbd>+<kbd>x</kbd> <kbd>@</kbd> <kbd>s</kbd> <kbd>j</kbd>
  but that is rarely necessary because <code>s-</code> is often bound
  to a GUI key like the <kbd>command</kbd> key on Apple keyboards and
  the <kbd>win</kbd> key on Windows keyboards.
</p>
<p>
  A practical example of a real and useful <code>s-</code> key binding
  from vanilla Emacs is <code>s-u</code> to invoke
  the <code>revert-buffer</code> command that reloads a file from the
  disk.
</p>
<h2 id="terminal-limitations">Terminal Limitations<a href="#terminal-limitations"></a></h2>
<p>
  The book mentions that there are some key bindings that we cannot
  use if we are running Emacs in the terminal.  That is because a
  terminal supports a very limited set of key bindings.  An example
  is <code>C-/</code> that invokes the <code>undo</code> command in
  GUI Emacs.  The terminal does not recognise that key sequence.
  However, the <code>undo</code> command is also bound
  to <code>C-_</code> and <code>C-x u</code>, so one of these key
  sequences can be used to undo changes in terminal Emacs.
</p>
<h2 id="definitions-for-key-sequences">Definitions for Key Sequences<a href="#definitions-for-key-sequences"></a></h2>
<p>
  The book provides a few definitions of key sequences that can be
  summarised as follows:
</p>
<ul>
  <li>
    <em>Key sequence</em> (or just <em>key</em>): A sequence of
    keyboard or mouse actions, e.g. <code>C-d</code>,
    <code>C-M-d</code>, <code>C-x C-f</code>, <code>C-x 8
    P</code>, <code>C-x</code>, <code>C-x 8</code>, etc.
  </li>
  <li>
    <em>Complete key</em>: A key sequence that invokes a command, e.g.
    <code>C-d</code>, <code>C-M-d</code>, <code>C-x
    C-f</code>, <code>C-x 8 P</code>, etc.
  </li>
  <li>
    <em>Prefix key</em>: A key sequence that is not a complete key,
    e.g. <code>C-x</code>, <code>C-x 8</code>, etc.
  </li>
</ul>
<h2 id="key-examples">Key Examples<a href="#key-examples"></a></h2>
<p>
  The section <em>Keys</em> presents the following examples of key
  sequences:
</p>
<ul>
  <li>
    <code>C-d</code>: Calls <code>delete-char</code> which deletes the
    following character.
  </li>
  <li>
    <code>C-M-d</code>: Calls <code>down-list</code> which moves
    forward down one level of parentheses.
  </li>
  <li>
    <code>C-x C-f</code>: Calls <code>find-file</code> which is used
    for editing a file.
  </li>
  <li>
    <code>C-x 8 P</code>: Insersts pilcrow, i.e. the symbol &para;,
    also known as the paragraph symbol.  Here both <code>C-x</code>
    and <code>8</code> are prefix keys.  There are many more key
    bindings available under the <code>C-x 8</code> prefix.  For
    example, <code>C-x 8 C</code> inserts the copyright symbol, i.e.
    the symbol &copy;.  A set of keys like this that belong to a
    particular prefix key is called a <em>key map</em>.
  </li>
  <li>
    <code>C-M-%</code>: Calls <code>query-replace-regexp</code> to
    replace text with regula-expression based matching.  Since the
    key <kbd>%</kbd> is normally typed
    as <kbd>shift</kbd>+<kbd>5</kbd>, this key sequence involves
    holding down 4 keys together,
    i.e. <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>shift</kbd>+<kbd>5</kbd>.
    Annoyingly, this happens to be an example of a key sequence that
    does not work in terminal Emacs due to terminal limitations.
  </li>
  <li>
    <code>TAB</code>: Calls <code>indent-for-tab-command</code> that
    either indents the current line or region or inserts a tab,
    depending on the context.
  </li>
  <li>
    <code>&lt;f1&gt;</code>, <code>&lt;f2&gt;</code>,
    ..., <code>&lt;f10&gt;</code>: Functions keys that invoke various
    functions.  Some of these are prefix keys while others are
    complete key sequence.  For example, <code>&lt;f1&gt;</code> is a
    prefix key that is available as an alternative to
    the <code>C-h</code> prefix key.  The key sequence <code>C-h
    m</code> shows help for the current major and minor modes and so
    does <code>&lt;f1&gt; m</code>.  However, <code>&lt;f10&gt;</code>
    is a complete key sequence that calls the
    command <code>menu-bar-open</code> that shows the menu bar.
  </li>
</ul>
<h2 id="ctrl-g">C-g: Universal Bail Me Out<a href="#ctrl-g"></a></h2>
<p>
  The key sequence <code>C-g</code> is used to cancel a partially
  completed command.  For example, normally, the key
  sequence <code>M-x whitespace-mode RET</code> toggles the visibility
  of whitespace in the current buffer.  However, let us say, we type
  the partial key sequence <code>M-x white</code> and then we change
  our mind about it and want to cancel entering the command any
  further, we can simply type <code>C-g</code> to
  run <code>keyboard-quit</code> that signals a quit condition and
  cancels the input.
</p>
<p>
  Similarly, say, we type <code>C-x</code> and then we change our mind
  about it and want to cancel this partially entered key sequence, we
  can simply type <code>C-g</code>.  The following message appears in
  the echo area but this is by design:
</p>
<pre><code>C-x C-g is undefined</code></pre>
<p>
  Don't let that message make you feel that you did something wrong by
  entering an undefined key sequence.  Key sequences ending
  with <code>C-g</code> have been intentionally left undefined, so
  that it can be used reliably as the universal <em>bail me out</em>
  key sequence.
</p>
<p>
  Now of course, nothing stops us from binding <code>C-x C-g</code> to
  a command of our choice.  For example, the following Elisp code
  binds it to a command that prints a message:
</p>
<pre><code>(global-set-key (kbd "C-x C-g") (lambda () (interactive) (message "You typed C-x C-g")))</code></pre>
<p>
  However, a key binding like the above one is a very bad idea because
  such a key binding flies against Emacs conventions.  If we were to
  create a key binding like the above one, we can longer rely
  on <code>C-g</code> to be our universal bail out command.  Key
  sequences ending with <code>C-g</code> are best left undefined.
</p>
<h2 id="caps-lock-as-control">Caps Lock as Control<a href="#caps-lock-as-control"></a></h2>
<p>
  The book recommends configuring our operating system to make
  the <kbd>caps lock</kbd> key behave like <kbd>ctrl</kbd>.  Many
  people do find this type of remapping very convenient.  Many
  discussions can be found online where people have claimed that this
  remapping has helped with overcoming repetitive strain injury (RSI).
  However, the
  article <a href="https://www.emacswiki.org/emacs/MovingTheCtrlKey">Moving
  the Ctrl Key</a> on Emacs Wiki claims that for some people this
  remapping <em>causes</em> RSI.
</p>
<p>
  I use the original <kbd>ctrl</kbd> keys as they come with the
  keyboard.  Most keyboards have two <kbd>ctrl</kbd> keys on either
  side of the keyboard which I find very convenient.  I touch type
  while editing text, so the two <kbd>ctrl</kbd> keys on either side
  of the keyboard turn out to be really useful.  For example, when I
  need to type <kbd>ctrl</kbd>+<kbd>a</kbd>, I can hold
  down <kbd>ctrl</kbd> with the little finger of the right hand and
  type <kbd>a</kbd> with the little finger of the left hand.
  Similarly, if I need to type <kbd>ctrl</kbd>+<kbd>p</kbd>, I can
  hold down <kbd>ctrl</kbd> with the little finger of the left hand
  and type <kbd>p</kbd> with the little finger of the right hand.
  Using the original <kbd>ctrl</kbd> keys offers this advantage of
  distributing the usage of the <kbd>ctrl</kbd> to both hands.
  However, some Apple keyboards provide only a single <kbd>ctrl</kbd>
  key on the left hand side which can be quite annoying to touch
  typists.  In such keyboards, remapping the <kbd>caps lock</kbd> key
  to behave like <kbd>ctrl</kbd> key can indeed be more convenient.
</p>
<h2 id="M-x-execute-extended-command">M-x: Execute Extended Command<a href="#M-x-execute-extended-command"></a></h2>
<p>
  The key sequence <code>M-x</code> is pronounced <em>mex</em>, <em>M
  x</em> or <em>meta x</em>.  It invokes the
  command <code>execute-extended-command</code> that brings up a
  minibuffer to read a command name and execute it.
</p>
<p>
  When <code>M-x</code> key sequences are presented in written form,
  often they may be written in a precise manner that includes
  the <code>M-x</code> key sequence, then the command name and finally
  the <code>RET</code> key in the end, e.g. <code>M-x lunar-phases
  RET</code>.  But sometimes they may also be written without
  the <code>RET</code> key, e.g. <code>M-x lunar-phases</code>.
  The <code>RET</code> key is automatically implied in the latter
  form.
</p>
<h2 id="interactive-commands">Interactive Commands<a href="#interactive-commands"></a></h2>
<p>
  The following function written in Elisp is interactive:
</p>
<pre>
<code>(defun hello ()
  (interactive)
  (message "hello"))</code>
</pre>
<p>
  However, the following function is not interactive:
</p>
<pre>
<code>(defun hola ()
  (message "hola"))</code>
</pre>
<p>
  The <code>(interactive)</code> expression declares a function as
  interactive which allows it to be called interactively
  using <code>M-x</code>.
</p>
<p>
  To see the difference between the two functions, copy both functions
  to some buffer, say, the scratch buffer and then put the cursor
  after the closing parentheses of each function and type <code>C-x
  C-e</code> to evaluate the <code>defun</code> expressions thus
  defining the functions.  After doing so, <code>M-x hello RET</code>
  executes the <code>hello</code> function and produces the "hello"
  message in the echo area.  However, typing <code>M-x hola RET</code>
  produces no match for a function named <code>hola</code>.
</p>
<h2 id="m-x-execute-extended-command-for-buffer">M-X: Execute Extended Command for Buffer<a href="#m-x-execute-extended-command-for-buffer"></a></h2>
<p>
  Emacs 28 introduces <code>M-X</code> that runs the
  command <code>execute-extended-command-for-buffer</code>.  The book
  mentions this key binding as <code>M-S-x</code> which is in
  fact <code>M-X</code>.  In these notes, we'll write <code>M-X</code>
  for consistency with how this key sequence is actually defined and
  represented in Emacs (for example, note that <code>C-h k
  M-S-x</code> shows the key as <code>M-X</code>).
</p>
<p>
  To see how this function works, first open a file,
  say, <code>foo.el</code> with <code>C-x C-f foo.el RET</code>, then
  type <code>M-x e RET</code>.  A large list of function names
  beginning with the letter "e" as choices appears.  Now
  type <code>M-X e RET</code>.  A much smaller list of choices that
  are relevant for the current Elisp buffer appears.
</p>
<h2 id="universal-arguments">Universal Arguments<a href="#universal-arguments"></a></h2>
<p>
  Universal arguments are also called <em>prefix arguments</em>.  The
  list below presents some examples of complete key sequences where we
  apply various prefix arguments to the key sequence <code>C-n</code>.
</p>
<ul>
  <li><code>C-u C-n</code>: Move cursor down 4 lines.</li>
  <li><code>C-u C-u C-n</code>: Move cursor down 16 lines.</li>
  <li><code>C-u C-u C-u C-n</code>: Move cursor down 64 lines.</li>
  <li><code>C-u 5 C-n</code>: Move cursor down 5 lines.</li>
  <li><code>C-u 15 C-n</code>: Move cursor down 15 lines.</li>
  <li><code>C-5 C-n</code>: Move cursor down 5 lines.</li>
  <li><code>C-1 C-5 C-n</code>: Move cursor down 15 lines.</li>
  <li><code>C-- C-n</code>: Move cursor up 1 line.</li>
  <li><code>C-- C-5 C-n</code>: Move cursor up 5 lines.</li>
  <li><code>C-- C-1 C-5 C-n</code>: Move cursor up 15 lines.</li>
</ul>
<p>
  Note that negative arguments (the last three examples above)
  reverses the direction of operation.  The digit arguments of the
  form <code>C-&lt;digit&gt;</code> can also be entered
  using <code>M-&lt;digit&gt;</code>
  or <code>C-M-&lt;digit&gt;</code>.  Here are some examples:
</p>
<ul>
  <li><code>M-5 C-n</code>: Move cursor down 5 lines.</li>
  <li><code>C-M-5 C-n</code>: Move cursor down 5 lines.</li>
  <li><code>M-1 M-5 C-n</code>: Move cursor down 15 lines.</li>
  <li><code>C-M-1 C-M-5 C-n</code>: Move cursor down 15 lines.</li>
  <li><code>M-- C-n</code>: Move cursor up 1 line.</li>
  <li><code>M-- M-5 C-n</code>: Move cursor up 5 lines.</li>
  <li><code>M-- M-1 M-5 C-n</code>: Move cursor up 15 lines.</li>
  <li><code>C-M-- C-n</code>: Move cursor up 1 line.</li>
  <li><code>C-M-- C-M-5 C-n</code>: Move cursor up 5 lines.</li>
  <li><code>C-M-- C-M-1 C-M-5 C-n</code>: Move cursor up 15 lines.</li>
</ul>
<p>
  While entering multiple digits in a digit argument, we can also mix
  and match modifier keys as shown below, however doing so would be
  pointless and unwieldy:
</p>
<ul>
  <li><code>C-1 M-5 C-n</code>: Move cursor down 15 lines.</li>
  <li><code>C-1 C-M-5 C-n</code>: Move cursor down 15 lines.</li>
</ul>
<p>
  The reason why Emacs supports entering digit arguments or negative
  arguments with all three modifier
  combinations <code>C-</code>, <code>M-</code>, <code>C-M-</code>, is
  so that we can choose a modifier that is convenient.  Usually, this
  would be the modifier we anticipate that we'll use next for the
  command we are prefixing with the digit or negative argument.  For
  example, if we are going to move forward by 5 words, then <code>M-5
  M-f</code> is going to be more convenient than <code>C-5 M-f</code>
  or <code>C-M-5 M-f</code>.  To type <code>M-5 M-f</code>, we can
  simply press and hold down <kbd>alt</kbd>, then type <kbd>5</kbd>
  followed by <kbd>f</kbd> and finally release <kbd>alt</kbd>.
  Similarly, if we are going to move forward by 5 expressions,
  then <code>C-M-5 C-M-f</code> is going to be more convenient than
  using any other modifier for the digit argument.
</p>
<p>
  Choosing the modifier combination for a universal argument such that
  it matches the modifier combination for the key sequence coming up
  next helps maintain good <em>tempo</em> while typing the key
  sequences.  The book often puts emphasis on the subject of tempo in
  various chapters.
</p>
<p>
  While discussing tempo, the book presents the example of <code>M--
  M-d</code> which can be used to kill the previous word.  Note
  that <code>M-d</code> kills one word forward, so <code>M--
  M-d</code> reverses the direction of the operation and kills one
  word backward.  The book notes that <code>M-- M-d</code> maintains
  tempo while <code>C-- M-d</code> which does exactly the same thing
  disrupts tempo.
</p>
<p>
  Another example that the section <em>Univeral Arguments</em> briefly
  alludes to but does not provide a concrete example of is changing
  the case of a word that we just typed.  Here are some concrete
  examples for it:
</p>
<ul>
  <li>
    <code>M-l</code>: Convert the text from the point to the end of
    the current or next word to lower case.
  </li>
  <li>
    <code>M-u</code>: Convert the text from the point to the end of
    the current or next word to upper case.
  </li>
  <li>
    <code>M-c</code>: Capitalise the text from the point to the end of
    the current or next word.  Capitalisation involves changing only
    the first letter to upper case.
  </li>
  <li>
    <code>M- M-l</code>: Convert the text from the point to the
    beginning of the current or previous word to upper case.
  </li>
  <li>
    <code>M- M-u</code>: Convert the text from the point to the
    beginning of the current or previous word to upper case.
  </li>
  <li>
    <code>M- M-c</code>: Capitalise the text from the point to the
    beginning of the current or previous word.
  </li>
</ul>
<h2 id="discovering-and-remembering-keys">Discovering and Remembering Keys<a href="#discovering-and-remembering-keys"></a></h2>
<p>
  To get help for a prefix key, type the prefix key followed
  by <code>C-h</code>.  Here are some examples:
</p>
<ul>
  <li><code>C-x C-h</code></li>
  <li><code>C-x 8 C-h</code></li>
  <li><code>C-x 8 " C-h</code></li>
  <li><code>C-x 8 ' C-h</code></li>
  <li><code>C-x 8 * C-h</code></li>
</ul>
<p>
  Getting help for a prefix key in this manner shows an automatically
  generated list of all keys that belong to the key map associated
  with the prefix key.  Note that a key map for a prefix key may
  itself contain more prefix keys.  For example, in the above
  examples, we see that the key map for <code>C-x 8</code> contains
  prefix keys <code>C-x 8 "</code>, <code>C-x 8 '</code>, etc.  Such
  nested prefix keys are clearly marked in the output as "Prefix
  Command".
</p>
<h2 id="true-colour">True Colour<a href="#true-colour"></a></h2>
<p>
  There is a note with the title <em>Supported colors</em> in the
  section <em>The Customize Interface</em> that introduces the
  following commands:
</p>
<ul>
  <li>
    <code>M-x list-color-display RET</code>: Display names of defined
    colours and show what they look like.
  </li>
  <li>
    <code>M-x info-apropos RET Colors on a TTY RET</code>: Find an
    info page on the subject of using colours on a TTY.
  </li>
</ul>
<p>
  Since Emacs 28, we can easily enable 24-bit colour in terminal Emacs
  by setting the environment variable
  <code>COLORTERM=truecolor</code>.  To quickly test it out,
  first enter the following command in the terminal:
</p>
<pre><code>COLORTERM=truecolor emacs -nw</code></pre>
<p>
  Then type the following in Emacs:
</p>
<pre><code>M-x list-color-display RET</code></pre>
<h2 id="the-customise-interface">The Customise Interface<a href="#the-customise-interface"></a></h2>
<p>
  The customise interface allows us to customise two things: faces and
  options.  Here are some steps to get started with the customise
  interface:
</p>
<ol>
  <li>
    <p>
      Type <code>C-x 2</code> to split the current window into two.
    </p>
  </li>
  <li>
    <p>
      Type <code>C-x C-f foo.el RET</code> to open a new Elisp file.
    </p>
  </li>
  <li>
    <p>
      Type some code into the file such that it contains at least one
      string, for example:
    </p>
    <pre><code>(message "hello")</code></pre>
  </li>
  <li>
    <p>
      Type <code>C-x o</code> to go to the other window.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-x customize RET</code>.
    </p>
  </li>
  <li>
    <p>
      Move the cursor to the editable text area.  This can be done
      with motion key sequences or with the mouse.
    </p>
  </li>
  <li>
    <p>
      Then type <code>font-lock-string-face</code> and
      press <kbd>enter</kbd>.  The customisation interface for the
      chosen face now appears in the buffer.  The message next to the
      "State" button shows "STANDARD." which indicates that the face
      is set to its default value.
    </p>
  </li>
  <li>
    <p>
      Then move the cursor to the editable text area next to the
      "Foreground:" label, type <code>blue</code>.  At this point, a
      preview of blue text is shown next to the "Choose" button.
      However, the string in the Elisp buffer still appears in its
      previous colour.  The message next to the "State" button shows
      "EDITED, shown value does not take effect until you set or save
      it."
    </p>
  </li>
  <li>
    <p>
      Now click the "Apply" button to apply the new string colour.
      Alternatively, move the cursor over to "Apply" and
      press <kbd>enter</kbd>.  As soon as this button is clicked, the
      string in the Elisp buffer appears blue.  The message next to
      the "State" button says "Set for current session only."
    </p>
  </li>
  <li>
    <p>
      Now click the "Revert..." button and then click
      "Revert This Session's Customizations" to revert the customisation.
    </p>
  </li>
  <li>
    <p>
      Now change the string colour to blue again and click "Apply and
      Save".  The message next to the "State" button now changes to
      "SAVED and set."  Then check Emacs initialisation file (such
      as <code>~/.emacs</code>, <code>~/.emacs.d/init.el</code>, etc.)
      and there should be a <code>custom-set-faces</code> call added
      to the initialisation file to set the string colour to blue.
    </p>
  </li>
  <li>
    <p>
      To erase the customisation from the initialisation file, click
      "Revert ..." and then click "Erase Customizations".  At this
      point, the customisation is no longer present in the
      initialisation file.  However, the customise interface shows a
      confusing message next to the "State" button, "EDITED, shown
      value does not take effect until you set or save it."  Further,
      the face is set to "-- Empty face --" in the customisation
      interface.  To add to the confusion, the "Apply and Save" button
      is enabled!  Beware though!  If "Apply and Save" is clicked now,
      it will set <code>nil</code> as the value for the face which
      will cause the face to appear black or white (not the default
      colour).
    </p>
  </li>
  <li>
    <p>
      To get rid of the confusing state of the customisation buffer
      discussed in the previous point and restore the customisation
      buffer to a sane state, click "Revert ..." and then click either
      "Undo Edits in Customization Buffer" or click
      "Revert This Session's Customizations".  Doing so would end up
      showing the default colour of the face in the customise
      interface.  The message next to the "State" button shows
      "STANDARD." again.
    </p>
  </li>
</ol>
<h2 id="customise-commands">Customise Commands<a href="#customise-commands"></a></h2>
<p>
  Here are some examples of complete key sequences that invoke various
  customise commands:
</p>
<ul>
  <li>
    <code>M-x customize RET</code>: Display customise interface.  We
    can reach a specific item to be customised by navigating the
    groups presented and the subgroups within them.  For example, to
    customise <code>font-lock-string-face</code>, we can naviage to
    Faces &gt; Font Lock &gt; Font Lock Faces &gt; Font Lock String
    Face.
  </li>
  <li>
    <code>M-x customize-browse RET</code>: Create a tree browser for
    the customise hierarchy.
  </li>
  <li>
    <code>M-x customize-option RET global-display-line-numbers
    RET</code>: Customise a specific option.
  </li>
  <li>
    <code>M-x customize-face RET font-lock-string-face RET</code>:
    Customise a specific face.
  </li>
  <li>
    <code>M-x customize-group RET faces RET</code>: Customise a
    specific group.
  </li>
  <li>
    <code>M-x customize-group RET font-lock-faces RET</code>: Another
    example similar to the previous one.  This one customises
    the <em>Font Lock Faces</em> subgroup within the <em>Faces</em>
    group.
  </li>
  <li>
    <code>M-x customize-mode RET</code>: Customise the major mode of
    the current buffer.
  </li>
  <li>
    <code>M-x customize-mode RET python-mode RET</code>: Customise a
    specific mode.  After the first <code>RET</code>, a prompt to
    enter the mode appears only if the current major mode has no known
    customise group.
  </li>
  <li>
    <code>C-u M-x customize-mode RET python-mode RET</code>: Yet
    another way to customise a specific mode.  Using the prefix
    argument ensures that we are always prompted for the mode name.
    This can be useful when we want to customise a minor mode or a
    major mode that is different from the current major mode.
  </li>
  <li>
    <code>M-x customize-themes RET</code>: Display a selectable list
    of custom themes.
  </li>
  <li>
    <code>M-x customize-customized RET</code>: Customise all
    customisations set in the session but not saved.  This is very
    useful to see all unsaved customisations together at one place.
  </li>
  <li>
    <code>M-x customize-saved RET</code>: Customise all saved
    customisations.  This is very useful to see all saved
    customisations together at one place.
  </li>
  <li>
    <code>M-x customize-changed RET</code>: Customise all settings
    whose meanings have changed since the previous major Emacs
    release.
  </li>
  <li>
    <code>M-x customize-changed RET 26.1 RET</code>: Customise all
    settings whose meanings have changed since a particular previous
    major Emacs release.
  </li>
</ul>
<p>
  One thing worth keeping in mind is that when we apply, save or
  revert customisations, only the customisations shown in the current
  buffer are applied, saved or reverted.  Here is an experiment that
  demonstrates what this means:
</p>
<ol>
  <li>
    <p>
      Type <code>C-x 2</code> followed by <code>C-x C-f foo.el
      RET</code> to split the current window into two and load an
      Elisp file in one window.  Then insert the following code:
    </p>
    <pre><code>(defun foo () (message "hello")) ;; Demo</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-x customize RET</code>, search
      for <code>font-lock-keyword-face</code>, set its colour
      to <code>red</code> and click "Apply".
    </p>
  </li>
  <li>
    <p>
      Then search for <code>font-lock-function-name-face</code>, set
      its colour to <code>green</code> and click "Apply".  At this
      point the macro name <code>defun</code> is coloured red and the
      function name <code>foo</code> is coloured green in the Elisp
      buffer.
    </p>
  </li>
  <li>
    <p>
      Now click "Revert ..." and then click
      "Revert This Session's Customizations".  Only the colour of the
      function name reverts to the default colour.  The colour of the
      macro name remains red in the Elisp buffer.  This confirms that
      the revert operation takes only the customisations in the buffer
      into account.
    </p>
  </li>
  <li>
    <p>
      Search for <code>font-lock-string-face</code>, set its colour
      to <code>blue</code> and click "Apply and Save".
    </p>
  </li>
  <li>
    <p>
      Search for <code>font-lock-comment-face</code>, set its colour
      to <code>magenta</code> and click "Apply and Save".  Inspecting
      the Emacs initialisation file shows that only the customisations
      for the string and comment faces have been saved to the file.
      This confirms that only the customisations shown in the current
      buffer are saved.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-x customize-customized RET</code>.  A new buffer
      appears and shows the customisation for keyword because it was
      customised and applied but not saved.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-x customize-saved RET</code>.  A new buffer appears
      and shows the customisations for string and comment because they
      were customised and saved.
    </p>
  </li>
  <li>
    <p>
      Now search for <code>font-lock-comment-face</code> so that the
      customise buffer contains only the customisation entry for
      comment.  Click "Revert ..." and then click
      "Erase Customizations".  Inspecting the Emacs initialisation
      file shows that the customisation for comment is removed but the
      customisation for string is still intact.  This confirms that
      only the customisation shown in the current buffer is erased.
    </p>
  </li>
</ol>
<h2 id="evaluating-elisp-code">Evaluating Elisp Code<a href="#evaluating-elisp-code"></a></h2>
<p>
  The chapter introduces two commands:
</p>
<ul>
  <li>
    <code>M-x eval-buffer RET</code>: Evaluate the entire buffer.
  </li>
  <li>
    <code>M-x eval-region RET</code>: Evaluates only the marked
    region.
  </li>
</ul>
<p>
  Here are some additional key sequences that I find very useful:
</p>
<ul>
  <li>
    <code>C-x C-e</code>: Evaluate the expression before the cursor.
    This key binding is available in <code>global-map</code>, so this
    key sequence works in any buffer.
  </li>
  <li>
    <code>C-M-x</code>: Evaluate the top-level expression on the
    cursor.  This key binding is not available in the global map.
    Therefore this key sequence works only in those major modes that
    support it.  For example, this key sequence works in Elisp buffers
    because this key binding is available
    in <code>emacs-lisp-mode-map</code>.
  </li>
</ul>
<h2 id="info">Info<a href="#info"></a></h2>
<p>
  <em>Info</em>, also known as the <em>Info Reader</em>, is the
  documentation browser of Emacs.  Type
  <code>M-x info RET</code> or <code>C-h i</code> to enter
  Info.
</p>
<p>
  The following points explain the navigation commands of Info:
</p>
<ul>
  <li>
    Type <code>[</code> or <code>]</code> to go to the previous or
    next node respectively.  Typing <code>]</code> repeatedly is a
    nice way to go from one node to the next one without skipping any
    content.  This provides an experience that very close to reading a
    book page by page although <code>SPC</code> (explained below)
    might be an even better way.
  </li>
  <li>
    Type <code>l</code> or <code>r</code> to go back or forward in
    history respectively.
  </li>
  <li>
    Type <code>n</code> or <code>p</code> to go to the previous or
    next sibling node.  This is a nice way to go from one chapter to
    next while skipping all the child nodes or to go from one section
    to the next sibling section while skipping all child subsections.
  </li>
  <li>
    Type <code>u</code> to go up one level to the parent node.
  </li>
  <li>
    Type <code>SPC</code> to scroll one screen forward at a time.
    Type <code>DEL</code> or <code>S-SPC</code> to scroll one screen
    backward at a time.  When a node boundary is reached, these
    commands automatically load the next or previous node.  Thus
    typing <code>SPC</code> over and over again is a nice way to read
    all the text in a node and then go to the next node.  This
    provides an experience that is closest to reading a book paragraph
    by paragraph and page by page.
  </li>
  <li>
    Type <code>TAB</code> to go to the next cross-reference or menu
    item, i.e. anything that looks like a link.
    Type <code>S-TAB</code> or <code>C-M-i</code> to go back to the
    previous cross-reference or menu item.
  </li>
  <li>
    Type <code>RET</code> to follow a node reference near point.  This
    behaves like visiting a link.
  </li>
  <li>
    Type <code>m</code> to prompt for a menu item to go to.  The menu
    item near the point is automatically selected as the default
    answer to the prompt.
  </li>
  <li>
    Type <code>q</code> to quit Info.  The Info buffer is not killed.
    Therefore typing <code>C-h i</code> will switch to the Info buffer
    and we can read the last node we visited again.
  </li>
</ul>
<p>
  To summarise, the commands <code>[</code> and <code>]</code> are
  great for browsing every node.  The command <code>SPC</code>
  and <code>DEL</code> are good for reading everything paragraph by
  paragraph and page by page.
</p>
<p>
  There are several ways to reach a specific node of a specific
  manual.  The following points describe some of them:
</p>
<ul>
  <li>
    When we open the Info reader with <code>C-h i</code> for the first
    time, immediately typing <code>m</code> is a convenient way to
    enter a particular menu item for a manual and jump to that manual,
    e.g. type <code>C-h i m org RET</code> to go to the Org manual.
  </li>
  <li>
    Since Emacs 28, we can also use <code>C-h R</code> to open a
    specific manual from any buffer, i.e. we do not need to
    type <code>C-h i</code> first to enter Info.  For example,
    type <code>C-h R org RET</code> to enter the Org manual.
  </li>
  <li>
    To look up the documentation for a command, type <code>C-h
    F</code>, e.g. <code>C-h F find-file RET</code>.
  </li>
  <li>
    Although not mentioned in the book, a popular way to point others
    to a specific node in the manual is to provide an Elisp expression
    to visit a node.  For example, to read the node
    named <code>Internal Links</code> in the <code>org</code> manual,
    evaluate the expression <code>(info "(org)Internal Links")</code>.
  </li>
  <li>
    An alternative to the Elisp expression in the previous point could
    be typing <code>C-h R org RET m Hyperlinks RET m Internal Links
    RET</code> or even <code>C-h R org RET m Internal Links
    RET</code>.  However, the Elisp expression in the previous point
    is a convenient way to share a pointer to a specific node in a
    specific manual with other Emacs users.
  </li>
</ul>
<h2 id="apropos">Apropos<a href="#apropos"></a></h2>
<p>
  The following key sequences demonstrate how to use the apropos
  system:
</p>
<ul>
  <li>
    <code>C-h a ^whitespace RET</code>: Find all commands that match
    the regular expression pattern <code>^whitespace</code>.
  </li>
  <li>
    <code>M-x apropos-command RET ^whitespace RET</code>: Same as
    above.
  </li>
  <li>
    <code>M-x apropos RET ^whitespace RET</code>: Show all symbols
    that match the given regular expression pattern.  The matches
    include symbols defined as functions, variables and faces.
  </li>
  <li>
    <code>C-h d cleanup-region RET</code>: Show symbols whose
    documentation strings match the given regular expression pattern.
    Note that this command shows symbols
    like <code>whitespace-cleanup</code>
    and <code>whitespace-report-region</code> in the results because
    their documentation strings contain the
    string <code>"cleanup-region"</code>.  However, it does not show
    the symbol <code>whitespace-cleanup-region</code> because its
    documentation string does not contain this string.
  </li>
  <li>
    <code>M-x apropos-documentation RET cleanup-region RET</code>:
    Same as above.
  </li>
  <li>
    <code>M-x apropos-library RET whitespace RET</code>: Show all
    variables and functions defined by the library
    <code>whitespace</code>.
  </li>
  <li>
    <code>M-x apropos-user-option RET ^whitespace RET</code>: Show
    user options that match the given pattern.  This includes
    variables that can be customised in the customise interface.
  </li>
  <li>
    <code>M-x apropos-value RET ^[^ ]*text RET</code>: Show all
    symbols which have values whose printed representation matches the
    given pattern.
  </li>
</ul>
<p>
  By default, the apropos commands show the results in alphabetical
  order.  To sort them by scores, evaluate the following Elisp
  expression:
</p>
<pre><code>(setq apropos-sort-by-scores t)</code></pre>
<p>
  To sort the matches by score as well as show the scores within
  parentheses next to the matches, evaluate the following Elisp
  expression:
</p>
<pre><code>(setq apropos-sort-by-scores 'verbose)</code></pre>
<p>
  Note that sorting by score does not work for <code>C-h d</code>
  (<code>apropos-documentation</code>).
</p>
<h2 id="describe">Describe<a href="#describe"></a></h2>
<p>
  The following key sequences demonstrate the describe system:
</p>
<ul>
  <li>
    <code>C-h m</code>: Display documentation of current major mode
    and minor modes along with key bindings introduced by the modes.
    Mode-specific commands that are not bound to any key are not
    shown.
  </li>
  <li>
    <code>C-h x calc RET</code>: Display documentation of
    the <code>calc</code> command.
  </li>
  <li>
    <code>C-h f calc RET</code>: Same as above.  However, note that
    while <code>C-h f</code> can display documentation of any
    function, <code>C-h x</code> on the other hand can display
    documentation of only those functions that are also commands.  For
    example, <code>C-h f string-join RET</code> works fine
    but <code>C-h x string-join RET</code> complains about no match.
  </li>
  <li>
    <code>C-h v tab-width RET</code>: Display documentation of the
    variable <code>tab-width</code>.
  </li>
  <li>
    <code>C-h k C-x C-f</code>: Display documentation of the command
    bound to the key sequence <code>C-x C-f</code>.
  </li>
</ul>
<h2 id="links">Links<a href="#links"></a></h2>
<p>
  The following list includes some links that were discussed during
  the book discussion group meetings:
</p>
<ul>
  <li>
    <a href="https://commons.wikimedia.org/wiki/File:Space-cadet.jpg">Picture
      of the space-cadet keyboard with Hyper, Super and Meta keys</a>
  </li>
  <li>
    <a href="https://www.emacswiki.org/emacs/MovingTheCtrlKey">Moving
    the Ctrl Key</a>
  </li>
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/ch03.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes on Mastering Emacs: Chapter 2: The Way of Emacs</title>
<link>https://susam.net/cc/mastering-emacs/ch02.html</link>
<guid isPermaLink="false">chxrj</guid>
<pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The following notes were taken while discussing Chapter 2 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#magpie-nest-of-shiny-things">Magpie's Nest of Shiny Things</a></li>
  <li><a href="#cornerstore-of-emacs">Cornerstone of Emacs</a></li>
  <li><a href="#uptime">Uptime</a></li>
  <li><a href="#rpn-calculator">RPN Calculator</a></li>
  <li><a href="#point-and-mark">Point and Mark</a></li>
  <li><a href="#returning-to-mark">Returning to Mark</a></li>
  <li><a href="#font-locking">Font Locking</a></li>
  <li><a href="#change-major-mode">Change Major Mode</a></li>
  <li><a href="#links">Links</a></li>
</ul>
<h2 id="magpie-nest-of-shiny-things">Magpie's Nest of Shiny Things<a href="#magpie-nest-of-shiny-things"></a></h2>
<p>
  The following commands mentioned in the book invoke some interesting
  functions:
</p>
<ul>
  <li>
    <code>M-x zone RET</code>: Zone out, completely; a built-in screensaver.
  </li>
  <li>
    <code>M-x dunnet RET</code>: Dungeon text adventure game.
  </li>
  <li>
    <code>M-x tetris RET</code>: Tetris clone.
  </li>
  <li>
    <code>M-x lunar-phases RET</code>: Lunar phases calendar.
  </li>
  <li>
    <code>M-x doctor RET</code>: ELIZA chatterbot.
  </li>
</ul>
<h2 id="cornerstore-of-emacs">Cornerstone of Emacs<a href="#cornerstore-of-emacs"></a></h2>
<p>
  The chapter mentions the Elisp interpreter as the cornerstone of
  Emacs.  In fact, Emacs is an editor program that runs in the Elisp
  interpreter.  When we start Emacs, what really starts first is an
  Elisp interpreter.  It executes the Elisp code of an editor program.
  When that program executes, we get Emacs, the editor!
</p>
<p>
  This behaviour is quite the opposite of how Vim and other editors
  behave.  For example, when we start Vim or Visual Studio Code, first
  the editor runs.  The editor then provides an embedded programming
  language that we can use to write plugins and extend the editor.
  For example, Vim offers VimScript to let us write code using
  VimScript and extend the functionality of Vim.  However, when we
  start Emacs, first the Elisp interpreter runs and this interpreter
  executes a program that results in Emacs, the editor.
</p>
<h2 id="uptime">Uptime<a href="#uptime"></a></h2>
<p>
  The key sequence <code>M-x emacs-uptime RET</code> shows how long
  the current instance of Emacs has been running.  Many users have
  month-long uptimes.
</p>
<h2 id="rpn-calculator">RPN Calculator<a href="#rpn-calculator"></a></h2>
<p>
  To try out the calculator, type <code>C-x * c</code> or <code>M-x
  calc RET</code> to start the calculator.  Then to calculate
  something like, say, 1 + (2 * 3), type <code>1 RET 2 RET 3 RET *
  +</code>.
</p>
<h2 id="point-and-mark">Point and Mark<a href="#point-and-mark"></a></h2>
<p>
  To try out point and mark quickly, first open a buffer with some
  text in it.  For example, open a file, say, <code>foo.txt</code>
  using the key sequence <code>C-x C-f foo.txt RET</code>.  Make sure
  there are a few lines of text in the buffer.  If it is a new buffer,
  type some lines of text into it.  Then move the point (cursor) to
  any arbitrary place within the text.  The motion keys
  like <code>C-p</code>, <code>C-n</code>, <code>C-b</code>, <code>C-f</code>,
  etc. or simply <code>&lt;up&gt;</code>, <code>&lt;down&gt;</code>,
  <code>&lt;left&gt;</code>, <code>&lt;right&gt;</code>, etc. may be
  used to do this.
</p>
<p>
  Then type <code>C-SPC</code> (i.e. <kbd>ctrl</kbd>+<kbd>space</kbd>)
  to set the mark at the current position of the point.  Then move the
  point around.  Emacs should now be highlighting the region between
  the mark (set earlier) and the point.  Then type <code>M-w</code>
  (i.e. <kbd>alt</kbd>+<kbd>w</kbd>) to copy the text in the selected
  region or type <code>C-w</code> to cut the text instead.  Finally,
  move the point around again and type <code>C-y</code> to paste the
  copied/cut text.
</p>
<h2 id="returning-to-mark">Returning to Mark<a href="#returning-to-mark"></a></h2>
<p>
  Marks can also be used to remember a position in the buffer to which
  we may wish to return to later.  To try it out, first move the point
  to some place in the buffer where a mark needs to be set.  Then
  type <code>C-SPC C-SPC</code> to set the mark without activating it
  (activating a mark causes Emacs to highlight the region as explained
  in the previous section).  Then move the point to some other place
  in the buffer.  Finally, type <code>C-u C-SPC</code> to return to
  the marked position.
</p>
<h2 id="font-locking">Font Locking<a href="#font-locking"></a></h2>
<p>
  Font locking (syntax highlighting) in Emacs is made up of faces of
  properties (colour, font, size, etc.).  Type <code>C-u C-x =</code>
  to describe the current character (the character the cursor is on).
  The output displays the face details as well.  Alternatively,
  type <code>M-x describe-face RET</code> to describe the face of the
  character the cursor is on.
</p>
<h2 id="change-major-mode">Change Major Mode<a href="#change-major-mode"></a></h2>
<p>
  Emacs almost always sets the appropriate major mode by inspecting
  the filename or the content of the buffer.  However, sometimes it
  can be useful to set the major mode manually.  For example, consider
  a file named <code>foo.html</code> which is open in Emacs and has
  the following text:
</p>
<pre>
<code>&lt;h1&gt;Euler's Identity&lt;/h1&gt;
&lt;p&gt;
  In mathematics, &lt;em&gt;Euler's identity&lt;/em&gt; is the
  equality

  \[
    e^{i \pi} + 1 = 0.
  \]

  Euler's identity is a special case of Euler's formula from complex
  analysis, which states that for any real number \( x, \)

  \[
    e^{ix} = \cos x + i \sin x.
  \]
&lt;/p&gt;</code>
</pre>
<p>
  This is an HTML file with some LaTeX snippets that would perhaps be
  rendered using a LaTeX rendering tool such as MathJax or KaTeX.  By
  default, when this file is opened in Emacs, the major mode is set to
  HTML+.  However, if one wants to focus on editing the embedded LaTeX
  content, it is possible to change the major mode to LaTeX by
  typing <code>M-x latex-mode RET</code>.  To change the major mode
  back to HTML+, type <code>M-x mhtml-mode RET</code>.
</p>
<h2 id="links">Links<a href="#links"></a></h2>
<p>
  The following list includes some links that were discussed during
  the book discussion group meetings:
</p>
<ul>
  <li>
    <a href="https://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html">Org
    as a spreadsheet system: a short introduction</a>
  </li>
  <li>
    <a href="https://orgmode.org/manual/The-Spreadsheet.html">The
    Spreadsheet (The Org Manual)</a>
  </li>
  <li>
    <a href="https://blog.polaris64.net/post/emacs-using-org-mode-to-track-exercises/">Using
    Org Mode to keep track of exercise</a>
  </li>
  <li>
    <a href="https://github.com/jkitchin/scimax">scimax: An emacs
      starterkit for scientists and engineers</a>
  </li>
  <li>
    <a href="https://www.iro.umontreal.ca/~monnier/oclosure.pdf">Open
    Closures: Disclosing lambda's inner monomaniac object!</a> by
    Stefan Monnier
  </li>
  <li>
    <a href="http://dantorop.info/project/emacs-animation/">Emacs Lisp
    Animations</a> by Dan Torop
  </li>
  <li>
    <a href="https://github.com/karthink/org-auctex">org-auctex:
      Better LaTeX previews for org-mode</a>
  </li>
  <li>
    <a href="https://emacsconf.org/2022/talks/eshell/">Top 10 reasons
    why you should be using Eshell</a> by Howard Abrams
  </li>
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/ch02.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes from Mastering Emacs Meetups</title>
<link>https://susam.net/cc/mastering-emacs/notes.html</link>
<guid isPermaLink="false">yzltf</guid>
<pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<h1>Notes from Mastering Emacs Meetups</h1>
<p>
  The following notes were taken while discussing the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  Note that these notes are not a good substitute for the actual book.
  Not everything in the book is captured in these notes.  While some
  points mentioned in the book are missing from the notes, there are
  also some points from the book where these notes discuss them in
  much greater detail than the book does.
</p>
<ul class="blog">
  <li>
    <a href="ch01.html">Notes on Mastering Emacs: Chapter 1: Introduction</a>
  </li>
  <li>
    <a href="ch02.html">Notes on Mastering Emacs: Chapter 2: The Way of Emacs</a>
  </li>
  <li>
    <a href="ch03.html">Notes on Mastering Emacs: Chapter 3: First Steps</a>
  </li>
  <li>
    <a href="ch04.html">Notes on Mastering Emacs: Chapter 4: The Theory of Movement</a>
  </li>
  <li>
    <a href="ch05.html">Notes on Mastering Emacs: Chapter 5: The Theory of Editing</a>
  </li>
  <li>
    <a href="ch06.html">Notes on Mastering Emacs: Chapter 6: The Practicals of Emacs</a>
  </li>
  <li>
    <a href="ch07.html">Notes on Mastering Emacs: Chapter 7: Conclusion</a>
  </li>
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/notes.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a>
</p>
]]>
</description>
</item>
<item>
<title>Mastering Emacs Book Club</title>
<link>https://susam.net/cc/mastering-emacs/</link>
<guid isPermaLink="false">cosiy</guid>
<pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<h1>Mastering Emacs Book Club</h1>
<div class="highlight">
  This meeting series is complete!  There are no new meetings
  happening for this book.  Go to the meetings
  <a href="../">main page</a> to find out about current
  active meetings.
</div>
<p>
  The following content on this page is an archive of the content as
  it appeared on the last day of meeting for this book.
</p>
<hr>
<div class="highlight">
  <p>
    Meeting times:
    Usually at 20:00 UTC on Fri, Sat and Sun<sup>&dagger;</sup>
  </p>
  <p>
    Meeting duration:
    40 minutes.
  </p>
  <p>
    Meeting link:
    <a href="../../meet/">susam.net/meet</a>
  </p>
  <p>
    Meeting log:
    <a href="log.html#upcoming">72 meetings</a>
  </p>
  <p>
    Reference book:
    <a href="https://www.masteringemacs.org/"><em>Mastering Emacs</em></a>
    by Mickey Petersen (2022 edition)
  </p>
  <p>
    Chapter notes:
    <a href="notes.html">Notes</a>
  </p>
  <p>
    Club channel:
    <a href="https://app.element.io/#/room/#susam:matrix.org">#susam:matrix.org</a> /
    <a href="https://web.libera.chat/#susam">#susam:libera.chat</a><sup>&ddagger;</sup>
  </p>
  <p>
    Mastodon:
    <a href="https://mastodon.social/@susam">@susam@mastodon.social</a>
  </p>
</div>
<p>
  <small>&dagger; There are some exceptions to this schedule
  occasionally.  Join
  <a href="https://app.element.io/#/room/#susam:matrix.org">#susam:matrix.org</a>
  or <a href="https://web.libera.chat/#susam">#susam:libera.chat</a>
  or follow <a href="https://mastodon.social/@susam">@susam@mastodon.social</a>
  to receive schedule updates.</small>
</p>
<p>
  <small>&ddagger; You only need to join either the Matrix channel or
  the Libera channel, not both.  Both channels are bridged together.
  If you are not an active IRC user, prefer joining the Matrix channel
  because it is more convenient for someone unfamiliar with IRC.  For
  example, you can close your browser or client and your chat session
  will still stay alive on Matrix.  You can connect back the next day
  and catch up with the messages.  Doing that with IRC requires
  slightly more work such as setting up IRC bouncers etc.</small>
</p>
<p>
  The primary reference book for these meetings is
  <em>Mastering Emacs</em> written by Mickey Petersen (2022 edition).
  PDF and EPUB copies of this book can be purchased
  from <a href="https://www.masteringemacs.org/">masteringemacs.org</a>.
</p>
<p>
  In case you miss any meeting, you can find recordings of the
  meetings that occurred in the last 7 days here:
  <a href="https://www.twitch.tv/susampal">twitch.tv/susampal</a>.
  These recordings are deleted automatically after 7 days.
</p>
<h2 id="faq">FAQ<a href="#faq"></a></h2>
<ol>
  <li>
    <h3 id="what-is-this-club-about">What is this club about?<a href="#what-is-this-club-about"></a></h3>
    <p>
      This is a hobby club with a focus on mathematics and
      computation.  This club picks reading material about concepts
      and technologies that have been around for a long time and have
      an air of timelessness around them.  See the blog
      post <a href="../../reading-classic-computation-books.html">Reading
      Classic Computation Books</a> for more details.
    </p>
  </li>
  <li>
    <h3 id="who-runs-this-club">Who runs this club?<a href="#who-runs-this-club"></a></h3>
    <p>
      My name is Susam.  This is my website.  I run this club.  I host
      the book club meetings.  The last series of book club meetings I
      hosted was about <a href="../iant/">analytic number
      theory</a>.  Some members of Libera IRC network and Hacker News
      participated in those meetings.  This new series is going to be
      about Emacs.
    </p>
  </li>
  <li>
    <h3 id="what-is-planned">What is planned for the next few meetings?<a href="#what-is-planned"></a></h3>
    <p>
      See the <a href="log.html">meeting log</a> which contains a
      rough plan for the next few meetings along with an archive of
      all previous meetings.
    </p>
  </li>
  <li>
    <h3 id="do-i-need-to-read-in-advance">Do I need to read the planned chapters/pages in advance before coming to the meetings?<a href="#do-i-need-to-read-in-advance"></a></h3>
    <p>
      Not at all.  It is up to you, really.  If you would like to read
      the chapters in advance and come, that's great.  But it is not
      necessary.  We are going to discuss every page of the book in
      detail anyway.  Further, we will demonstrate the concepts we
      learn from the book live using an actual Emacs editor.  So it is
      perfectly fine if you want to join the meetings without any
      preparation.
    </p>
  </li>
  <li>
    <h3 id="can-beginners-join">I have little to no knowledge of Emacs.  Can I join?<a href="#can-beginners-join"></a></h3>
    <p>
      Yes, certainly!  The reference book selected for these meetings
      teaches Emacs from scratch.  No prior knowledge is expected from
      the participants of these meeetings.
    </p>
  </li>
  <li>
    <h3 id="can-experts-join">I am an expert in Emacs.  Will the meetings be useful to me?<a href="#can-experts-join"></a></h3>
    <p>
      In online discussions, often people with many years of Emacs
      experience have claimed that despite their high degree of
      expertise in Emacs, the book taught them new stuff.  Whether
      attending 40-minute meetings, a few days a week, with a
      possibility of learning something new is a good return of your
      investment or not, is something you might want to consider.
    </p>
    <p>
      Having said that, expert Emacs users and developers are very
      welcome to these meetings.  In the previous meetings on analytic
      number theory, we found that the experts often contributed to
      the meetings with new insights and interesting background
      information that helped everyone learn the reading material
      better.
    </p>
  </li>
  <li>
    <h3 id="can-i-lurk">Can I just lurk in the meetings?<a href="#can-i-lurk"></a></h3>
    <p>
      Yes!  Lurking is absolutely fine in our club meetings.  In fact,
      most members of the club join in and stay silent throughout the
      meetings.  Only a few members talk via audio/video or chat.
      This is considered absolutely normal in this club, so please do
      not hesitate to join our meetings!
    </p>
  </li>
  <li>
    <h3 id="vim-or-emacs">Tell me honestly.  Which is better?  Vim or Emacs?<a href="#vim-or-emacs"></a></h3>
    <p>
      Sorry, we don't do this here!  <!-- Emacs!  Definitely Emacs!  -->
    </p>
  <li>
    <h3 id="where-can-i-ask-questions">I have more questions.  Where can I ask?<a href="#where-can-i-ask-questions"></a></h3>
    <p>
      Join the club channel
      at <a href="https://app.element.io/#/room/#susam:matrix.org">#susam:matrix.org</a>
      or <a href="https://web.libera.chat/#susam">#susam:libera.chat</a>
      to ask more questions.
    </p>
  </li>
</ol>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Notes on Mastering Emacs: Chapter 1: Introduction</title>
<link>https://susam.net/cc/mastering-emacs/ch01.html</link>
<guid isPermaLink="false">zwrnu</guid>
<pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The following notes were taken while discussing Chapter 1 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#describe-system">Describe System</a></li>
  <li><a href="#language-servers">Language Servers</a></li>
  <li><a href="#baroque-terminology">Baroque Terminology</a></li>
  <li><a href="#active-friendly-community">Active, Friendly Community</a></li>
  <li><a href="#vim-emulation-layer">Vim Emulation Layer</a></li>
  <li><a href="#links">Links</a></li>
</ul>
<h2 id="describe-system">Describe System<a href="#describe-system"></a></h2>
<p>
  To get a glimpse of the powerful describe system available in Emacs,
  type the following key sequence: <code>C-h C-k C-p</code>.  This
  shows the documentation associated with the keys
  sequence <code>C-p</code> that invokes the command
  named <code>previous-line</code> to move the cursor to the previous
  line.  The documentation mentions that this command is defined in a
  file named <code>simple.el</code>.  Click on the file name to jump
  straight into the source code of <code>simple.el</code> where this
  command is defined.  With Emacs, the source code of Emacs is not
  hidden from the user.  The describe system is discussed in Chapter 3
  of the book.
</p>
<h2 id="language-servers">Language Servers<a href="#language-servers"></a></h2>
<p>
  The two popular language server implementations for Emacs are LSP
  Mode and Eglot.  Since Emacs 29, Eglot is part of Emacs core and
  does not require installing a separate package.  It can be run with
  the key sequence <code>M-x eglot RET</code>.
</p>
<h2 id="baroque-terminology">Baroque Terminology<a href="#baroque-terminology"></a></h2>
<p>
  Some examples are:
</p>
<ul>
  <li>
    The term <em>point</em> to refer to the cursor.
  </li>
  <li>
    The term <em>yank</em> to paste text.  What can be especially
    confusing for users with prior Vim experience is that Vim uses the
    term <em>yank</em> to mean copying text but Emacs uses this term
    to mean pasting text.
  </li>
  <li>
    An OS-level or desktop-environment-level window is known
    as <em>frame</em> in Emacs.  We can split an Emacs frame into
    multiple panes and these panes are called <em>windows</em> in
    Emacs.
  </li>
</ul>
<p>
  There are many more such examples.  The above examples illustrate
  the kind of surprises one should be ready for while reading Emacs
  documentation.  Fortunately, it is often possible to understand the
  meaning of these terms from the context.
</p>
<h2 id="active-friendly-community">Active, Friendly Community<a href="#active-friendly-community"></a></h2>
<p>
  There are three good places to hang out with other Emacs users, seek
  help or help others with Emacs:
</p>
<ul>
  <li>
    Reddit <a href="https://www.reddit.com/r/emacs/">r/emacs</a>
    community.
  </li>
  <li>
    Libera <a href="https://web.libera.chat/#emacs">#emacs</a>
    channel.
  </li>
  <li>
    Matrix <a href="https://app.element.io/#/room/#emacs:matrix.org">#emacs</a>
    room.
  </li>
</ul>
<p>
  All three places appear to be quite friendly to beginners to Emacs!
</p>
<h2 id="vim-emulation-layer">Vim Emulation Layer<a href="#vim-emulation-layer"></a></h2>
<p>
  The most popular Vim emulation layer these days is Evil Mode.  It is
  often said that the best implementation of Vim is written in Emacs
  Lisp.  Some people also claim that Evil Mode is a better Vim than
  Vim itself.  In fact, the next chapter, i.e. Chapter 3, says the
  following:
</p>
<blockquote>
  Vim users are migrating to Emacs because, well, Emacs is often a
  better Vim than Vim.
</blockquote>
<h2 id="links">Links<a href="#links"></a></h2>
<p>
  The following list includes some links that were discussed during
  the book discussion group meetings:
</p>
<ul>
  <li>
    <a href="https://github.com/Wilfred/helpful">Helpful</a> is an
    alternative to the built-in Emacs help that provides much more
    contextual information.
  </li>
  <li>
    <a href="https://github.com/xuchunyang/elisp-demos">Elisp API
    Demos</a> injects Elisp demo examples in <code>*Help*</code>
    buffers.
  </li>
  <li>
    <a href="https://planet.emacslife.com/">Planet Emacslife</a> is a
    feed aggregrator for Emacs-related blogs.
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/cc/mastering-emacs/ch01.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/meetup.html">#meetup</a>
</p>
]]>
</description>
</item>
<item>
<title>Paredit Slurp and Barf Mnemonics</title>
<link>https://susam.net/paredit-slurp-and-barf-mnemonics.html</link>
<guid isPermaLink="false">bnphd</guid>
<pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  Of the several sophisticated Paredit commands to edit s-expressions,
  I believe, the following four commands are the most important ones:
</p>
<ul>
  <li><code>paredit-backward-slurp-sexp</code></li>
  <li><code>paredit-forward-slurp-sexp</code></li>
  <li><code>paredit-backward-barf-sexp</code></li>
  <li><code>paredit-forward-barf-sexp</code></li>
</ul>
<p>
  By default, these commands are bound to the key sequences
  <code>C-(</code>, <code>C-)</code>, <code>C-{</code> and
  <code>C-}</code> respectively in Emacs.  These commands can make
  editing s-expressions very convenient.  However, often on IRC
  networks and other online forums, I come across users who have
  difficulty remembering the key sequence each command is bound to.  I
  will share some mnemonics in this post that make this easier to
  remember.  Before discussing the mnemonics, let us see what these
  commands do.  However, if you already know what these commands do,
  skip right ahead to the
  <em><a href="#mnemonics">Mnemonics</a></em> section.
</p>

<h2 id="slurp-demo">Slurp Demo<a href="#slurp-demo"></a></h2>
<p>
  Say, we have the following Lisp expressions in our editor:
</p>
<pre><code>(* 10 20) (+ 30 40)<span class="cursor"> </span></code></pre>
<p>
  The block above shows where the cursor is placed.  Let us now bring
  the expression <code>(+ 30 40)</code> inside the expression <code>(*
  10 20)</code>.  To do so, we first place the cursor somewhere inside
  the first expression, say, as shown below:
</p>
<pre><code>(* 10 20<span class="cursor">)</span> (+ 30 40)</code></pre>
<p>
  Now type <code>C-)</code> and the closing parenthesis of the first
  expression moves forward to <em>slurp</em> the next expression.  The
  result looks like this:
</p>
<pre><code>(* 10 20<span class="cursor"> </span>(+ 30 40))</code></pre>
<p>
  The key sequence <code>C-)</code> invokes the
  <code>paredit-forward-slurp-sexp</code> command that adds the
  expression following the current list into that list by moving the
  closing delimiter ahead.  Similarly, there is the key sequence
  <code>C-(</code> that invokes the
  <code>paredit-backward-slurp-sexp</code> command which works
  similarly except that it makes the current list consume the
  preceding expression.  Note that the slurp commands expand the
  current list to consume a neighbouring expression.
</p>

<h2 id="barf-demo">Barf Demo<a href="#barf-demo"></a></h2>
<p>
  Say, we have the following Lisp expression in our editor:
</p>
<pre><code>(* 10 20 (+ 30 40))<span class="cursor"> </span></code></pre>
<p>
  We now want to move <code>(+ 30 40)</code> out of the first
  expression.  To do so, we first place the cursor somewhere inside
  the outer expression but not inside the inner expression.  Here is
  an example of where we place the cursor:
</p>
<pre><code>(* 10 20 <span class="cursor">(</span>+ 30 40))</code></pre>
<p>
  Now type <code>C-}</code> and the closing parenthesis of the outer
  expression moves behind to <em>barf</em> the inner expression out.
  The result looks like this:
</p>
<pre><code>(* 10 20) <span class="cursor">(</span>+ 30 40)</code></pre>
<p>
  The key sequence <code>C-}</code> invokes the
  <code>paredit-forward-barf-sexp</code> command that removes the
  last expression in the current list from that list by moving the
  closing delimiter behind.  Similarly, there is the key sequence
  <code>C-{</code> that invokes the
  <code>paredit-backward-barf-sexp</code> command which works
  similarly except that it removes the first expression from the
  current list.  Note that the barf commands shrinks the current list
  to remove an expression from that list.
</p>

<h2 id="mnemonics">Mnemonics<a href="#mnemonics"></a></h2>
<p>
  When I began using Paredit for the first time, several years ago, I
  could never remember which key sequences <em>slurp</em> and which
  ones <em>barf</em>.  Then I made up these mnemonics:
</p>
<ul>
  <li>
    <code>C-(</code> and <code>C-)</code> have parentheses that look
    nice and round.  They expand the current list to consume another
    expression.  Nom nom!
  </li>
  <li>
    <code>C-{</code> and <code>C-}</code> have braces that look
    squiggly and wiggly.  They shrink the current list and barf an
    expression.
  </li>
</ul>
<p>
  I do not need these mnemonics anymore because after using these key
  sequences a few times, they get burnt into our muscle memory.
  However, in the initial days of using Paredit, these mnemonics were
  quite useful.  Now whenever I find someone complaining about how
  easy it is to forget the key sequences bound to these commands, I
  share these mnemonics with them and they never have any problem
  again with the slurp and barf commands.  These mnemonics have served
  me and many others I know quite well.
</p>
<hr>
<p>
  <em>
    <strong>Update on 01 Mar 2022:</strong> Jon Snader, who maintains
    a very popular blog named
    <a href="http://irreal.org/blog/">Irreal</a>, has discussed this
    blog post on his own blog.  While he did not find my mnemonics
    particularly helpful, he has shared his own way of remembering the
    key sequences.  Quoting Jon below:
  </em>
</p>
<blockquote>
  <em>
    To me, the braces suggest pointing out
    so <kbd>Ctrl</kbd>+<kbd>}</kbd> and <kbd>Ctrl</kbd>+<kbd>{</kbd>
    are clearly for barfing.
  </em>
</blockquote>
<p>
  <em>
    That is quite an interesting and elegant mnemonic.  See his
    post <a href="https://irreal.org/blog/?p=10361">Using Paredit's
    Slurp and Barf</a> to read his complete views on this topic.
  </em>
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/paredit-slurp-and-barf-mnemonics.html">Read on website</a> |
  <a href="https://susam.net/tag/emacs.html">#emacs</a> |
  <a href="https://susam.net/tag/lisp.html">#lisp</a> |
  <a href="https://susam.net/tag/programming.html">#programming</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a>
</p>
]]>
</description>
</item>


</channel>
</rss>
