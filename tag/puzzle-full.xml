<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="../feed.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
<title>Susam's Puzzle Pages</title>
<link>https://susam.net/tag/puzzle.html</link>
<atom:link rel="self" type="application/rss+xml" href="https://susam.net/tag/puzzle-full.xml"/>
<description>Feed for Susam's Puzzle Pages</description>

<item>
<title>Mutually Attacking Knights</title>
<link>https://susam.net/mutually-attacking-knights.html</link>
<guid isPermaLink="false">makcf</guid>
<pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  How many different ways can we place two identical knights on an \(
  n \times n \) chessboard so that they attack each other?  Can we
  find a closed-form expression that gives this number?  This is the
  problem we explore in this article.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#counting-placements-as-the-board-grows">Counting Placements as the Board Grows</a>
    <ul>
      <li><a href="#type-a-squares">Type A Squares</a></li>
      <li><a href="#type-b-squares">Type B Squares</a></li>
      <li><a href="#type-c-squares">Type C Squares</a></li>
      <li><a href="#type-d-squares">Type D Squares</a></li>
      <li><a href="#closed-form-expression-1">Closed Form Expression</a></li>
    </ul>
  </li>
  <li><a href="#counting-placements-for-each-square">Counting Placements for Each Square</a>
    <ul>
      <li><a href="#attacking-degrees-of-squares">Attacking Degrees of Squares</a></li>
      <li><a href="#from-attacking-degrees-to-counting-placements">From Attacking Degrees to Counting Placements</a></li>
      <li><a href="#closed-form-expression-2">Closed Form Expression</a></li>
    </ul>
  </li>
  <li><a href="#counting-placements-from-minimal-attack-sections">Counting Placements From Minimal Attack Sections</a>
    <ul>
      <li><a href="#minimal-attack-sections">Minimal Attack Sections</a></li>
      <li><a href="#closed-form-expression-3">Closed Form Expression</a></li>
    </ul>
  </li>
  <li><a href="#reference">References</a></li>
</ul>
<h2 id="introduction">Introduction<a href="#introduction"></a></h2>
<p>
  A knight moves two squares in one direction, then one square
  perpendicular to it, forming an L-shaped path.  If a piece occupies
  the destination square, the knight captures it.  If two knights are
  placed such that each can capture the other in a single move, then
  we say the knights attack each other.  We want to determine the
  number of ways to place two identical knights on an \( n \times n \)
  chessboard so that they attack each other.
</p>
<figure>
  <table class="chess odd">
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td class="black knight"></td>
      <td></td>
    </tr>
  </table>
  <figcaption>
    Two knights attacking each other
  </figcaption>
</figure>
<p>
  The above illustration shows just one of several ways two knights
  can attack each other on a \( 3 \times 3 \) board.  There are, in
  fact, a total of eight such placements, shown below.
</p>
<figure style="text-align: center">
  <!-- 1 -->
  <table class="chess odd inline">
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td class="black knight"></td>
      <td></td>
    </tr>
  </table>
  <!-- 2 -->
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td class="black knight"></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <!-- 3 -->
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td class="black knight"></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
  </table>
  <!-- 4 -->
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td class="black knight"></td>
      <td></td>
    </tr>
  </table>
  <!-- 5 -->
  <table class="chess odd inline">
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <!-- 6 -->
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <!-- 7 -->
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
  </table>
  <!-- 8 -->
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <figcaption>
    All \( 8 \) ways two identical knights can attack each other on a
    \( 3 \times 3 \) board.
  </figcaption>
</figure>
<p>
  Let \( f(n) \) denote the number of ways we can place two identical
  knights on an \( n \times n \) chessboard such that they attack each
  other, where \( n \ge 1.  \)
</p>
<p>
  A \( 1 \times 1 \) board has room for only one knight, so we define
  \( f(1) = 0.  \)  On a \( 2 \times 2 \) board, a knight cannot move
  two squares in any direction and therefore cannot attack.
  Therefore, \( f(2) = 0.  \)  To summarise,

  \[
    f(1) = f(2) = 0.
  \]

  From the illustration above, we see that \( f(3) = 8.  \)  We want to
  find a closed-form expression for \( f(n).  \)
</p>
<p>
  We will analyse this problem from various perspectives.  We begin
  with a couple of needlessly complicated approaches, followed by a
  simple and elegant solution.  While I personally enjoy these
  long-winded explorations, if you prefer a more direct solution,
  please skip ahead
  to <a href="#counting-placements-from-minimal-attack-sections">Counting
  Placements From Minimal Attack Sections</a>.
</p>
<p>
  Before we proceed, let us introduce the term <em>mutually attacking
  knight placement</em> to mean a placement of two knights on the
  chessboard such that they attack each other.  Unless stated
  otherwise, the two knights are identical.  This term will serve as a
  convenient shorthand for referring to such placements.
</p>
<h2 id="counting-placements-as-the-board-grows">Counting Placements as the Board Grows<a href="#counting-placements-as-the-board-grows"></a></h2>
<p>
  We now turn to the needlessly complicated solution promised in the
  previous section.  We analyse the <em>new</em> mutually attacking
  knight placements introduced when an existing board is enlarged by
  adding a row and a column.
</p>
<p>
  Let us define

  \[
    \Delta f(n) = f(n) - f(n - 1)
  \]

  for \( n \ge 2, \) so that \( \Delta f(n) \) denotes the new
  mutually attacking knight placements introduced when an \( (n - 1)
  \times (n - 1) \) board is expanded to size \( n \times n \) by
  adding one row and one column.
</p>
<p>
  For brevity, we will avoid restating the process of enlarging an \(
  (n - 1) \times (n - 1) \) board to an \( n \times n \) board by
  adding one row and one column whenever we refer to new placements.
  Instead, we use the term <em>new placements</em> on an
  \( n \times n \) board to refer to \( \Delta f(n).  \)  It is to be
  understood that these new placements are the mutually attacking
  knight placements introduced by enlarging the board from size \( (n
  - 1) \times (n - 1) \) to \( n \times n.  \)
</p>
<p>
  Without loss of generality, suppose the new row and column are added
  to the bottom and right respectively.  We already know that

  \begin{align*}
    \Delta f(2) &amp; = f(2) - f(1) = 0 - 0 = 0, \\
    \Delta f(3) &amp; = f(3) - f(2) = 8 - 0 = 8.  \\
  \end{align*}

  We will now find \( \Delta f(n) \) for \( n \ge 4.  \)  To do this,
  we first categorise the newly added squares due to board expansion,
  into four types, as illustrated below.
</p>
<figure>
  <table class="chess">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">A</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">B</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">C</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">C</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">D</td>
    </tr>
    <tr>
      <td class="em">A</td>
      <td class="em">B</td>
      <td class="em">C</td>
      <td class="em">C</td>
      <td class="em">D</td>
      <td class="em">A</td>
    </tr>
  </table>
  <figcaption>
    New squares, labelled by type, as the board size increases from \(
    5 \times 5 \) to \( 6 \times 6 \)
  </figcaption>
</figure>
<p>
  Here is a brief description of each square type:
</p>
<ul>
  <li>
    Type A squares are the three new corner squares.
  </li>
  <li>
    Type B squares are the two new squares adjacent to type A squares
    at the top and left edges.
  </li>
  <li>
    Type C squares are the new squares that are <em>not</em> adjacent
    to any type A square.  If the new board has dimensions \( n \times
    n, \) where \( n \ge 4, \) then there are exactly \( 2n - 8 \)
    squares of type C.
  </li>
  <li>
    Type D squares are the two new squares adjacent to the
    bottom-right type A square.
  </li>
</ul>
<p>
  We now calculate how many new mutually attacking knight placements
  are introduced by these additional squares as the board expands.  We
  proceed with a case-by-case analysis for each square type.
</p>
<h3 id="type-a-squares">Type A Squares<a href="#type-a-squares"></a></h3>
<p>
  There are three squares of type A.  If we place one knight on a type
  A square, there are two positions for the second knight such that
  the two knights attack each other.
</p>
<figure>
  <table class="chess odd">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td class="black knight em"></td>
      <td class="em"></td>
      <td class="em"></td>
      <td class="em"></td>
      <td class="black knight em"></td>
    </tr>
  </table>
  <figcaption>
    Knights on type A squares, with squares attacked by the top knight
    marked with crosses
  </figcaption>
</figure>
<p>
  Since there are three such squares, we get a total of \( 3 \times 2
  = 6 \) new mutually attacking knight placements.
</p>
<h3 id="type-b-squares">Type B Squares<a href="#type-b-squares"></a></h3>
<p>
  There are two squares of type B.  If we place one knight on a type B
  square, there are three positions for the second knight such that
  the two knights attack each other.
</p>
<figure>
  <table class="chess odd">
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td class="em"></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="black knight em"></td>
      <td class="em"></td>
      <td class="em"></td>
      <td class="em"></td>
    </tr>
  </table>
  <figcaption>
    Knights on type B squares, with squares attacked by the top knight
    marked with crosses
  </figcaption>
</figure>
<p>
  Since there are two such squares, we get a total of \( 2 \times 3 =
  6 \) new mutually attacking knight placements.
</p>
<h3 id="type-c-squares">Type C Squares<a href="#type-c-squares"></a></h3>
<p>
  The number of type C squares depends on the board size.  When we
  increase the size of a board from \( (n - 1) \times (n - 1) \) to
  \(n \times n, \) where \( n \ge 4, \) we add \( n^2 - (n - 1)^2 = 2n
  - 1 \) new squares.  Among these, \( 3 \) are of type A, \( 2 \) are
  of type B and \( 2 \) are of type D.  That gives us a total of \(
  7 \) squares of type A, B or D.  The remaining \( 2n - 1 - 7 = 2n -
  8 \) squares are therefore of type C.  Note that when the board size
  increases from \( 3 \times 3 \) to \( 4 \times 4, \) there are \( 2
  \times 4 - 8 = 0 \) squares of type C.
</p>
<figure>
  <table class="chess">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">A</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">B</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">D</td>
    </tr>
    <tr>
      <td class="em">A</td>
      <td class="em">B</td>
      <td class="em">D</td>
      <td class="em">A</td>
    </tr>
  </table>
  <figcaption>
    A \( 4 \times 4 \) board has no type C squares.
  </figcaption>
</figure>
<p>
  However, for a board of size \( 5 \times 5 \) or greater, there is a
  positive number of type C squares since \( 2n - 8 \gt 0 \) if and
  only if \( n \gt 4.  \)
</p>
<figure>
  <table class="chess">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">A</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">B</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">C</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em">D</td>
    </tr>
    <tr>
      <td class="em">A</td>
      <td class="em">B</td>
      <td class="em">C</td>
      <td class="em">D</td>
      <td class="em">A</td>
    </tr>
  </table>
  <figcaption>
    A \( 5 \times 5 \) board has one type C square.
  </figcaption>
</figure>
<p>
  If we place one knight on a type C square, there are four positions
  for the second knight such that the two knights attack each other.
</p>
<figure>
  <table class="chess odd">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="em"></td>
      <td class="black knight em"></td>
      <td class="em">&cross;</td>
      <td class="em"></td>
    </tr>
  </table>
  <figcaption>
    Knights on type C squares, with squares attacked by the top knight
    marked with crosses
  </figcaption>
</figure>
<p>
  Since there are \( 2n - 8 \) such squares, we get a total of \( 4(2n
  - 8) = 8(n - 4) \) new mutually attacking knight placements.
</p>
<h3 id="type-d-squares">Type D Squares<a href="#type-d-squares"></a></h3>
<p>
  There are two squares of type D.  As with type B squares, placing
  one knight on a type D square yields three positions for the second
  knight such that the two knights attack each other.  This gives \( 2
  \times 3 = 6 \) <em>potentially</em> new placements.
</p>
<figure>
  <table class="chess odd">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="em"></td>
      <td class="em">&cross;</td>
      <td class="black knight em"></td>
      <td class="em"></td>
    </tr>
  </table>
  <figcaption>
    Knights on type D squares, with squares attacked by the top knight
    marked with crosses
  </figcaption>
</figure>
<p>
  However, unlike type B squares, not all of these placements are
  <em>new</em>.  The two placements where one knight is on the right
  edge and the other on the bottom edge were already counted in a
  previous subsection.
</p>
<figure>
  <table class="chess inline">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="black knight em"></td>
      <td class="em"></td>
      <td class="em"></td>
    </tr>
  </table>
  <table class="chess inline">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="em"></td>
      <td class="black knight em"></td>
      <td class="em"></td>
    </tr>
  </table>
  <figcaption>
    Placements already counted while analysing placements involving a
    knight on a type B square of the \( 4 \times 4 \) board
  </figcaption>
</figure>
<p>
  For example, when we increase the board size from \( 3 \times 3 \)
  to \( 4 \times 4, \) both the placements described in the previous
  paragraph appear while analysing the placements with a knight on a
  type B square.  More generally, for any board of size
  \( n \times n \) with \( n \ge 5, \) these placements occur while
  analysing the placements with a knight on a type C square.
  Therefore the total number of new mutually attacking knight
  placements is \( 2 \times 3 - 2 = 4.  \)
</p>
<figure>
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="em"></td>
      <td class="black knight em"></td>
      <td class="em"></td>
      <td class="em"></td>
    </tr>
  </table>
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="em"></td>
      <td class="em"></td>
      <td class="black knight em"></td>
      <td class="em"></td>
    </tr>
  </table>
  <figcaption>
    Placements already counted while analysing placements involving a
    knight on a type C square of an \( n \times n \) board, where \( n
    \ge 5 \)
  </figcaption>
</figure>
<p>
  Another way to describe this result is to observe that when one
  knight is placed on a type D square, only two positions for the
  second knight yield <em>new</em> mutually attacking knight
  placements.  Since there are two type \( D \) squares, we get a
  total of \( 2 \times 2 = 4 \) new mutually attacking knight
  placements.
</p>
<figure>
  <table class="chess odd">
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td class="em"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="black knight em"></td>
    </tr>
    <tr>
      <td class="em"></td>
      <td class="em"></td>
      <td class="em"></td>
      <td class="black knight em"></td>
      <td class="em"></td>
    </tr>
  </table>
  <figcaption>
    Knights on type D squares, with squares attacked by the top knight
    that yield <em>new</em> mutually attacking knight placements
    marked with crosses
  </figcaption>
</figure>
<h3 id="closed-form-expression-1">Closed Form Expression<a href="#closed-form-expression-1"></a></h3>
<p>
  If we add the number of new mutually attacking knight placements
  found in each of the cases above, we get

  \[
    \Delta f(n) = 6 + 6 + 8(n - 4) + 4 = 8(n - 2)
  \]

  new mutually attacking knight placements as the board size increases
  from \( (n - 1) \times (n - 1) \) to \( n \times n, \) where \( n
  \ge 4.  \)  We already know that \( \Delta f(2) = 0 \) and \( \Delta
  f(3) = 8.  \)  Surprisingly, the above formula produces the correct
  values for those cases as well.  Therefore, we can generalise this
  result as

  \[
    \Delta f(n) = 8(n - 2)
  \]

  for all \( n \ge 2.  \)  We can now calculate \( f(n) \) for \( n \ge
  1 \) as follows:

  \begin{align*}
    f(n)
    &amp; = \sum_{k = 1}^n f(k) - \sum_{k = 1}^{n - 1} f(k) \\
    &amp; = \sum_{k = 1}^n f(k) - \sum_{k = 2}^n f(k - 1) \\
    &amp; = f(1) + \sum_{k = 2}^n (f(k) - f(k - 1)) \\
    &amp; = f(1) + \sum_{k = 2}^n \Delta f(k) \\
    &amp; = 0 + \sum_{k = 2}^n 8(k - 2) \\
    &amp; = 8 \sum_{k = 0}^{n - 2} k \\
    &amp; = \frac{8(n - 2)(n - 1)}{2} \\
    &amp; = 4(n - 1)(n - 2).
  \end{align*}

  To summarise, we now have a closed form expression for \( f(n).  \)
  For all \( n \ge 1, \) we have

  \[
    f(n) = 4(n - 1)(n - 2).
  \]
</p>
<h2 id="counting-placements-for-each-square">Counting Placements for Each Square<a href="#counting-placements-for-each-square"></a></h2>
<p>
  The previous section took a long-winded path to arrive at a closed
  form expression for \( f(n).  \)  In this section, we will reach the
  same result that is still a bit drawn out, but not quite as much as
  before.
</p>
<p>
  This time, instead of looking only at the new squares created when
  the board grows, we consider <em>every</em> square on the board.  To
  make the counting easier, we no longer treat the knights as
  identical.  We first work with two distinct knights, count the
  mutually attacking knight placements and then divide the total by \(
  2 \) to get the result for identical knights.
</p>
<h3 id="attacking-degrees-of-squares">Attacking Degrees of Squares<a href="#attacking-degrees-of-squares"></a></h3>
<p>
  Here, we introduce the term <em>attacking degree of a square</em> to
  mean the number of squares a knight can move to from that square in
  a single move.  In other words, the attacking degree of a square is
  the number of squares that would be attacked if a knight were placed
  on it.  For example, the corner squares have an attacking degree of
  \( 2.  \)
</p>
<figure>
  <table class="chess">
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>&cross;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&cross;</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <figcaption>
    The attacking degree of a corner square is \( 2 \) since a knight
    can attack two squares from it
  </figcaption>
</figure>
<p>
  Let us now label each square with its attacking degree.  A \( 1
  \times 1 \) board has only one square of attacking degree \( 0 \)
  since a knight placed on it has nothing to attack.  Similarly, each
  square of a \( 2 \times 2 \) board has attacking degree \( 0 \) too.
</p>
<figure>
  <table class="chess odd inline">
    <tr>
      <td>0</td>
    </tr>
  </table>
  <table class="chess inline">
    <tr>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
    </tr>
  </table>
  <figcaption>
    Attacking degrees of all squares are zero on \( 1 \times 1 \) and
    \( 2 \times 2 \) boards
  </figcaption>
</figure>
<p>
  On a \( 3 \times 3 \) board, all squares have attacking degree
  \( 2 \) except the centre square, whose attacking degree is \( 0.  \)
  In other words, placing a knight on any square other than the middle
  one gives exactly two possible positions for the other knight so
  that they attack each other.
</p>
<figure>
  <table class="chess odd">
    <tr>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
  </table>
  <figcaption>
    Attacking degrees of all squares on a \( 3 \times 3 \) board
  </figcaption>
</figure>
<p>
  With eight such squares, we get \( 8 \times 2 = 16 \) mutually
  attacking knight placements when the two knights are distinct.  If
  we divide this number by \( 2, \) we get \( 8 \) which is indeed the
  number of mutually attacking knight placements on a \( 3 \times 3 \)
  board when the two knights are identical.  This matches the earlier
  result \( f(3) = 8.  \)
</p>
<h3 id="from-attacking-degrees-to-counting-placements">From Attacking Degrees to Counting Placements<a href="#from-attacking-degrees-to-counting-placements"></a></h3>
<p>
  Let \( g(n) \) be the number of mutually attacking knight placements
  on an \( n \times n \) board when the knights are distinct.  Then \(
  g(n) \) is simply the sum of the attacking degrees of all squares on
  the board.  As before, let \( f(n) \) denote the number of mutually
  attacking knight placements on an \( n \times n \) board when the
  two knights are identical.  We will now show that
  \( f(n) = g(n)/2.  \)
</p>
<p>
  Label all squares of the \( n \times n \) board as \( S_1, S_2,
  \dots, S_{n^2} \) in any fixed order.  Label the two distinct
  knights as \( N_1 \) and \( N_2.  \)  We represent each mutually
  attacking knight placement as an ordered pair \( (S_i, S_j) \) if \(
  N_1 \) is on \( S_i \) and \( N_2 \) is on \( S_j, \) with the two
  knights attacking each other.  Here \( 1 \le i, j \le n^2 \) and \(
  i \ne j.  \)
</p>
<p>
  Let \( M \) be the set of all mutually attacking knight placements
  for distinct knights on an \( n \times n \) board.  Then

  \[
    g(n) = \lvert M \rvert.
  \]

  If \( (S_i, S_j) \) is a mutually attacking knight placement of the
  distinct knights \( N_1 \) and \( N_2 \) for some \( i \) and
  \( j \) with \( 1 \le i, j \le n^2 \) and \( i \ne j, \) then \(
  (S_j, S_i) \) is also a mutually attacking knight placement, since
  swapping the positions of the two mutually attacking knights still
  yields a valid mutually attacking placement.  Therefore

  \[
    (S_i, S_j) \in M \iff (S_j, S_i) \in M.
  \]

  Each ordered placement \( (S_i, S_j) \) in \( M \) is thus paired
  with the ordered placement \( (S_j, S_i).  \)  When the knights are
  identical, the two arrangements are indistinguishable and count as
  one placement.  Hence, the number of mutually attacking placements
  for identical knights is exactly half of the number for distinct
  knights, i.e.

  \[
    f(n) = \frac{g(n)}{2}.
  \]

  The next subsection focuses on calculating \( g(n), \) from which \(
  f(n) \) follows immediately by the above formula.
</p>
<h3 id="closed-form-expression-2">Closed Form Expression<a href="#closed-form-expression-2"></a></h3>
<p>
  As noted in the previous section, the number of mutually attacking
  knight placements for two distinct knights on an \( n \times n \)
  board is simply the sum of attacking degrees of all squares on the
  board.  If we label each square as discussed in the previous section
  and use the notation \( \deg(S_i) \) for the attacking degree of the
  square labelled \( S_i, \) where \( 1 \le i \le n^2, \) then

  \[
    g(n) = \sum_{i=1}^{n^2} \deg(S_i).
  \]

  Recall that the attacking degree of a square is the number of
  squares a knight could attack if it were placed there.  Earlier, we
  saw that on a \( 3 \times 3 \) board, all squares except the centre
  one have attacking degree \( 2, \) which gives \( g(3) = 8 \times 2
  = 16 \) and \( f(3) = g(3)/2 = 8.  \)  Let us now write down the
  attacking degrees of all squares on a \( 4 \times 4 \) board.
</p>
<figure>
  <table class="chess">
    <tr>
      <td>2</td>
      <td>3</td>
      <td>3</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>3</td>
      <td>2</td>
    </tr>
  </table>
  <figcaption>
    Attacking degrees of all squares on a \( 4 \times 4 \) board
  </figcaption>
</figure>
<p>
  From the above illustration we get

  \begin{align*}
    g(4) &amp; = 4 \times 2 + 8 \times 3 + 4 \times 4 = 48, \\
    f(4) &amp; = g(4)/2 = 24.
  \end{align*}

  A more general pattern emerges if we consider a larger board, such
  as a \( 6 \times 6 \) board.
</p>
<figure>
  <table class="chess">
    <tr>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>6</td>
      <td>6</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>4</td>
      <td>6</td>
      <td>8</td>
      <td>8</td>
      <td>6</td>
      <td>4</td>
    </tr>
    <tr>
      <td>4</td>
      <td>6</td>
      <td>8</td>
      <td>8</td>
      <td>6</td>
      <td>4</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>6</td>
      <td>6</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
    </tr>
  </table>
  <figcaption>
    Attacking degrees of all squares on a \( 6 \times 6 \) board
  </figcaption>
</figure>
<p>
  From this illustration, we get

  \begin{align*}
    g(6) &amp; = 4 \times 2 + 8 \times 3 + 12 \times 4 + 8 \times 6 + 4 \times 8 = 160.  \\
    f(6) &amp; = g(6)/2 = 80.
  \end{align*}

  Let us find a general formula now for \( n \ge 4.  \)  We introduce
  one more notation.  Let \( D_k(n) \) denote the sum of the attacking
  degrees of all squares of attacking degree \( k \) on an \( n \times
  n \) board, i.e.

  \[
    D_k(n) = \sum_{\mathclap{\deg(S_i) = k}} \deg(S_i).
  \]

  Since the only attacking degrees the squares can have are \( 2, 3,
  4, 6 \) and \( 8, \) the sum of the attacking degrees of all squares
  can be written as

  \[
    g(n) = D_2(n) + D_3(n) + D_4(n) + D_6(n) + D_8(n).
  \]

  There are exactly four squares of attacking degree \( 2.  \)  These
  are the corner ones.  Therefore,

  \[
    D_2(n) = 4 \times 2 = 8.
  \]

  The eight squares adjacent to the corner squares have attacking
  degree \( 3.  \)  Therefore,

  \[
    D_3(n) = 8 \times 3 = 24.
  \]

  Let us define an <em>inner corner square</em> as one that shares a
  corner with a corner square but not an edge with it.  There are four
  inner corner squares and each has attacking degree \( 4.  \)
  Further, each row and column on the outer edge contains \( n - 4 \)
  additional squares with attacking degree \( 4.  \)  Therefore,

  \[
    D_4(n) = (4 + 4(n - 4))(4) = 16(n - 3).
  \]

  Consider a row or column that contains two inner corner squares of
  attacking degree \( 4.  \)  All \( n - 4 \) squares between the inner
  corner squares have attacking degree \( 6.  \)  There are two such
  rows and two such columns.  Therefore,

  \[
    D_6(n) = 4(n - 4)(6) = 24(n - 4).
  \]

  We have counted the attacking degrees of all squares in the first
  two columns and rows as well as the last two columns and rows.  We
  are left with \( (n - 4)^2 \) squares in the middle and they all
  have attacking degree \( 8.  \)  Therefore,

  \[
    D_8(n) = 8(n - 4)^2.
  \]

  Therefore,

  \begin{align*}
    g(n)
    &amp; = D_2(n) + D_3(n) + D_4(n) + D_6(n) + D_8(n) \\
    &amp; = 8 + 24 + 16(n - 3) + 24(n - 4) + 8(n - 4)^2 \\
    &amp; = 8(n - 1)(n - 2).
  \end{align*}

  Even though we assumed \( n \ge 4 \) while obtaining the above
  formula, remarkably, it gives us the correct values for \( n = 1,
  2 \) and \( 3.  \)  The number of mutually attacking knight
  placements for distinct knights on an \( n \times n \) board is \(
  0 \) if \( n = 1 \) or \( 2.  \)  It is \( 16 \) if \( n = 3.  \)
  Indeed the above formula gives us

  \[
    g(1) = g(2) = 0, \quad g(3) = 16.
  \]

  Therefore, we can now generalise the above result as

  \[
    g(n) = 8(n - 1)(n - 2)
  \]

  for all \( n \ge 1.  \)  Therefore, for all \( n \ge 1, \)

  \[
    f(n) = \frac{g(n)}{2} = 4(n - 1)(n - 2).
  \]
</p>
<h2 id="counting-placements-from-minimal-attack-sections">Counting Placements From Minimal Attack Sections<a href="#counting-placements-from-minimal-attack-sections"></a></h2>
<p>
  Finally, in this section, we take a look at a simple and elegant
  solution that arrives at the closed-form solution in a more direct
  manner.  The analysis begins by looking at the smallest section of
  the board where two knights can attack each other.
</p>
<h3 id="minimal-attack-sections">Minimal Attack Sections<a href="#minimal-attack-sections"></a></h3>
<p>
  Consider a \( 2 \times 3 \) section of a board of size
  \( 3 \times 3 \) or larger.  Such a section has exactly two mutually
  attacking knight placements.
</p>
<figure>
  <table class="chess inline">
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
  </table>
  <table class="chess inline">
    <tr>
      <td></td>
      <td></td>
      <td class="black knight"></td>
    </tr>
    <tr>
      <td class="black knight"></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <figcaption>
    Two mutually attacking knight placements on a \( 2 \times 3 \)
    section of a board
  </figcaption>
</figure>
<p>
  Similarly, a \( 3 \times 2 \) section of a board also has exactly
  two mutually attacking knight placements.
</p>
<figure>
  <table class="chess odd inline">
    <tr>
      <td class="black knight"></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td class="black knight"></td>
    </tr>
  </table>
  <table class="chess odd inline">
    <tr>
      <td></td>
      <td class="black knight"></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td class="black knight"></td>
      <td></td>
    </tr>
  </table>
  <figcaption>
    Two mutually attacking knight placements on a \( 3 \times 2 \)
    section of a board
  </figcaption>
</figure>
<p>
  We call these \( 2 \times 3 \) and \( 3 \times 2 \) sections
  the <em>minimal attack sections</em> of a board, since no smaller
  section can contain a mutually attacking knight placement.
</p>
<p>
  Two distinct \( 2 \times 3 \) sections can share at most a \( 1
  \times 3 \) section, which is smaller than a minimal attack section.
  Consequently, no mutually attacking knight placement can be common
  to two distinct \( 2 \times 3 \) sections of a board.
</p>
<p>
  Similarly, two distinct \( 3 \times 2 \) sections can share at most
  a \( 3 \times 1 \) section, again too small to contain a minimal
  attack section.  Therefore, they share no mutually attacking knight
  placement.
</p>
<p>
  A \( 2 \times 3 \) section and a \( 3 \times 2 \) section can share
  at most a \( 2 \times 2 \) section, which is still smaller than a
  minimal attack section, so they share no mutually attacking knight
  placement either.
</p>
<p>
  To summarise, any two minimal attack sections of the board yield
  distinct pairs of mutually attacking knight placements.  The total
  number of such placements is therefore exactly twice the number of
  minimal attack sections on the board.
</p>
<h3 id="closed-form-expression-3">Closed Form Expression<a href="#closed-form-expression-3"></a></h3>
<p>
  In an \( n \times n \) board where \( n \ge 3, \) the left edge of a
  \( 2 \times 3 \) section can be placed in any one of the first \( n
  - 2 \) columns of the board.  Similarly, the top edge of such a
  section can be placed in any one of the first \( n - 1 \) rows of
  the board.  Therefore, the total number of distinct \( 2 \times 3 \)
  sections on the board is \( (n - 2)(n - 1).  \)
</p>
<p>
  By similar reasoning, the number of distinct \( 3 \times 2 \)
  sections on an \( n \times n \) board, where \( n \ge 3, \) is also
  \( (n - 1)(n - 2).  \)
</p>
<p>
  Let \( h(n) \) be the total number of minimal attack sections we can
  find on an \( n \times n \) board where \( n \ge 1.  \)  From the
  discussion in the previous two paragraphs, we know that \( h(n) =
  2(n - 1)(n - 2) \) for \( n \ge 3.  \)  Further, this formula for \(
  h(n) \) works for \( n = 1 \) and \( n = 2 \) as well since \( h(1)
  = h(2) = 0 \) and indeed a \( 1 \times 1 \) board or a
  \( 2 \times 2 \) board is too small to contain any minimal attack
  sections.  Therefore, for all \( n \ge 1, \) we get

  \[
    h(n) = 2(n - 1)(n - 2).
  \]

  Since each minimal attack section yields two mutually attacking
  knight placements, the total number of mutually attacking knight
  placements on an \( n \times n \) board is

  \[
    f(n) = 2h(n) = 4(n - 1)(n - 2)
  \]

  for all \( n \ge 1.  \)
</p>
<h2 id="reference">References<a href="#reference"></a></h2>
<ul>
  <li>
    <a href="https://cses.fi/problemset/task/1072">Two Knights</a>
    from the CSES Problem Set
  </li>
  <li>
    <a href="https://mathworld.wolfram.com/KnightGraph.html">Knight Graph</a>
    by Eric W. Weisstein
  </li>
  <li>
    <a href="https://oeis.org/A033996">OEIS Entry A033996</a>
    by N. J. A. Sloane
  </li>
  <li>
    <a href="https://oeis.org/A172132">OEIS Entry A172132</a>
    by Vaclav Kotesovec
  </li>
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/mutually-attacking-knights.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Zigzag Number Spiral</title>
<link>https://susam.net/zigzag-number-spiral.html</link>
<guid isPermaLink="false">znscf</guid>
<pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<div style="display: none">
  \[
    \gdef\lf{\hspace{-5mm}\leftarrow\hspace{-5mm}}
    \gdef\rt{\hspace{-5mm}\rightarrow\hspace{-5mm}}
    \gdef\up{\uparrow}
    \gdef\dn{\downarrow}
    \gdef\sp{}
    \gdef\cd{\cdots}
    \gdef\vd{\vdots}
    \gdef\dd{\ddots}
    \gdef\arraystretch{1.2}
    \gdef\hl{\small\blacktriangleright}
  \]
</div>
<p>
  Consider the following infinite grid of numbers, where the numbers
  are arranged in a spiral-like manner, but the spiral reverses
  direction each time it reaches the edge of the grid:

  \begin{array}{rcrcrcrcrl}
      1 &amp; \rt &amp;   2 &amp; \sp &amp;   9 &amp; \rt &amp;  10 &amp; \sp &amp;  25 &amp; \cd \\
    \sp &amp; \sp &amp; \dn &amp; \sp &amp; \up &amp; \sp &amp; \dn &amp; \sp &amp; \up &amp; \sp \\
      4 &amp; \lf &amp;   3 &amp; \sp &amp;   8 &amp; \sp &amp;  11 &amp; \sp &amp;  24 &amp; \cd \\
    \dn &amp; \sp &amp; \sp &amp; \sp &amp; \up &amp; \sp &amp; \dn &amp; \sp &amp; \up &amp; \sp \\
      5 &amp; \rt &amp;   6 &amp; \rt &amp;   7 &amp; \sp &amp;  12 &amp; \sp &amp;  23 &amp; \cd \\
    \sp &amp; \sp &amp; \sp &amp; \sp &amp; \sp &amp; \sp &amp; \dn &amp; \sp &amp; \up &amp; \sp \\
     16 &amp; \lf &amp;  15 &amp; \lf &amp;  14 &amp; \lf &amp;  13 &amp; \sp &amp;  22 &amp; \cd \\
    \dn &amp; \sp &amp; \sp &amp; \sp &amp; \sp &amp; \sp &amp; \sp &amp; \sp &amp; \up &amp; \sp \\
     17 &amp; \rt &amp;  18 &amp; \rt &amp;  19 &amp; \rt &amp;  20 &amp; \rt &amp;  21 &amp; \cd \\
    \vd &amp; \sp &amp; \vd &amp; \sp &amp; \vd &amp; \sp &amp; \vd &amp; \sp &amp; \vd &amp; \dd
  \end{array}

  Can we find a closed-form expression that tells us the number at the
  \( m \)th row and \( n \)th column?
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#patterns-on-the-edges">Patterns on the Edges</a>
    <ul>
      <li><a href="#computing-edge-numbers">Computing Edge Numbers</a></li>
      <li><a href="#computing-all-grid-numbers-1">Computing All Grid Numbers</a></li>
      <li><a href="#closed-form-expression-1">Closed Form Expression</a></li>
    </ul>
  </li>
  <li><a href="#patterns-on-the-diagonal">Patterns on the Diagonal</a>
    <ul>
      <li><a href="#computing-diagonal-numbers">Computing Diagonal Numbers</a></li>
      <li><a href="#computing-all-grid-numbers-2">Computing All Grid Numbers</a></li>
      <li><a href="#closed-form-expression-2">Closed Form Expression</a></li>
    </ul>
  </li>
  <li><a href="#references">References</a></li>
</ul>
<h2 id="introduction">Introduction<a href="#introduction"></a></h2>
<p>
  Before we explore this problem further, let us rewrite the zigzag
  number spiral grid in a cleaner form, omitting the arrows:

  \begin{array}{rrrrrl}
      1 &amp;   2 &amp;   9  &amp;  10 &amp;  25 &amp; \cd \\
      4 &amp;   3 &amp;   8  &amp;  11 &amp;  24 &amp; \cd \\
      5 &amp;   6 &amp;   7  &amp;  12 &amp;  23 &amp; \cd \\
     16 &amp;  15 &amp;  14  &amp;  13 &amp;  22 &amp; \cd \\
     17 &amp;  18 &amp;  19  &amp;  20 &amp;  21 &amp; \cd \\
    \vd &amp; \vd &amp; \vd  &amp; \vd &amp; \vd &amp; \dd
  \end{array}

  Let \( f(m, n) \) denote the number at the \( m \)th row and
  \( n \)th column.  For example, \( f(1, 1) = 1 \) and \( f(2, 5) =
  24.  \)  We want to find a closed-form expression for \( f(m, n).  \)
</p>
<p>
  Let us first clarify what we mean by a <em>closed-form
  expression</em>.  There is no universal definition of a closed-form
  expression, but the term typically refers to a mathematical
  expression involving variables and constants, built using a finite
  combination of basic operations: addition, subtraction,
  multiplication, division, integer exponents, roots with integer
  index and functions such as exponentials, logarithms and
  trigonometric functions.
</p>
<p>
  In this article, however, we need only addition, subtraction,
  division, squares and square roots.  This may be a bit of a spoiler,
  but I must mention that the \( \max \) function appears in the
  closed-form expressions we are about to see.  If you are concerned
  about whether functions like \( \max \) and \( \min \) are permitted
  in such expressions, note that

  \begin{align*}
    \max(m, n) &amp; = \frac{m + n + \sqrt{(m - n)^2}}{2}, \\
    \min(m, n) &amp; = \frac{m + n - \sqrt{(m - n)^2}}{2}.
  \end{align*}

  So \( \max \) and \( \min \) are simply shorthand for expressions
  involving addition, subtraction, division, squares and square roots.
  In the discussion that follows, we will use only the \( \max \)
  function.
</p>
<h2 id="patterns-on-the-edges">Patterns on the Edges<a href="#patterns-on-the-edges"></a></h2>
<p>
  Let us begin by analysing the edge numbers.  Number the rows as \(
  1, 2, 3 \dots \) and the columns likewise.  Observe where the spiral
  touches the left edge and changes direction.  This happens only on
  even-numbered rows.  Similarly, each time the spiral touches the top
  edge and changes direction, it does so on odd-numbered columns.  In
  the following subsections, we take a closer look at this behaviour
  of the spiral.
</p>
<p>
  I should mention that this section takes a rather long path to
  arrive at the closed-form solution.  Personally, I enjoy such long
  tours.  If you prefer a more direct approach, feel free to skip
  ahead to
  <a href="#patterns-on-the-diagonal">Patterns on the Diagonal</a> for
  a shorter discussion that reaches the same result.
</p>
<h3 id="computing-edge-numbers">Computing Edge Numbers<a href="#computing-edge-numbers"></a></h3>
<p>
  Each time the spiral reaches the left edge of the grid, it does so
  at some \( m \)th row where \( m \) is even.  The \( m \times m \)
  subgrid formed by the first \( m \) rows and the first \( m \)
  columns contains \( m^2 \) consecutive numbers.  Since the numbers
  strictly increase as the spiral grows, the largest of these
  \( m^2 \) numbers must appear at the position where the spiral
  touches the left edge.  This is illustrated in the figure below.
</p>
<figure>
  \begin{array}{rrrr:rl}
     1     &amp;   2 &amp;   9  &amp;  10 &amp;  25 &amp; \cd \\
     4     &amp;   3 &amp;   8  &amp;  11 &amp;  24 &amp; \cd \\
     5     &amp;   6 &amp;   7  &amp;  12 &amp;  23 &amp; \cd \\
    \hl 16 &amp;  15 &amp;  14  &amp;  13 &amp;  22 &amp; \cd \\
    \hdashline
    17     &amp;  18 &amp;  19  &amp;  20 &amp;  21 &amp; \cd \\
    \vd    &amp; \vd &amp; \vd  &amp; \vd &amp; \vd &amp; \dd
  \end{array}
  <figcaption>
    The spiral touches the left edge on the \( 4 \)th row where the
    number is \( 4^2 \)
  </figcaption>
</figure>
<p>
  Whenever the spiral touches the left edge at the \( m \)th row
  (where \( m \) is even), the number in the first column of that row
  is \( m^2.  \)  Hence, we conclude that \( f(m, 1) = m^2 \) when \( m
  \) is even.  Immediately after touching the left edge, the spiral
  turns downwards into the first column of the next row.  Thus, in the
  next row, i.e. in the \( (m + 1) \)th row, we have \( f(m + 1, 1) =
  m^2 + 1, \) where \( m + 1 \) is odd.  This can be restated as \(
  f(m, 1) = (m - 1)^2 + 1 \) when \( m \) is odd.  Since \( f(1, 1) =
  1, \) we can summarise the two formulas we have found here as:

  \[
    f(m, 1) =
      \begin{cases}
        m^2           &amp; \text{if } m \equiv 0 \pmod{2}, \\
        (m - 1)^2 + 1 &amp; \text{if } m \equiv 1 \pmod{2}.
      \end{cases}
  \]
</p>
<p>
  We can perform a similar analysis for the numbers at the top edge
  and note that whenever the spiral touches the top edge at the
  \( n \)th column (where \( n \) is odd), the number in the first row
  of that column is \( n^2.  \)  This is illustrated below.
</p>
<figure>
  \begin{array}{rrr:rrl}
     1 &amp;   2 &amp; \hl 9 &amp;  10 &amp;  25 &amp; \cd \\
     4 &amp;   3 &amp;     8 &amp;  11 &amp;  24 &amp; \cd \\
     5 &amp;   6 &amp;     7 &amp;  12 &amp;  23 &amp; \cd \\
    \hdashline
    16 &amp;  15 &amp;    14 &amp;  13 &amp;  22 &amp; \cd \\
    17 &amp;  18 &amp;    19 &amp;  20 &amp;  21 &amp; \cd \\
    \vd &amp; \vd &amp;  \vd &amp; \vd &amp; \vd &amp; \dd
  \end{array}
  <figcaption>
    The spiral touches the top edge on the \( 3 \)rd column where the
    number is \( 3^2 \)
  </figcaption>
</figure>
<p>
  Immediately after touching the top edge, the spiral turns right into
  the next column.  These observations give us the following formula
  for the numbers at the top edge:

  \[
    f(1, n) =
      \begin{cases}
        n^2           &amp; \text{if } n \equiv 1 \pmod{2}, \\
        (n - 1)^2 + 1 &amp; \text{if } n \equiv 0 \pmod{2}.
      \end{cases}
  \]

  Next we will find a formula for any arbitrary number anywhere in the
  grid.
</p>
<h3 id="computing-all-grid-numbers-1">Computing All Grid Numbers<a href="#computing-all-grid-numbers-1"></a></h3>
<p>
 Since the spiral touches the left edge on even-numbered rows, then
 turns downwards into the next (odd-numbered) row and then starts
 moving right until the diagonal (where it changes direction again),
 the following two rules hold:
</p>
<ul>
  <li>
    On every odd-numbered row, as we go from left to right, the
    numbers increase until we reach the diagonal.
  </li>
  <li>
    On every even-numbered row, as we go from left to right, the
    numbers decrease until we reach the diagonal.
  </li>
</ul>
<p>
  Note that all the numbers we considered in the above two points lie
  on or below the diagonal (or equivalently, on or to the left of the
  diagonal).  Therefore, on an odd-numbered row, we can find the
  numbers on or below the diagonal using the formula \( f(m, n) = f(m,
  1) + (n - 1), \) where \( m \) is odd.  Similarly, on even-numbered
  rows, we can find the numbers on or below the diagonal using the
  formula \( f(m, n) = f(m, 1) - (n - 1), \) where \( m \) is even.
</p>
<p>
  By a similar analysis, the following rules hold when we consider the
  numbers in a column:
</p>
<ul>
  <li>
    On every even-numbered column, as we go from top to bottom, the
    numbers increase until we reach the diagonal.
  </li>
  <li>
    On every odd-numbered column, as we go from top to bottom, the
    numbers decrease until we reach the diagonal.
  </li>
</ul>
<p>
  Now the numbers on or above the diagonal can be found using the
  formula \( f(m, n) = f(1, n) - (m - 1) \) when \( n \) is odd and \(
  f(m, n) = f(1, n) + (m - 1), \) when \( n \) is even.
</p>
<p>
  Can we determine from the values of \( m \) and \( n \) if the
  number \( f(m, n) \) is above the diagonal or below it?  Yes, if \(
  m \le n, \) then \( f(m, n) \) lies on or above the diagonal.
  However, if \( m \ge n, \) then \( f(m, n) \) lies on or below the
  diagonal.
</p>
<p>
  We now have everything we need to write a general formula for
  finding the numbers anywhere in the grid.  Using the four formulas
  and the two inequalities obtained in this section, we get

  \[
    f(m, n) =
      \begin{cases}
        f(1, n) + (m - 1)
        &amp; \text{if } m \le n \text{ and } n \equiv 0 \pmod{2}, \\
        f(1, n) - (m - 1)
        &amp; \text{if } m \le n \text{ and } n \equiv 1 \pmod{2}, \\
        f(m, 1) - (n - 1)
        &amp; \text{if } m \ge n \text{ and } m \equiv 0 \pmod{2}, \\
        f(m, 1) + (n - 1)
        &amp; \text{if } m \ge n \text{ and } m \equiv 1 \pmod{2}.  \\
      \end{cases}
  \]

  Using the equations for \( f(1, n) \) and \( f(m, 1) \) from the
  previous section, the above formulas can be rewritten as

  \[
    f(m, n) =
      \begin{cases}
        (n - 1)^2 + 1 + (m - 1)
        &amp; \text{if } m \le n \text{ and } n \equiv 0 \pmod{2}, \\
        n^2 - (m - 1)
        &amp; \text{if } m \le n \text{ and } n \equiv 1 \pmod{2}, \\
        m^2 - (n - 1)
        &amp; \text{if } m \ge n \text{ and } m \equiv 0 \pmod{2}, \\
        (m - 1)^2 + 1 + (n - 1)
        &amp; \text{if } m \ge n \text{ and } m \equiv 1 \pmod{2}.  \\
      \end{cases}
  \]

  Simplifying the expressions on the right-hand side, we get

  \[
    f(m, n) =
      \begin{cases}
        (n - 1)^2 + m
        &amp; \text{if } m \le n \text{ and } n \equiv 0 \pmod{2}, \\
        n^2 - m + 1
        &amp; \text{if } m \le n \text{ and } n \equiv 1 \pmod{2}, \\
        m^2 - n + 1
        &amp; \text{if } m \ge n \text{ and } m \equiv 0 \pmod{2}, \\
        (m - 1)^2 + n
        &amp; \text{if } m \ge n \text{ and } m \equiv 1 \pmod{2}.  \\
      \end{cases}
  \]

  This is pretty good.  We now have a piecewise formula that works for
  any position in the grid.  Let us now explore whether we can express
  it as a single closed-form expression.
</p>
<h3 id="closed-form-expression-1">Closed Form Expression<a href="#closed-form-expression-1"></a></h3>
<p>
  First, we will rewrite the piecewise formula from the previous
  section in the following form:

  \[
    f(m, n) =
      \begin{cases}
        (n^2 - n + 1) + (m - n)
        &amp; \text{if } m \le n \text{ and } n \equiv 0 \pmod{2}, \\
        (n^2 - n + 1) - (m - n)
        &amp; \text{if } m \le n \text{ and } n \equiv 1 \pmod{2}, \\
        (m^2 - m + 1) + (m - n)
        &amp; \text{if } m \ge n \text{ and } m \equiv 0 \pmod{2}, \\
        (m^2 - m + 1) - (m - n)
        &amp; \text{if } m \ge n \text{ and } m \equiv 1 \pmod{2}.  \\
      \end{cases}
  \]

  This is the same formula, rewritten to reveal common patterns
  between the four expressions on the right-hand side.  In each
  expression, one variable plays the dominant role, occurring several
  times, while the other appears only once.  For example, in the first
  two expressions, \( n \) plays the dominant role whereas \( m \)
  occurs only once.  If we look closely, we realise that it is the
  variable that is greater than or equal to the other that plays the
  dominant role.  Therefore the first and third expressions may be
  written as

  \[
    \left( (\max(m, n))^2 - \max(m, n) + 1 \right) + (m - n).
  \]

  Similarly, the second and fourth expressions may be written as

  \[
    \left( (\max(m, n))^2 - \max(m, n) + 1 \right) - (m - n).
  \]

  We have made some progress towards a closed-form expression.  We
  have collapsed the four expressions in the piecewise formula to just
  two.  The only difference between them lies in the sign of the
  second term: it is positive when the dominant variable is even and
  negative when it is odd.  This observation allows us to unify both
  cases into a single expression:

  \[
    f(m, n) = (\max(m, n))^2 - \max(m, n) + 1 + (-1)^{\max(m, n)} (m - n).
  \]

  Now we have a closed-form expression for \( f(m, n) \) that gives
  the number at any position in the grid.
</p>
<h2 id="patterns-on-the-diagonal">Patterns on the Diagonal<a href="#patterns-on-the-diagonal"></a></h2>
<p>
  As mentioned earlier, there is a shorter route to the same
  closed-form expression.  This alternative approach is based on
  analysing the numbers along the diagonal of the grid.  We still need
  to examine the edge numbers, but not all of them as we did in the
  previous section.  Some of the reasoning about edge values will be
  repeated here to ensure this section is self-contained.
</p>
<h3 id="computing-diagonal-numbers">Computing Diagonal Numbers<a href="#computing-diagonal-numbers"></a></h3>
<p>
  A number on the diagonal has the same row number and column number.
  In other words, a diagonal number has the value \( f(n, n) \) for
  some positive integer \( n.  \)  Consider the case when \( n \) is
  even.  In this case, the diagonal number is on a segment of the
  spiral that is moving to the left.  The \( n \times n \) subgrid
  formed by the first \( n \) rows and the first \( n \) columns
  contains exactly \( n^2 \) consecutive numbers.  Since the diagonal
  number is on the last row of this subgrid and the numbers in this
  row increase as we move from right to left, the largest number in
  the subgrid must be on the left edge of this row.  Therefore the
  number at the left edge is \( f(n, 1) = n^2, \) where \( n \) is
  even.  This is illustrated below.
</p>
<figure>
  \begin{array}{rrrr:rl}
     1     &amp;   2 &amp;   9  &amp;     10 &amp;  25 &amp; \cd \\
     4     &amp;   3 &amp;   8  &amp;     11 &amp;  24 &amp; \cd \\
     5     &amp;   6 &amp;   7  &amp;     12 &amp;  23 &amp; \cd \\
    \hl 16 &amp;  15 &amp;  14  &amp; \hl 13 &amp;  22 &amp; \cd \\
    \hdashline
    17     &amp;  18 &amp;  19  &amp;     20 &amp;  21 &amp; \cd \\
    \vd    &amp; \vd &amp; \vd  &amp;    \vd &amp; \vd &amp; \dd
  \end{array}
  <figcaption>
    The spiral touches the left edge on the \( 4 \)th row where the
    number is \( 4^2 \)
  </figcaption>
</figure>
<p>
  From the diagonal to the edge of the subgrid, there are \( n \)
  consecutive numbers.  In a sequence of \( n \) consecutive numbers,
  the difference between the maximum number and the minimum number is
  \( n - 1.  \)  Therefore, \( n^2 - f(n, n) = n - 1.  \)  This gives us

  \[
    f(n, n) = n^2 - n + 1 \quad \text{if } n \equiv 0 \pmod{2}.
  \]
</p>
<p>
  Now consider the case when \( n \) is odd.
</p>
<figure>
  \begin{array}{rrr:rrl}
     1 &amp;   2 &amp; \hl 9 &amp;  10 &amp;  25 &amp; \cd \\
     4 &amp;   3 &amp;     8 &amp;  11 &amp;  24 &amp; \cd \\
     5 &amp;   6 &amp; \hl 7 &amp;  12 &amp;  23 &amp; \cd \\
    \hdashline
    16 &amp;  15 &amp;    14 &amp;  13 &amp;  22 &amp; \cd \\
    17 &amp;  18 &amp;    19 &amp;  20 &amp;  21 &amp; \cd \\
    \vd &amp; \vd &amp;  \vd &amp; \vd &amp; \vd &amp; \dd
  \end{array}
  <figcaption>
    The spiral touches the top edge on the \( 3 \)rd column where the
    number is \( 3^2 \)
  </figcaption>
</figure>
<p>
  By a similar reasoning, for odd \( n, \) the \( n \)th column has
  numbers that increase as we move up from the diagonal number towards
  the top edge.  Therefore \( f(1, n) = n^2 \) and since \( n^2 - f(n,
  n) = n - 1, \) we again obtain

  \[
    f(n, n) = n^2 - n + 1 \quad \text{if } n \equiv 1 \pmod{2}.
  \]

  Since \( f(n, n) \) takes the same form for both odd and even
  \( n, \) we can write

  \[
    f(n, n) = n^2 - n + 1
  \]

  for all positive integers \( n.  \)
</p>
<h3 id="computing-all-grid-numbers-2">Computing All Grid Numbers<a href="#computing-all-grid-numbers-2"></a></h3>
<p>
  If \( m \le n, \) then the number \( f(m, n) \) lies on or above the
  diagonal number \( f(n, n).  \)  If \( n \) is even, then the numbers
  decrease as we go from the diagonal up to the top edge.  Therefore
  \( f(m, n) \le f(n, n) \) and \( f(m, n) = f(n, n) - (n - m).  \)  If
  \( n \) is odd, then the numbers increase as we go from the diagonal
  up to the top edge and therefore \( f(m, n) \ge f(n, n) \) and \(
  f(m, n) = f(n, n) + (n - m).  \)
</p>
<p>
  If \( m \ge n, \) then the number \( f(m, n) \) lies on or below the
  diagonal number \( f(m, m).  \)  By a similar analysis, we find that
  \( f(m, n) = f(m, m) + (m - n) \) if \( n \) is even and \( f(m, n)
  = f(m, m) - (m - n) \) if \( n \) is odd.  We summarise these
  results as follows:

  \[
    f(m, n) =
      \begin{cases}
        f(n, n) - (n - m)
        &amp; \text{if } m \le n \text{ and } n \equiv 0 \pmod{2}, \\
        f(n, n) + (n - m)
        &amp; \text{if } m \le n \text{ and } n \equiv 1 \pmod{2}, \\
        f(m, m) + (m - n)
        &amp; \text{if } m \ge n \text{ and } m \equiv 0 \pmod{2}, \\
        f(m, m) - (m - n)
        &amp; \text{if } m \ge n \text{ and } m \equiv 1 \pmod{2}.  \\
      \end{cases}
  \]

  Note that the above formula can be rewritten as

  \[
    f(m, n) =
      \begin{cases}
        f(n, n) + (m - n)
        &amp; \text{if } m \le n \text{ and } n \equiv 0 \pmod{2}, \\
        f(n, n) - (m - n)
        &amp; \text{if } m \le n \text{ and } n \equiv 1 \pmod{2}, \\
        f(m, m) + (m - n)
        &amp; \text{if } m \ge n \text{ and } m \equiv 0 \pmod{2}, \\
        f(m, m) - (m - n)
        &amp; \text{if } m \ge n \text{ and } m \equiv 1 \pmod{2}.  \\
      \end{cases}
  \]
</p>
<h3 id="closed-form-expression-2">Closed Form Expression<a href="#closed-form-expression-2"></a></h3>
<p>
  If we take a close look at the last formula in the previous section,
  we find that in each expression, one variable plays a dominant role,
  i.e. it occurs more frequently in the expression than the other.  In
  the first two expressions \( n \) plays the dominant role whereas in
  the last two expressions \( m \) plays the dominant role.  In fact,
  in each expression, the dominant variable is the one that is greater
  than or equal to the other.  With this in mind, we can rewrite the
  above formula as

  \[
    f(m, n) =
      \begin{cases}
        f(\max(m, n), \max(m, n)) + (m - n)
        &amp; \text{if } \max(m, n) \equiv 0 \pmod{2}, \\
        f(\max(m, n), \max(m, n)) - (m - n)
        &amp; \text{if } \max(m, n) \equiv 1 \pmod{2}.  \\
      \end{cases}
  \]

  The only difference between the expressions is the sign of the
  second term: it is positive when \( \max(m, n) \) is even and
  negative when \( \max(m, n) \) is odd.  As a result, we can rewrite
  the above formula as a single expression like this:

  \[
    f(m, n) = f(\max(m, n), \max(m, n)) + (-1)^{\max(m, n)} (m - n).
  \]

  Using the formula \( f(n, n) = n^2 - n + 1 \) from the previous
  section, we get

  \[
    f(m, n) = (\max(m, n))^2 - \max(m, n) + 1 + (-1)^{\max(m, n)} (m - n).
  \]

  We arrive again at the same closed-form expression, this time by
  focusing on the diagonal of the grid.
</p>
<h2 id="references">References<a href="#references"></a></h2>
<ul>
  <li>
    <a href="https://cses.fi/problemset/task/1071">Number Spiral</a>
    from the CSES Problem Set
  </li>
  <li>
    <a href="https://mathworld.wolfram.com/Closed-FormSolution.html">Closed-Form Solution</a>
    by Christopher Stover and Eric W. Weisstein
  </li>
  <li>
    <a href="https://mathworld.wolfram.com/PiecewiseFunction.html">Piecewise Function</a>
    by Eric W. Weisstein
  </li>
</ul>
<!-- ### -->
<p>
  <a href="https://susam.net/zigzag-number-spiral.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Wordle With Grep</title>
<link>https://susam.net/wordle-with-grep.html</link>
<guid isPermaLink="false">rvtgp</guid>
<pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  Let us solve a couple of
  <a href="https://www.powerlanguage.co.uk/wordle/">Wordle</a> games
  with the Unix <code>grep</code> command and the
  Unix <code>words</code> file.  The Wordle games #217, #218 and #219
  for 22&nbsp;Jan&nbsp;2022, 23&nbsp;Jan&nbsp;2022 and
  24&nbsp;Jan&nbsp;22 respectively are used as examples in this post.
  The output examples shown below are obtained using the words
  file <code>/usr/share/dict/words</code>, GNU grep 3.6 and GNU bash
  5.1.4 on Debian GNU/Linux 11.2 (bullseye).
</p>
<p>
  Note that the original Wordle game uses a different word list.
  Further, there are several Wordle clones which may have their own
  word lists.  For the purpose of this post, we will use the word list
  that comes with Debian.  We will solve each Wordle in a quick and
  dirty manner in this post.  The focus is going to be on making
  constant progress and reaching the solution quickly with simple
  shell commands.
</p>
<h2 id="contents">Contents<a href="#contents"></a></h2>
<ul>
  <li><a href="#preliminary-work">Preliminary Work</a></li>
  <li><a href="#wordle-217">Wordle #217</a></li>
  <li><a href="#wordle-218">Wordle #218</a></li>
  <li><a href="#wordle-219">Wordle #219</a></li>
</ul>
<h2 id="preliminary-work">Preliminary Work<a href="#preliminary-work"></a></h2>
<p>
  Before we start solving Wordle games, we will do some preliminary
  work.  We will create a convenient shell alias that automatically
  selects all five-letter words from the <code>words</code> files.  We
  will also find a good word to enter as the first guess into the
  Wordle game.  The following steps elaborate this preliminary work:
</p>
<ol>
  <li>
    <p>
      Make a shell alias named <code>words</code> that selects all 5
      letter words from the words file.
    </p>
<pre>
<samp>$ <kbd>alias words='grep "^[a-z]\{5\}$" /usr/share/dict/words'</kbd>
$ <kbd>words | head -n 3</kbd>
abaci
aback
abaft
$ <kbd>words | tail -n 3</kbd>
zoned
zones
zooms
$ <kbd>words | wc -l</kbd>
4594</samp>
</pre>
  </li>
  <li>
    <p>
      For each letter in the English alphabet, count the number of
      five-letter words that contain the letter.  Rank each letter by
      this count.
    </p>
<pre>
<samp>$ <kbd>for c in {a..z}; do echo $(words | grep $c | wc -l) $c; done | sort -rn | head -n 15</kbd>
2245 s
2149 e
1736 a
1404 r
1301 o
1231 i
1177 l
1171 t
975 n
924 d
810 u
757 c
708 p
633 h
623 y</samp>
</pre>
    <p>
      The output shows that the letter 's' occurs in 2245 five-letter
      words, followed by 'e' which occurs in 2149 five-letter words
      and so on.
    </p>
  </li>
  <li>
    <p>
      Find a word that contains the top five letters found in the
      previous step.
    </p>
<pre>
<samp>$ <kbd>words | grep s | grep e | grep a | grep r | grep o</kbd>
arose</samp>
</pre>
    <p>
      We will enter this word as the first guess in every Wordle game.
    </p>
  </li>
  <li>
    <p>
      In case, the word "arose" does not lead to any positive result,
      we will need another word to enter as our second guess.  Find a
      word that contains the next five top letters in the list found
      above.
    </p>
<pre>
<samp>$ <kbd>words | grep i | grep l | grep t | grep n | grep d</kbd>
$ <kbd>words | grep i | grep l | grep t | grep n | grep u</kbd>
until</samp>
</pre>
    <p>
      We found that there is no such word that contains 'i', 'l', 't',
      'n' and 'd'.  So we got rid of 'd' in our search and included
      'u' (the next highest ranking letter after 'd') instead to find
      the word "until".  We will enter this word as the second guess
      if and only if the first guess (i.e. "arose") does not lead to
      any positive result.
    </p>
</ol>
<h2 id="wordle-217">Wordle #217<a href="#wordle-217"></a></h2>
<p>
  Let us now solve Wordle #217 for Sat,&nbsp;22&nbsp;Jan&nbsp;2022
  with the following steps:
</p>
<ol>
  <li>
    <p>
      Use the word "arose" as the first guess.  The following result
      appears:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">A</span>
      <span style="background: #333; padding: 0.5em">R</span>
      <span style="background: #333; padding: 0.5em">O</span>
      <span style="background: #333; padding: 0.5em">S</span>
      <span style="background: #585; padding: 0.5em">E</span>
    </p>
  </li>
  <li>
    <p>
      The previous result shows that the letter 'e' occurs at the
      fifth place.  Further, the letters 'a', 'r', 'o' and 's' do not
      occur anywhere in the word.  Look for words satisfying these
      constraints.
    </p>
<pre>
<samp>$ <kbd>words | grep '....e' | grep -v '[aros]' | head -n 5</kbd>
beige
belie
belle
bible
bilge</samp>
</pre>
    <p>
      Pick the word "beige" for the second guess and enter it into the
      Wordle game.  Note that since we are following a quick and dirty
      approach here, we do not spend any time figuring out which of
      the various five-letter words ending with the letter 'e' is the
      most optimal choice for the next guess.  We simply pick the
      first word from the output above and enter it as the second
      guess.  The following result appears now:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">B</span>
      <span style="background: #333; padding: 0.5em">E</span>
      <span style="background: #b93; padding: 0.5em">I</span>
      <span style="background: #333; padding: 0.5em">G</span>
      <span style="background: #585; padding: 0.5em">E</span>
    </p>
  </li>
  <li>
    <p>
      The letter 'i' occurs somewhere in the word but not at the third
      place.  Further the letters 'b' and 'g' do not occur anywhere in
      the word.  Also, the letter 'e' does not occur anywhere apart
      from the fifth place.  The letter 'e' in the gray tile in the
      second place confirms that the letter 'e' does not repeat in the
      answer word.  Refine the previous command to add these
      constraints.
    </p>
<pre>
<samp>$ <kbd>words | grep '[^e][^e][^ie][^e]e' | grep i | grep -v '[arosbg]' | head -n 5</kbd>
fiche
indue
lithe
mince
niche</samp>
</pre>
    <p>
      Enter "fiche" as the third guess.  The following result appears:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">F</span>
      <span style="background: #585; padding: 0.5em">I</span>
      <span style="background: #b93; padding: 0.5em">C</span>
      <span style="background: #333; padding: 0.5em">H</span>
      <span style="background: #585; padding: 0.5em">E</span>
    </p>
  </li>
  <li>
    <p>
      The previous result shows that the letter 'i' occurs at the
      second place.  Further, the letter 'c' occurs somewhere in the
      word but not at the third place.  Also, the letters 'f' and 'h'
      do not occur anywhere in the word.  Refine the previous command
      further to add these constraints:
    </p>
<pre>
<samp>$ <kbd>words | grep '[^e]i[^iec][^e]e' | grep c | grep -v '[arosbgfh]' | head -n 5</kbd>
mince
wince</samp>
</pre>
    <p>
      Enter the word "mince" for the fourth guess.  It leads to the
      following result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">M</span>
      <span style="background: #585; padding: 0.5em">I</span>
      <span style="background: #585; padding: 0.5em">N</span>
      <span style="background: #585; padding: 0.5em">C</span>
      <span style="background: #585; padding: 0.5em">E</span>
    </p>
  </li>
  <li>
    <p>
      We are almost there!  We now have all the letters except the
      first one.  The previous result shows that the letter 'm' does
      not occur in the word.  Thus the answer word must be "wince".
      For the sake of completeness, here is a refined search that
      selects the answer word based on the constraints known so far:
    </p>
<pre>
<samp>$ <kbd>words | grep '[^e]ince' | grep -v '[arosbgfhm]' | head -n 5</kbd>
wince</samp>
</pre>
    <p>
      It looks like we have found the answer word.  Enter "wince" as
      the fifth guess to get the following result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #585; padding: 0.5em">W</span>
      <span style="background: #585; padding: 0.5em">I</span>
      <span style="background: #585; padding: 0.5em">N</span>
      <span style="background: #585; padding: 0.5em">C</span>
      <span style="background: #585; padding: 0.5em">E</span>
    </p>
    <p>
      Done!
    </p>
</ol>
<h2 id="wordle-218">Wordle #218<a href="#wordle-218"></a></h2>
<p>
  Now that the wordle for Sat,&nbsp;22&nbsp;Jan&nbsp;2022 is solved,
  let us try the same method on Wordle #219 for
  Sun,&nbsp;23&nbsp;Jan&nbsp;2022 and see how well this method works.
  Here are the steps:
</p>
<ol>
  <li>
    <p>
      Like before, the first guess is "arose".  Entering this word
      leads to the following result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">A</span>
      <span style="background: #585; padding: 0.5em">R</span>
      <span style="background: #333; padding: 0.5em">O</span>
      <span style="background: #333; padding: 0.5em">S</span>
      <span style="background: #333; padding: 0.5em">E</span>
    </p>
  </li>
  <li>
    <p>
      Now search for words based on the previous result.
    </p>
<pre>
<samp>$ <kbd>words | grep '.r...' | grep -v '[aose]' | head -n 5</kbd>
brick
bring
brink
briny
bruin</samp>
</pre>
    <p>
      Enter the word "brick" as the second guess.  This leads to the
      following result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">B</span>
      <span style="background: #585; padding: 0.5em">R</span>
      <span style="background: #585; padding: 0.5em">I</span>
      <span style="background: #b93; padding: 0.5em">C</span>
      <span style="background: #333; padding: 0.5em">K</span>
    </p>
  </li>
  <li>
    <p>
      Use the previous result to refine the search further.
    </p>
<pre>
<samp>$ <kbd>words | grep '.ri[^c].' | grep c | grep -v '[aosebk]' | head -n 5</kbd>
crimp</samp>
</pre>
    <p>
      Enter "crimp" as the third guess.  This leads to the following
      result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #585; padding: 0.5em">C</span>
      <span style="background: #585; padding: 0.5em">R</span>
      <span style="background: #585; padding: 0.5em">I</span>
      <span style="background: #585; padding: 0.5em">M</span>
      <span style="background: #585; padding: 0.5em">P</span>
    </p>
    <p>
      Done!
    </p>
  </li>
</ol>
<h2 id="wordle-219">Wordle #219<a href="#wordle-219"></a></h2>
<p>
  Finally, let us solve Wordle #219 for
  Mon,&nbsp;24&nbsp;Jan&nbsp;2022.
</p>
<ol>
  <li>
    <p>
      Enter "arose" as the first guess to get this result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">A</span>
      <span style="background: #333; padding: 0.5em">R</span>
      <span style="background: #585; padding: 0.5em">O</span>
      <span style="background: #333; padding: 0.5em">S</span>
      <span style="background: #333; padding: 0.5em">E</span>
    </p>
  </li>
  <li>
    <p>
      The previous result shows that the third letter is 'o' and the
      letters 'a', 'r', 's' and 'e' do not occur anywhere in the word.
      Search for words that match these constraints.
    </p>
<pre>
<samp>$ <kbd>words | grep '..o..' | grep -v '[arse]' | head -n 5</kbd>
block
blond
blood
bloom
blown</samp>
</pre>
    <p>
      Enter "block" as the second guess.  This leads to the following
      result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #333; padding: 0.5em">B</span>
      <span style="background: #b93; padding: 0.5em">L</span>
      <span style="background: #585; padding: 0.5em">O</span>
      <span style="background: #333; padding: 0.5em">C</span>
      <span style="background: #b93; padding: 0.5em">K</span>
    </p>
  </li>
  <li>
    <p>
      The previous result shows that the letter 'l' occurs somewhere
      in the word but not at the second place.  Similarly, the letter
      'k' occurs somewhere in the word but not at the fifth place.
      Further, the letters 'b' and 'c' do not occur anywhere in the
      word.  Search for words that match these constraints.
    </p>
<pre>
<samp>$ <kbd>words | grep '.[^l]o.[^k]' | grep l | grep k | grep -v '[arsebc]' | head -n 5</kbd>
knoll</samp>
</pre>
    <p>
      Enter "knoll" as the third guess.  It leads to the following
      result:
    </p>
    <p style="font-family: monospace; font-weight: bold; color: #ddd">
      <span style="background: #585; padding: 0.5em">K</span>
      <span style="background: #585; padding: 0.5em">N</span>
      <span style="background: #585; padding: 0.5em">O</span>
      <span style="background: #585; padding: 0.5em">L</span>
      <span style="background: #585; padding: 0.5em">L</span>
    </p>
    <p>
      Done!
    </p>
  </li>
</ol>
<!-- ### -->
<p>
  <a href="https://susam.net/wordle-with-grep.html">Read on website</a> |
  <a href="https://susam.net/tag/unix.html">#unix</a> |
  <a href="https://susam.net/tag/shell.html">#shell</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Loopy C Puzzle</title>
<link>https://susam.net/loopy-c-puzzle.html</link>
<guid isPermaLink="false">yuzqb</guid>
<pubDate>Sat, 01 Oct 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<h2 id="integer-underflow">Integer Underflow<a href="#integer-underflow"></a></h2>
<p>
  Let us talk a little bit about integer underflow and undefined
  behaviour in C before we discuss the puzzle I want to share in this
  post.
</p>
<pre>
<code>#include &lt;stdio.h&gt;

int main()
{
    int i;
    for (i = 0; i &lt; 6; i--) {
        printf(".");
    }
    return 0;
}</code>
</pre>
<p>
  This code invokes undefined behaviour.  The value in variable
  <code>i</code> decrements to <code>INT_MIN</code> after
  <code>|INT_MIN|</code> iterations.  In the next iteration, there is a
  negative overflow which is undefined for signed integers in C.  On
  many implementations though, <code>INT_MIN - 1</code> wraps around
  to <code>INT_MAX</code>.  Since <code>INT_MAX</code> is not less than
  <code>6</code>, the loop terminates.  With such implementations, this
  code prints print <code>|INT_MIN| + 1</code> dots.  With 32-bit integers,
  that amounts to 2147483649 dots.  Here is one such example output:
</p>
<pre>
<samp>$ <kbd>gcc -std=c89 -Wall -Wextra -pedantic foo.c &amp;&amp; ./a.out | wc -c</kbd>
2147483649</samp>
</pre>
<p>
  It is worth noting that the above behaviour is only one of the many
  possible ones.  The code invokes undefined behaviour and the ISO
  standard imposes no requirements on a specific implementation of the
  compiler regarding what the behaviour of such code should be.  For
  example, an implementation could also exploit the undefined
  behaviour to turn the loop into an infinite loop.  In fact, GCC does
  optimise it to an infinite loop if we compile the code with
  the <code>-O2</code> option.
</p>
<pre>
<samp><kbd># This never terminates!</kbd>
$ <kbd>gcc -O2 -std=c89 -Wall -Wextra -pedantic foo.c &amp;&amp; ./a.out</kbd></samp>
</pre>
<h2 id="puzzle">Puzzle<a href="#puzzle"></a></h2>
<p>
  Let us take a look at the puzzle now.
</p>
<div class="highlight">
<p>
  Add or modify exactly one operator in the following code such that
  it prints exactly 6 dots.
</p>
<pre>
<code>for (i = 0; i &lt; 6; i--) {
    printf(".");
}</code>
</pre>
</div>
<p>
  An obvious solution is to change <code>i--</code>
  to <code>i++</code>.
</p>
<pre>
<code>for (i = 0; i &lt; 6; i++) {
    printf(".");
}</code>
</pre>
<p>
  There are a few more solutions to this puzzle.  One of the solutions
  is very interesting.  We will discuss the interesting solution in
  detail below.
</p>
<h2 id="solutions">Solutions<a href="#solutions"></a></h2>
<p>
  <em><strong>Update on 02 Oct 2011:</strong> The puzzle has been
  solved in the <a href="comments/loopy-c-puzzle.html">comments</a>
  section.  We will discuss the solutions now.  If you want to think
  about the problem before you see the solutions, this is a good time
  to pause and think about it.  There are spoilers ahead.</em>
</p>
<p>
  Here is a list of some solutions:
</p>
<ul>
  <li>
    <code>for (i = 0; i &lt; 6; i++)</code>
  </li>
  <li>
    <code>for (i = 0; i &lt; 6; ++i)</code>
  </li>
  <li>
    <code>for (i = 0; -i &lt; 6; i--)</code>
  </li>
  <li>
    <code>for (i = 0; i + 6; i--)</code>
  </li>
  <li>
    <code>for (i = 0; i ^= 6; i--)</code>
  </li>
</ul>
<p>
  The last solution involving the bitwise XOR operation is not
  immediately obvious.  A little analysis is required to understand
  why it works.
</p>
<h2 id="generalisation">Generalisation<a href="#generalisation"></a></h2>
<p>
  Let us generalise the puzzle by replacing \( 6 \) in the loop with
  an arbitrary positive integer \( n.  \)  The loop in the last
  solution now becomes:
</p>
<pre>
<code>for (i = 0; i ^= n; i--) {
    printf(".");
}</code>
</pre>
<p>
  If we denote the value of the variable <code>i</code> set by the
  execution of <code>i ^= n</code> after \( k \) dots are printed as
  \( f(k), \) then

  \[
    f(k) =
      \begin{cases}
        0                       &amp; \text{if } k = 0, \\
        n \oplus (f(k - 1) - 1) &amp; \text{if } k \gt 1
      \end{cases}
  \]

  where \( k \) is a nonnegative integer, \( n \) is a positive
  integer and the symbol \( \oplus \) denotes bitwise XOR operation on
  two nonnegative integers.
</p>
<p>
  Note that \( f(0) \) represents the value of <code>i</code> set by
  the execution of <code>i ^= n</code> when no dots have been printed
  yet.
</p>
<p>
  If we can show that \( n \) is the least value of \( k \) for which
  \( f(k) = 0, \) it would prove that the loop terminates after
  printing \( n \) dots.
</p>
<p>
  We will see in the next section that for odd values of \( n, \)

  \[
    f(k) =
      \begin{cases}
        n &amp; \text{if } k \text{ is even}, \\
        1 &amp; \text{if } k \text{ is odd}.
      \end{cases}
  \]

  Therefore there is no value of \( k \) for which \( f(k) = 0 \) when
  \( n \) is odd.  As a result, the loop never terminates when \( n \)
  is odd.
</p>
<p>
  We will then see that for even values of \( n \) and \( 0 \leq k
  \leq n, \)

  \[
    f(k) = 0 \iff k = n.
  \]

  Therefore the loop terminates after printing \( n \) dots when
  \( n \) is even.
</p>
<h2 id="lemmas">Lemmas<a href="#lemmas"></a></h2>
<p>
  We will first prove a few lemmas about some interesting properties
  of the bitwise XOR operation.  We will then use it to prove the
  claims made in the previous section.
</p>
<!-- Lemma 1 -->
<p>
<strong>Lemma 1.</strong>
<em>
  For an odd positive integer \( n, \)

  \[
    n \oplus (n - 1) = 1
  \]

  where the symbol \( \oplus \) denotes bitwise XOR operation on two
  nonnegative integers.
</em>
</p>
<p>
  <em>Proof.</em>  Let the binary representation of \( n \) be \( b_m
  \dots b_1 b_0 \) where \( m \) is a nonnegative integer and
  \( b_m \) represents the most significant nonzero bit of \( n.  \)
  Since \( n \) is an odd number, \( b_0 = 1.  \)

  Thus \( n \) may be written as

  \[
    b_m \dots b_1 1.
  \]

  As a result \( n - 1 \) may be written as

  \[
    b_m \dots b_1 0.
  \]

  The bitwise XOR of both binary representations is \( 1.  \)
</p>
<!-- Lemma 2 -->
<p>
  <strong>Lemma 2.</strong>
  <em>
    For a nonnegative integer \( n, \)

    \[
      n \oplus 1 =
      \begin{cases}
      n + 1 &amp; \text{if } n \text{ is even}, \\
      n - 1 &amp; \text{if } n \text{ is odd}.
      \end{cases}
    \]

    where the symbol \( \oplus \) denotes bitwise XOR operation on two
    nonnegative integers.
  </em>
</p>
<p>
  <em>Proof.</em>  Let the binary representation of \( n \) be \( b_m
  \dots b_1 b_0 \) where \( m \) is a nonnegative integer and
  \( b_m \) represents the most significant nonzero bit of \( n.  \)
</p>
<p>
  If \( n \) is even, \( b_0 = 0.  \)  In this case, \( n \) may be
  written as \( b_m \dots b_1 0.  \)  Thus \( n \oplus 1 \) may be
  written as \( b_m \dots b_1 1.  \)  Therefore \( n \oplus 1 = n + 1.  \)
</p>
<p>
  If \( n \) is odd, \( b_0 = 1.  \)  In this case, \( n \) may be
  written as \( b_m \dots b_1 1.  \)  Thus \( n \oplus 1 \) may be
  written as \( b_m \dots b_1 0.  \)  Therefore \( n \oplus 1 = n - 1.  \)
</p>
<p>
  Note that for odd \( n, \) lemma 1 can also be derived as a
  corollary of lemma 2 in this manner:

  \[
    k \oplus (k - 1)
    = k \oplus (k \oplus 1)
    = (k \oplus k) \oplus 1
    = 0 \oplus 1
    = 1.
  \]
</p>
<!-- Lemma 3 -->
<p>
  <strong>Lemma 3.</strong>
  <em>
    If \( x \) is an even nonnegative integer and \( y \) is an odd
    positive integer, then \( x \oplus y \) is odd, where the symbol
    \( \oplus \) denotes bitwise XOR operation on two nonnegative
    integers.
  </em>
</p>
<p>
  <em>Proof.</em>  Let the binary representation of \( x \) be \(
  b_{xm_x} \dots b_{x1} b_{x0} \) and that of \( y \) be \( b_{ym_y}
  \dots b_{y1} b_{y0} \) where \( m_x \) and \( m_y \) are nonnegative
  integers and \( b_{xm_x} \) and \( b_{xm_y} \) represent the most
  significant nonzero bits of \( x \) and \( y \) respectively.
</p>
<p>
  Since \( x \) is even, \( b_{x0} = 0.  \)  Since \( y \) is odd, \(
  b_{y0} = 1.  \)
</p>
<p>
  Let \( z = x \oplus y \) with a binary representation of \( b_{zm_z}
  \dots b_{z1} b_{z0} \) where \( m_{zm_z} \) is a nonnegative integer
  and \( b_{zm_z} \) is the most significant nonzero bit of \( z.  \)
</p>
<p>
  We get \( b_{z0} = b_{x0} \oplus b_{y0} = 0 \oplus 1 = 1.  \)
  Therefore \( z \) is odd.
</p>
<h2 id="theorems">Theorems<a href="#theorems"></a></h2>
<!-- Theorem 1 -->
<p>
<strong>Theorem 1.</strong>
<em>
  Let \( \oplus \) denote bitwise XOR operation on two nonnegative
  integers and

  \[
    f(k) =
    \begin{cases}
    n                        &amp; \text{if } n = 0, \\
    n \oplus (f(n - 1) - 1)  &amp; \text{if } n \gt 1.
    \end{cases}
  \]

  where \( k \) is a nonnegative integer and \( n \) is an odd
  positive integer.  Then

  \[
    f(k) =
    \begin{cases}
    n &amp; \text{if } k \text{ is even}, \\
    1 &amp; \text{if } k \text{ is odd}.
    \end{cases}
  \]
</em>
</p>
<p>
  <em>Proof.</em>  This is a proof by mathematical induction.  We have
  \( f(0) = n \) by definition.  Therefore the base case holds good.
</p>
<p>
  Let us assume that \( f(k) = n \) for any even \( k \) (induction
  hypothesis).  Let \( k' = k + 1 \) and \( k'' = k + 2.  \)
</p>
<p>
  If \( k \) is even, we get

  \begin{align*}
    f(k')  &amp; = n \oplus (f(k) - 1)  &amp;&amp; \text{(by definition)} \\
           &amp; = n \oplus (n - 1)     &amp;&amp; \text{(by induction hypothesis)} \\
           &amp; = 1                    &amp;&amp; \text{(by lemma 1)},\\
    f(k'') &amp; = n \oplus (f(k') - 1) &amp;&amp; \text{(by definition)} \\
           &amp; = n \oplus (1 - 1)     &amp;&amp; \text{(since \( f(k') = 1 \))} \\
           &amp; = n \oplus 0 \\
           &amp; = n.
  \end{align*}
</p>
<p>
  Since \( f(k'') = n \) and \( k'' \) is the next even number after
  \( k, \) the induction step is complete.  The induction step shows
  that for every even \( k, \) \( f(k) = n \) holds good.  It also
  shows that as a result of \( f(k) = n \) for every even \( k, \) we
  get \( f(k') = 1 \) for every odd \( k'.  \)
</p>
<!-- Theorem 2 -->
<p>
  <strong>Theorem 2.</strong>
  <em>
    Let \( \oplus \) denote bitwise XOR operation on two nonnegative
    integers and

    \[
      f(k) =
        \begin{cases}
          n                        &amp; \text{if } n = 0, \\
          n \oplus (f(n - 1) - 1)  &amp; \text{if } n \gt 1.
        \end{cases}
    \]

    where \( k \) is a nonnegative integer, \( n \) is an even
    positive integer and \( 0 \leq k \leq n.  \)  Then

   \[
     f(k) = 0 \iff k = n.
   \]
</em>
</p>
<p>
  <em>Proof.</em>  We will first show by the principle of mathematical
  induction that for even \( k, \) \( f(k) = n - k.  \)  We have \(
  f(0) = n \) by definition, so the base case holds good.  Now let us
  assume that \( f(k) = n - k \) holds good for any even \( k \) where
  \( 0 \leq k \leq n \) (induction hypothesis).
</p>
<p>
  Since \( n \) is even (by definition) and \( k \) is even (by
  induction hypothesis), \( f(k) = n - k \) is even.  As a result, \(
  f(k) - 1 \) is odd.  By lemma 3, we conclude that \( f(k + 1) = n
  \oplus (f(k) - 1) \) is odd.
</p>
<p>
  Now we perform the induction step as follows:

  \begin{align*}
    f(k + 2) &amp; = n \oplus (f(k + 1) - 1)
                     &amp;&amp; \text{(by definition)} \\
             &amp; = n \oplus (f(k + 1) \oplus 1)
                     &amp;&amp; \text{(by lemma 2 for odd \( n \))} \\
             &amp; = n \oplus ((n \oplus (f(k) - 1)) \oplus 1)
                     &amp;&amp; \text{(by definition)} \\
             &amp; = (n \oplus n ) \oplus ((f(k) - 1) \oplus 1)
                     &amp;&amp; \text{(by associativity of XOR)} \\
             &amp; = 0 \oplus ((f(k) - 1) \oplus 1) \\
             &amp; = (f(k) - 1) \oplus 1 \\
             &amp; = (f(k) - 1) - 1
                     &amp;&amp; \text{(from lemma 2 for odd \( n \))} \\
             &amp; = f(k) - 2 \\
             &amp; = n - k - 2
                     &amp;&amp; \text{(by induction hypothesis).}
  \end{align*}

  This completes the induction step and proves that \( f(k) = n - k \)
  for even \( k \) where \( 0 \leq k \leq n.  \)
</p>
<p>
  We have shown above that \( f(k) \) is even for every even \( k \)
  where \( 0 \leq k \leq n \) which results in \( f(k + 1) \) as odd
  for every odd \( k + 1.  \)  This means that \( f(k) \) cannot be \(
  0 \) for any odd \( k.  \)  Therefore \( f(k) = 0 \) is possible only
  even \( k.  \)  Solving \( f(k) = n - k = 0, \) we conclude that \(
  f(k) = 0 \) if and only if \( k = n.  \)
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/loopy-c-puzzle.html">Read on website</a> |
  <a href="https://susam.net/tag/c.html">#c</a> |
  <a href="https://susam.net/tag/programming.html">#programming</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>From Tower of Hanoi to Counting Bits</title>
<link>https://susam.net/from-tower-of-hanoi-to-counting-bits.html</link>
<guid isPermaLink="false">xfjry</guid>
<pubDate>Sun, 25 Sep 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[

<h2 id="tower-of-hanoi">Tower of Hanoi<a href="#tower-of-hanoi"></a></h2>
<p>
  A few weeks ago, I watched
  <a href="http://www.imdb.com/title/tt1318514/">Rise of the Planet of
  the Apes</a>.  The movie showed a genetically engineered chimpanzee
  trying to solve a puzzle involving four discs, initially stacked in
  ascending order of size on one of three pegs.  The chimpanzee was
  supposed to transfer the entire stack to one of the other pegs,
  moving only one disc at a time and never placing a larger disc on a
  smaller one.
</p>
<p>
  The problem was called the <em>Lucas' Tower</em> in the movie.  I
  have always known this problem as the <em>Tower of Hanoi</em>
  puzzle.  The minimum number of moves required to solve the problem
  is \( 2^n - 1 \) where \( n \) is the number of discs.  In the
  movie, the chimpanzee solved the problem in 15 moves, the minimum
  number of moves required when there are 4 discs.
</p>
<p>
  Referring to the problem as the Lucas' Tower made me wonder why it
  was called so instead of calling it the Tower of Hanoi.  I guessed
  it was probably because the puzzle was invented by the French
  mathematician &Eacute;douard Lucas.  Later when I checked
  the <a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">Wikipedia
  article on this topic</a>, I realised I was right about this.  In
  fact, the article mentioned that there is another version of this
  problem known as <em>the Tower of Brahma</em> that involves 64 discs
  made of pure gold and three diamond needles.  According to a legend,
  a group of Brahmin priests are working at the problem and the world
  will end when the last move of the puzzle is completed.  Now, even
  if they make one move every second, it'll take
  18&#8239;446&#8239;744&#8239;073&#8239;709&#8239;551&#8239;615
  seconds to complete the puzzle.  That's about 585 billion years.
  The article also had this nice animation of a solution involving
  four discs.
</p>
<figure>
  <img src="files/blog/tower-of-hanoi-animation.gif"
       alt="Animated solution of the Tower of Hanoi puzzle">
  <figcaption>
    Animated solution of the Tower of Hanoi puzzle created by
    Andr&eacute; Karwath
    (<a
    href="https://commons.wikimedia.org/wiki/File:Tower_of_Hanoi_4.gif">original
    source</a>)
  </figcaption>
</figure>
<p>
  I'll not discuss the solution of this puzzle in this blog post.
  There are plenty of articles on the web including the Wikpedia
  article that describes why it takes a minimum of \( 2^n - 1 \) moves
  to solve the puzzle when there are \( n \) discs involved.  In this
  post, I'll talk about an interesting result I discovered while
  playing with this puzzle one afternoon.
</p>
<h2 id="binary-numbers">Binary Numbers<a href="#binary-numbers"></a></h2>
<p>
  If we denote the minimum number of moves required to solve the Tower
  of Hanoi puzzle as \( T_n, \) then \( T_n \) when expressed in
  binary is the largest possible \( n \)-bit integer.  For example, \(
  T_4 = 15_{10} = 1111_{2}.  \)  That makes sense because \( T_n = 2^n
  - 1 \) indeed represents the maximum possible \( n \)-bit integer
  where all \( n \) bits are set to \( 1.  \)
</p>
<p>
  While playing with different values of \( T_n \) for different
  values of \( n, \) I stumbled upon an interesting result which I
  will pose as a problem in a later section below.
</p>
<h2 id="assumptions">Assumptions<a href="#assumptions"></a></h2>
<p>
  Before proceeding to the problem, let us define the bit-length of an
  integer to eliminate any possibility of ambiguity:
</p>
<ul>
  <li>
    A positive integer \( x \) is said to be an \( n \)-bit integer if
    and only if the minimum number of bits required to express the
    integer is \( n, \) or equivalently, \( \lfloor \log_2 x \rfloor +
    1 = n.  \)
  </li>
</ul>
<p>
  We will be dealing with arbitrary precision integers (bignums) in
  the problem, so let us also make a few assumptions:
</p>
<ul>
  <li>
    Addition or subtraction of an \( m \)-bit integer and an \( n \)-bit
    integer (\( m \le n \)) takes \( O(n) \) time.
  </li>
  <li>
    Counting the number of \( 1 \)-bits in an \( n \)-bit integer takes
    \( O(n) \) time.
  </li>
</ul>
<p>
  The definition along with the assumptions lead to the following
  conclusions:
</p>
<ul>
  <li>
    Adding or subtracting two integers \( a \) and \( b \) takes \(
    O(\log(\max(a, b))) \) time.
  </li>
  <li>
    Counting the number of \( 1 \)-bits in an integer \( a \) takes
    \( O(\log(a)) \) time.
  </li>
</ul>
<h2 id="binary-puzzle">Binary Puzzle<a href="#binary-puzzle"></a></h2>
<div class="highlight">
  What is the most efficient way to compute the number of \( 1 \)-bits
  in

  \[
    T_1 + T_2 + \dots + T_n
  \]

  where \( n \) is a positive integer, each \( T_i = 2^i - 1 \) for
  integers \( 1 \le i \le n \) and efficiency is measured in terms of
  time and space complexity?
</div>
<p>
  The naive approach involves adding all the \( n \) integers and
  counting the number of \( 1 \)-bits in the sum.  It takes
  \( O(n^2) \) time to add the \( n \) integers.  The sum is an \( (n
  + 1) \)-bit integer, so it takes \( O(n) \) time to count the number
  of \( 1 \)-bits in the sum.  Since the sum is \( (n + 1) \)-bit
  long, it takes \( O(n) \) memory to store the sum.  If \( n \) is as
  large as, say, \( 2^{64}, \) it takes 2 exbibytes plus one more bit
  of memory to store the sum.
</p>
<p>
  We can arrive at a much more efficient solution if we look at what
  the binary representation of the sum looks like.  We first arrive at
  a closed-form expression for the sum:

  \begin{align*}
    T_1 + T_2 + \dots + T_n
    &amp; = (2 - 1) + (2^2 - 1) + \dots + (2^n - 1) \\
    &amp; = (2 + 2^2 + \dots + 2^n) - n \\
    &amp; = (2^{n + 1} - 2) - n \\
    &amp; = (2^{n + 1} - 1) - (n + 1).
  \end{align*}

  Now \( 2^{n + 1} - 1 \) is an \( (n + 1) \)-bit number with all its
  bits set to \( 1.  \)  Subtracting \( n + 1 \) from it is equivalent
  to performing the following operation with their binary
  representations: for each \( 1 \)-bit in \( (n + 1), \) set the
  corresponding bit in \( (2^{n + 1} - 1) \) to \( 0.  \)
</p>
<p>
  If we use the notation \( \text{bitcount}(n) \) to represent the
  number of \( 1 \)-bits in the binary representation of a positive
  integer \( n, \) then we get

  \[
    \text{bitcount}(T_1 + T_2 + \dots + T_n)
    = (n + 1) - \text{bitcount}(n + 1).
  \]

  Now the computation involves counting the number of \( 1 \)-bits in
  \( n + 1 \) which takes \( O(\log n) \) and subtracting this count
  from \( n + 1 \) which also takes \( O(\log n) \) time.  Further,
  the largest number that we keep in memory is \( n + 1 \) which
  occupies \( O(\log n) \) space.  Therefore, the entire problem can
  be solved in \( O(\log n) \) time with \( O(\log n) \) space.
</p>
<p>
  What would have taken 2 exbibytes and 1 bit of memory with the naive
  approach requires 8 bytes and 1 bit of memory now.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/from-tower-of-hanoi-to-counting-bits.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Langford Pairing</title>
<link>https://susam.net/langford-pairing.html</link>
<guid isPermaLink="false">dobze</guid>
<pubDate>Sat, 17 Sep 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<h2 id="permutation-problem">Permutation Problem<a href="#permutation-problem"></a></h2>
<p>
  A few days ago, I came across this problem:
</p>
<div class="highlight">
  <p>
    There is a sequence of \( 2n \) numbers where each natural number
    from \( 1 \) to \( n \) is repeated twice, i.e.

    \[
      (1, 1, 2, 2, \dots, n, n).
    \]

    Find a permutation of this sequence such that for each \( k \)
    where \( 1 \le k \le n, \) there are \( k \) numbers between two
    occurrences of \( k \) in the permutation.
  </p>
</div>
<h2 id="getting-started">Getting Started<a href="#getting-started"></a></h2>
<p>
  In combinatorics, this problem has a name: <em>Langford's
  problem</em>.  A permutation of \( (1, 1, 2, 2, \dots, n, n) \) that
  satisfies the condition given in the probem is known as
  a <em>Langford pairing</em> or <em>Langford sequence</em>.
</p>
<p>
  For small \( n, \) say \( n = 4, \) Langford pairings can be
  obtained easily by trial and error: \( (4, 1, 3, 1, 2, 4, 3, 2).  \)
  What if \( n \) is large?  We need an algorithm to find a
  permutation that solves the problem in that case.
</p>
<p>
  There is another question to consider: Is there a solution for every
  possible \( n?  \)  One can easily see that there are no Langford
  pairings for \( n = 1 \) and \( n = 2, \) i.e. the sequences \( (1,
  1) \) and \( (1, 1, 2, 2) \) have no Langford pairings.
</p>
<p>
  We need to understand two things:
</p>
<ol>
  <li>
    For what values of \( n \) do Langford pairings exist?
  </li>
  <li>
    For the values of \( n \) for which Langford pairings exist, how
    do we find the Langford pairings?
  </li>
</ol>
<p>
  A simple Python 3 program I wrote to find Langford pairings for
  small values of \( n \) offers some clues.  Here is the program:
</p>
<pre>
<code>def find_solutions(n, s=None):
    # If called from top-level (s=None), create a list of 2n zero
    # values.  Zeroes represent unoccupied cells.
    if s is None:
        s = [0] * (2 * n)

    # Next number to be placed.
    m = max(s) + 1

    # For each i, try to place m at s[i] and s[i + m + 1].
    for i in range(2 * n - m - 1):

        # If s[i] and s[i + m + 1] are unoccupied, ...
        if s[i] == s[i + m + 1] == 0:

            # first place m at s[i] and s[i + m + 1].
            s[i] = s[i + m + 1] = m

            # If m is the last number to be placed, ...
            if m == n:
                # then a solution has been found; yield it.
                yield s[:]
            else:
                # else try to place the next number.
                yield from find_solutions(n, s)

            # Undo placement of m.
            s[i] = s[i + m + 1] = 0


# Count solutions for 1 &lt;= n &lt;= 12.
for n in range(1, 13):
    count = sum(1 for s in find_solutions(n))
    print('n = {:2} =&gt; {:6} solutions'.format(n, count))</code>
</pre>
<p>
  It takes a few minutes for this program to run.  Here is the output
  of this program:
</p>
<pre>
<samp>$ <kbd>python3 langford.py</kbd>
n =  1 =&gt;      0 solutions
n =  2 =&gt;      0 solutions
n =  3 =&gt;      2 solutions
n =  4 =&gt;      2 solutions
n =  5 =&gt;      0 solutions
n =  6 =&gt;      0 solutions
n =  7 =&gt;     52 solutions
n =  8 =&gt;    300 solutions
n =  9 =&gt;      0 solutions
n = 10 =&gt;      0 solutions
n = 11 =&gt;  35584 solutions
n = 12 =&gt; 216288 solutions</samp>
</pre>
<p>
  Note that we always talk about Langford pairings in plural in this
  post.  That's because either a sequence has no Langford pairings or
  it has two or more Langford pairings.  There is never a sequence
  that has only one Langford pairing.  That's because if we find at
  least one Langford pairing for a sequence, the reverse of that
  Langford pairing is also a Langford pairing.  Therefore, when
  Langford pairings exist for a sequence, they must at least be two in
  number.  Since they occur in pairs, they are always even in number.
  This is why we don't have to write "one or more Langford pairings"
  in this post.  We can always write "Langford pairings" instead.
</p>
<h2 id="conjecture">Conjecture<a href="#conjecture"></a></h2>
<p>
  From the output above, we can form a conjecture:
</p>
<div class="highlight">
  The sequence \( (1, 1, 2, 2, \dots, n, n) \) has Langford pairings
  if and only if \( n \equiv 0 \pmod{4} \) or
  \( n \equiv 3 \pmod{4}.  \)
</div>
<p>
  For convenience, let us denote the sequence \( (1, 1, 2, 2, \dots,
  n, n) \) as \( S_n.  \)  We will now prove the above conjecture in two
  parts:
</p>
<ol>
  <li>
    We will first show that the condition that either \( n \equiv 0
    \pmod{4} \) or \( n \equiv 3 \pmod{4} \) must hold is a
    <em>necessary</em> condition for the sequence \( S_n \) to have
    Langford pairings.
  </li>
  <li>
    We will then show that the condition that either \( n \equiv 0
    \pmod{4} \) or \( n \equiv 3 \pmod{4} \) must hold is a
    <em>sufficient</em> condition for the sequence \( S_n \) to have
    Langford pairings.
  </li>
</ol>
<h2 id="necessity">Necessity<a href="#necessity"></a></h2>
<p>
  Let \( S_n = (1, 1, 2, 2, \dots, n, n) \) be a sequence such that it
  has Langford pairings.  Let us pick an arbitrary Langford pairing \(
  s \) of \( S_n \) and split this Langford pairing \( s \) into two
  mutually exclusive subsequences \( s_1 \) and \( s_2 \) such that:
</p>
<ul>
  <li>
    \( s_1 \) contains all numbers in odd numbered positions and
  </li>
  <li>
    \( s_2 \) contains all numbers in even numbered positions.
  </li>
</ul>
<p>
  For example, if we pick \( s = (1, 7, 1, 2, 5, 6, 2, 3, 4, 7, 5, 3,
  6, 4) \) which is a Langford pairing of \( S_7, \) we split \( s \)
  into

  \begin{align*}
    s_1 &amp; = (1, 1, 5, 2, 4, 5, 6), \\
    s_2 &amp; = (7, 2, 6, 3, 7, 3, 4).
  \end{align*}
</p>
<p>
  We can make a few observations:
</p>
<ol>
  <li>
    Both occurrences of an even number do not occur in the same
    subsequence.
  </li>
  <li>
    There are \( \left\lfloor \frac{n}{2} \right\rfloor \) even
    numbers in each subsequence.
  </li>
  <li>
    Both occurrences of an odd number occur in the same subsequence.
  </li>
  <li>
    There are \( \left\lceil \frac{n}{2} \right\rceil \) odd numbers
    in each subsequence.
  </li>
</ol>
<p>
  Do these observations hold good for every Langford pairing of any
  aribrary \( S_n \) for every positive integer value of \( n?  \)
  Yes, they do.  We will now prove them one by one:
</p>
<ol>
  <li>
    <p>
      Let us consider an even number \( k \) from a Langford pairing.
      If the first occurrence of \( k \) lies at the \( i \)th
      position in the pairing, then its second occurrence lies at the
      \( (i + k + 1) \)th position.  Since \( k \) is even, \( i \)
      and \( i + k + 1 \) have different parities, i.e. if \( i \) is
      odd, then \( i + k + 1 \) is even and vice versa.  Therefore, if
      the first occurrence of \( k \) lies at an odd numbered
      position, its second occurrence must lie at an even numbered
      position and vice versa.  Thus one occurrence of \( k \) must
      belong to \( s_1 \) and the other must belong to \( s_2.  \)
      This proves the first observation.
    </p>
  </li>
  <li>
    <p>
      The number of even numbers between \( 1 \) and \( n, \)
      inclusive, is \( \left\lfloor \frac{n}{2} \right\rfloor.  \)
      Each of these even numbers has been split equally between
      \( s_1 \) and \( s_2.  \)  This proves the second observation.
    </p>
  </li>
  <li>
    <p>
      Now let us consider an odd number \( k \) from a Langford
      pairing.  If the first occurrence of \( k \) lies at the
      \( i \)th position in the pairing, then its second occurrence lies at
      the \( (i + k + 1) \)th position.  Since \( k \) is odd, \( i \)
      and \( i + k + 1 \) have the same parity.  Therefore, either
      both occurrences of \( k \) belong to \( s_1 \) or both belong
      to \( s_2.  \)  This proves the third observation.
    </p>
  </li>
  <li>
    <p>
      Each subsequence, \( s_1 \) or \( s_2 \) has \( n \) numbers
      because we split a Langford pairing \( s \) with \( 2n \)
      numbers equally between the two subsequences.  We have shown
      that each subsequence has \( \left\lfloor \frac{n}{2}
      \right\rfloor \) even numbers.  Therefore the number of odd
      numbers in each subsequence is \( n - \left\lfloor \frac{n}{2}
      \right\rfloor = \left\lceil \frac{n}{2} \right\rceil.  \)
    </p>
  </li>
</ol>
<p>
  From the third observation, we know that the odd numbers always
  occur in pairs in each subsequence because both occurrences of an
  odd number occur together in the same subsequence.  Therefore, the
  number of odd numbers in each subsequence must be even.  Since the
  number of odd numbers in each subsequence is \( \left\lceil
  \frac{n}{2} \right\rceil \) as proven for the fourth observation, we
  conclude that \( \left\lceil \frac{n}{2} \right\rceil \) must be
  even.
</p>
<p>
  Now let us see what must \( n \) be like so that \( \left\lceil
  \frac{n}{2} \right\rceil \) is even.
</p>
<p>
  Let us express \( n \) as \( 4q + r \) where \( q \) is a
  nonnegative integer and \( r \in \{0, 1, 2, 3\}.  \)
</p>
<ul>
  <li>
    If \( n = 4q + 0, \) then\( \left\lceil \frac{n}{2} \right\rceil =
    \left\lceil \frac{4q}{2} \right\rceil = 2q.  \)
  </li>
  <li>
    If \( n = 4q + 1, \) then\( \left\lceil \frac{n}{2} \right\rceil =
    \left\lceil \frac{4q + 1}{2} \right\rceil = 2q + 1.  \)
  </li>
  <li>
    If \( n = 4q + 2, \) then\( \left\lceil \frac{n}{2} \right\rceil =
    \left\lceil \frac{4q + 2}{2} \right\rceil = 2q + 1.  \)
  </li>
  <li>
    If \( n = 4q + 3, \) then\( \left\lceil \frac{n}{2} \right\rceil =
    \left\lceil \frac{4q + 3}{2} \right\rceil = 2q + 2.  \)
  </li>
</ul>
<p>
  We see that \( \left\lceil \frac{n}{2} \right\rceil \) is even if
  and only if either \( n \equiv 0 \pmod{4} \) or \( n \equiv 3
  \pmod{4} \) holds good.
</p>
<p>
  We have shown that if a sequence \( S_n \) has Langford pairings,
  then either \( n \equiv 0 \pmod{4} \) or \( n \equiv 3 \pmod{4}.  \)
  This proves the necessity of the condition.
</p>
<h2 id="sufficiency">Sufficiency<a href="#sufficiency"></a></h2>
<p>
  If we can show that we can construct a Langford pairing for \( (1,
  1, 2, 2, \dots, n, n ) \) for both cases, i.e. \( n \equiv 0
  \pmod{4} \) as well as \( n \equiv 3 \pmod{4}, \) then it would
  complete the proof.
</p>
<h3 id="notation">Notation<a href="#notation"></a></h3>
<p>
  Let us define some notation to make it easier to write sequences we
  will use in the construction of a Langford pairing:
</p>
<ul>
  <li>
    <p>
      \( (i \dots j)_{even} \) denotes a sequence of even positive
      integers from \( i \) to \( j, \) exclusive, arranged in
      ascending order.
    </p>
    <p>
      For example, \( (1 \dots 8)_{even} = (2, 4, 6) \) and \( (1
      \dots 2)_{even} = ().  \)
    </p>
  </li>
  <li>
    <p>
      \( (i \dots j)_{odd} \) denotes a sequence of odd positive
      integers from \( i \) to \( j, \) exclusive, arranged in
      ascending order.
    </p>
    <p>
      For example, \( (1 \dots 8)_{odd} = (3, 5, 7) \) and \( (1 \dots
      3)_{odd} = ().  \)
    </p>
  </li>
  <li>
    <p>
      \( s' \) denotes the reverse of the sequence \( s.  \)
    </p>
    <p>
      For example, for a sequence \( s = (2, 3, 4, 5), \) we have \(
      s' = (2, 3, 4, 5)' = (5, 4, 3, 2).  \)
    </p>
  </li>
  <li>
    <p>
      \( s \cdot t \) denotes the concatenation of sequences \( s \)
      and \( t.  \)
    </p>
    <p>
      For example, for sequences \( s = (1, 2, 3) \) and
      \( t = (4, 5), \) we have \( s \cdot t = (1, 2, 3) \cdot (4, 5)
      = (1, 2, 3, 4, 5).  \)
    </p>
  </li>
</ul>
<p>
  Let \( x = \left\lceil \frac{n}{4} \right\rceil.  \)  Therefore,

  \[
    x =
    \begin{cases}
      \frac{n}{4}     &amp; \text{if } n \equiv 0 \pmod{4}, \\
      \frac{n + 1}{4} &amp; \text{if } n \equiv 3 \pmod{4}.
    \end{cases}
  \]

  Let us now define the following eight sequences:

  \begin{align*}
    a &amp; = (2x - 1), \\
    b &amp; = (4x - 2), \\
    c &amp; = (4x - 1), \\
    d &amp; = (4x), \\
    p &amp; = (0 \dots a)_{odd}, \\
    q &amp; = (0 \dots a)_{even}, \\
    r &amp; = (a \dots b)_{odd}, \\
    s &amp; = (a \dots b)_{even}.
  \end{align*}

  Now let us construct a Langford pairing for both cases: \( n \equiv
  0 \pmod{4} \) and \( n \equiv 3 \pmod{4}.  \)  We will do this case by
  case.
</p>
<h3 id="case-1">Case \( n \equiv 0 \pmod{4} \)<a href="#case-1"></a></h3>
<p>
  If \( n \equiv 0 \pmod{4}, \) we construct a Langford pairing with
  the following concatenation:

  \[
    s' \cdot
    p' \cdot
    b  \cdot
    p  \cdot
    c  \cdot
    s  \cdot
    d  \cdot
    r' \cdot
    q' \cdot
    b  \cdot
    a  \cdot
    q  \cdot
    c  \cdot
    r  \cdot
    a  \cdot
    d.
  \]

  Let us do an example with \( n = 12.  \)
</p>
<p>
  For \( n = 12, \) we get \( x = \frac{n}{4} = 3.  \)  Therefore,

  \begin{alignat*}{2}
    a &amp; = (2x - 1)           &amp;&amp; = (5), \\
    b &amp; = (4x - 2)           &amp;&amp; = (10), \\
    c &amp; = (4x - 1)           &amp;&amp; = (11), \\
    d &amp; = (4x)               &amp;&amp; = (12), \\
    p &amp; = (0 \dots a)_{odd}  &amp;&amp; = (1, 3), \\
    q &amp; = (0 \dots a)_{even} &amp;&amp; = (2, 4), \\
    r &amp; = (a \dots b)_{odd}  &amp;&amp; = (7, 9), \\
    s &amp; = (a \dots b)_{even} &amp;&amp; = (6, 8).
  \end{alignat*}

  After performing the specified concatenation, we get the following
  Langford pairing:

  \[
    (
      8, 6, 3, 1, 10, 1, 3, 11, 6, 8, 12, 9,
      7, 4, 2, 10, 5, 2, 4, 11, 7, 9, 5, 12
    ).
  \]

  Let us now show that any construction of a sequence as per this
  specified concatenation always leads to a Langford pairing.
</p>
<p>
  Each sequence \( a, \) \( b, \) \( c \) and \( d \) has one number
  each.  Each sequence \( p, \) \( q, \) \( r \) and \( s \) has \( x
  - 1 \) numbers each.
</p>
<p>
  The two occurrences of \( a \) have \( q, \) \( c \) and \( r \) in
  between, i.e.

  \[
    (x - 1) + 1 + (x - 1) = 2x - 1 = a
  \]

  numbers in between.  Similarly, we can check that the two
  occurrences of \( b \) have \( b \) numbers in between; likewise for
  \( c \) and \( d.  \)
</p>
<p>
  The two occurrences of \( 1 \) belong to \( p \) and \( p'.  \)
  Between these two occurrences of \( 1, \) we have only one element
  of \( b.  \)
</p>
<p>
  We now show that for each \( k \) in \( p, \) there are \( k \)
  numbers in between.  For any \( k \) in \( p, \) there is the
  sequence \( (0..k)'_{odd} \cdot b \cdot (0..k)_{odd} \) in between
  the two occurrences of \( k, \) i.e, there are \( \frac{k - 1}{2} +
  1 + \frac{k - 1}{2} = k \) numbers in between.  Similarly, we can
  check that for each \( k \) in \( q, \) there are \( k \) numbers in
  between.
</p>
<p>
  Finally, we show that for each \( k \) in \( r, \) there are \( k \)
  numbers in between.  For any \( k \) in \( r, \) there is the
  sequence \( (a..k)'_{odd} \cdot q' \cdot b \cdot a \cdot q \cdot c
  \cdot (a..k)_{odd} \) in between the two occurrences of \( k.  \)
  Note that \( a \) is odd, so the number of integers in this sequence
  is

  \[
    \frac{k - a - 2}{2} + (x - 1) + 1 + 1 + (x - 1) + 1 + \frac{k - a - 2}{2}.
  \]

  Simplifying the above expression and then substituting
  \( a = 2x - 1, \) we get

  \[
    k - a - 2 + 2x + 1 = k.
  \]

  Similarly, we can check that for each \( k \) in \( s, \) there are
  \( k \) numbers in between.
</p>
<h3 id="case-2">Case \( n \equiv 3 \pmod{4} \)<a href="#case-2"></a></h3>
<p>
  If \( n \equiv 3 \pmod{4}, \) we construct a Langford pairing with
  the following concatenation:

  \[
    s' \cdot
    p' \cdot
    b  \cdot
    p  \cdot
    c  \cdot
    s  \cdot
    a  \cdot
    r' \cdot
    q' \cdot
    b  \cdot
    a  \cdot
    q  \cdot
    c  \cdot
    r.
  \]

  Note that this concatenation of sequences is almost the same as the
  concatenation in the previous section with the following two
  differences:
</p>
<ul>
  <li>
    The sequence \( d \) is not used here.
  </li>
  <li>
    The sequence \( a \) in the end has moved to replace the sequence
    \( d \) in the middle of the concatenation.
  </li>
</ul>
<p>
  Let us do an example with \( n = 11.  \)  For \( n = 12, \) we get \(
  x = \frac{n + 1}{4} = 3.  \)  Therefore, the sequences \( a, \) \(
  b, \) \( c, \) \( p, \) \( q, \) \( r \) and \( s \) are same as
  those in the last example in the previous section.  After performing
  the specified concatenation, we get the following Langford pairing:

  \[
    (
      8, 6, 3, 1, 10, 1, 3, 11, 6, 8, 5,
      9, 7, 4, 2, 10, 5, 2, 4, 11, 7, 9
    ).
  \]

  We can verify that for every \( k \) in a Langford pairing
  constructed in this manner, there are \( k \) numbers in between.
  The verification steps are similar to what we did in the previous
  section.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/langford-pairing.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/combinatorics.html">#combinatorics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Magical Chameleons Puzzle</title>
<link>https://susam.net/magical-chameleons-puzzle.html</link>
<guid isPermaLink="false">fuoog</guid>
<pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  An island contained chameleons of three different colours: red,
  green and blue.  The chameleons were studied by some biologists and
  they found that when two chameleons of different colours met they
  changed their colours to the third one.  They found that there were
  2000 red chameleons and 3000 green ones on the day they counted
  them.  They didn't get time to count the number of blue chameleons.
</p>
<p>
  When the biologists returned to the island two months later they
  found that all chameleons were red in colour.  They were certain
  that no chameleons died because they did not find dead remains of
  any chameleon.  What does it say about the number of blue chameleons
  on the day the biologists counted the number of red and green
  chameleons?
</p>
<p>
  See the comments page for the solution.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/magical-chameleons-puzzle.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Calendar Cubes Puzzle</title>
<link>https://susam.net/calendar-cubes-puzzle.html</link>
<guid isPermaLink="false">yoksw</guid>
<pubDate>Sun, 12 Jun 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  How many different ways are there to assign the ten digits of Arabic
  numerals (0 to 9) to each face of two cubes to ensure that we can
  arrange both cubes on any day such that the front faces of the cubes
  show the current day of the month?
</p>
<p>
  For example, on February 9 the cubes would be placed side by side
  such that the front face of the cube on the left side shows 0 and
  that of the one on the right side shows 9.
</p>
<p>
  Two ways of assigning the digits to the faces of the cubes are
  considered different if and only if it is not possible to get one
  assignment from the other by performing one or more of the following
  operrations:
</p>
<ol>
  <li>
    Rotating (reorienting) the digits with respect to the faces they
    belong to.
  </li>
  <li>
    Rotating the cubes.
  </li>
  <li>
    Swapping the cubes.
  </li>
</ol>
<p>
  See the comments page for the solution.
</p>

<!-- ### -->
<p>
  <a href="https://susam.net/calendar-cubes-puzzle.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>URL in C</title>
<link>https://susam.net/url-in-c.html</link>
<guid isPermaLink="false">vnjtr</guid>
<pubDate>Fri, 03 Jun 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  Here is an interesting C puzzle I created recently.  It is a silly
  one but you might find it amusing.
</p>
<pre>
<code>#include &lt;stdio.h&gt;

int main()
{
    https://susam.net/
    printf("hello, world\n");
    return 0;
}</code>
</pre>
<p>
  This code compiles and runs successfully.
</p>
<pre>
<samp>$ <kbd>c99 hello.c &amp;&amp; ./a.out</kbd>
hello, world</samp>
</pre>
<p>
  However, the
  <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf">C99
  standard</a> does not mention anywhere that a URL is a valid
  syntactic element in C.  How does this code work then?
</p>
<p>
  <em><strong>Update on 04 Jun 2011:</strong> The puzzle has been
  solved in the <a href="comments/url-in-c.html">comments</a> section.
  If you want to think about the problem before you see the solutions,
  this is a good time to pause and think about it.  There are spoilers
  ahead.</em>
</p>
<p>
  The code works fine because <code>https:</code> is a label and
  <code>//</code> following it begins a comment.  In case, you are
  wondering if <code>//</code> is indeed a valid comment in C, yes, it
  is, since C99.  Download the
  <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf">C99
  standard</a>, go to section 6.4.9 (Comments) and read the second
  point which mentions this:
</p>
<blockquote>
  Except within a character constant, a string literal, or a comment,
  the characters <code>//</code> introduce a comment that includes all
  multibyte characters up to, but not including, the next new-line
  character.  The contents of such a comment are examined only to
  identify multibyte characters and to find the terminating new-line
  character.
</blockquote>
<!-- ### -->
<p>
  <a href="https://susam.net/url-in-c.html">Read on website</a> |
  <a href="https://susam.net/tag/c.html">#c</a> |
  <a href="https://susam.net/tag/programming.html">#programming</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Missing Digit Puzzle</title>
<link>https://susam.net/missing-digit-puzzle.html</link>
<guid isPermaLink="false">fthed</guid>
<pubDate>Sat, 14 May 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  There is a 10-digit multiple of 234.  9 of its digits in ascending
  order are: 0, 1, 1, 2, 3, 4, 5, 7 and 9.  What is the missing digit?
</p>
<p>
  See the comments page for the solution.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/missing-digit-puzzle.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Ternary Operator Puzzle</title>
<link>https://susam.net/ternary-operator-puzzle.html</link>
<guid isPermaLink="false">kaibc</guid>
<pubDate>Wed, 06 Apr 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  What is the shortest statement you can write in the C or C++
  programming language to express the following statement?
</p>
<pre><code>a = (a == 0 ? 0 : 1);</code></pre>
<p>
  See the comments page for the solution.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/ternary-operator-puzzle.html">Read on website</a> |
  <a href="https://susam.net/tag/c.html">#c</a> |
  <a href="https://susam.net/tag/programming.html">#programming</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>From Out Shuffles to Multiplicative Order</title>
<link>https://susam.net/from-out-shuffles-to-multiplicative-order.html</link>
<guid isPermaLink="false">vnpml</guid>
<pubDate>Wed, 23 Mar 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<div style="display: none">
  \( \gdef\ord{\operatorname{ord}} \)
</div>
<h2 id="out-shuffles">Out Shuffles<a href="#out-shuffles"></a></h2>
<p>
  A <em>perfect riffle shuffle</em> of a deck of cards involves
  splitting the deck into two halves (one in each hand) and then
  alternately dropping one card from each half till all cards have
  fallen.  If the shuffling is done in such a manner that the bottom
  and the top cards remain preserved at their positions, then it is
  an <em>out shuffle</em>.
</p>
<h2 id="problem">Problem<a href="#problem"></a></h2>
<p>
  Here is a problem that a colleague asked me recently while
  discussing shuffling techniques:
</p>
<div class="highlight">
  How many out shuffles do we need to perform on a deck of 52 cards to
  return the deck to its initial state?
</div>
<h2 id="solution">Solution<a href="#solution"></a></h2>
<p>
  The solution to this problem is rather long, so it has been split
  into three parts below.
</p>
<h3 id="part-1">Part 1: Congruence Relation<a href="#part-1"></a></h3>
<p>
  Let us assume that there are \( n \) cards where \( n \) is a
  positive even integer.  Let us denote these cards as \( c_0, c_1,
  \dots, c_{n-1} \) where \( c_0 \) is the card at index \( 0 \) (top
  of the deck), \( c_{n - 1} \) is the card at index \( n - 1 \)
  (bottom of the deck) and \( c_i \) is the card at index \( i \)
  where \( 0 \le i \le n - 1.  \)
</p>
<p>
  For example, if we have \( 8 \) cards, then the cards are denoted as

  \[
    c_0, c_1, c_2, c_3, c_4, c_5, c_6, c_7.
  \]

  After the first out shuffle, these cards are now in this order:

  \[
    c_0, c_4, c_1, c_5, c_2, c_6, c_3, c_7.
  \]
</p>
<p>
  From the problem description and the example above, we see that
  after a single out shuffle, a card at index \( i \) moves to index
  \( 2i \bmod (n - 1) \) for \( 0 \le i \lt n - 1 \) and the card at
  index \( n - 1 \) remains at the same place.
</p>
<p>
  After \( m \) shuffles a card at index \( i \) moves to index \(
  (2^m i) \bmod (n - 1) \) for \( 0 \le i \lt n - 1.  \)  The card at
  index \( n - 1 \) always remains at the same place.
</p>
<p>
  The solution to the problem then is the smallest positive integer \(
  m \) such that

  \[
    2^m i \equiv i \pmod{n - 1}.
  \]

  for all integers \( i \) that satisfy the inequality \( 0 \le i \lt
  n - 1.  \)
</p>
<p>
  In modular arithmetic, we know that

  \[
    ac \equiv bc \pmod{n}
    \iff
    a \equiv b \pmod{n / \gcd(c, n)}.
  \]

  where \( a, \) \( b, \) \( c \) and \( n \) are integers.  Therefore

  \[
    2^m i \equiv i \pmod{n - 1}
    \iff
    2^m \equiv 1 \pmod{(n - 1) / \gcd(i, n - 1)}.
  \]

  Let \( F_{ni} = \frac{n - 1}{\gcd(i, n - 1)} \) where \( 0 \le i \lt
  n - 1.  \)  Now the above congruence relation can be written as

  \[
    2^m \equiv 1 \pmod{F_{ni}}.
  \]
</p>
<h3 id="part-2">Part 2: Multiplicative Order<a href="#part-2"></a></h3>
<p>
  The smallest positive integer \( m \) that satisfies the above
  congruence relation is known as the multiplicative order of \( 2 \)
  modulo \( F_{ni}.  \)  It is denoted as \( \ord_{F_{ni}}(2).  \)
</p>
<p>
  In general, given an integer \( a \) and a positive integer \( n \)
  with \( \gcd(a, n) = 1, \) the multiplicative order of \( a \)
  modulo \( n, \) denoted as \( \ord_{n}(a), \) is the smallest
  positive integer \( k \) such that

  \[
    a^k \equiv 1 \pmod{n}.
  \]

  In this problem, \( n \) is even, so \( n - 1 \) is odd as a result
  of which \( F_{ni} \) is also odd.  As a result, \( \gcd(2, F_{ni}) =
  1.  \)  Therefore, the smallest positive integer \( m \) that
  satisfies the congruence relation \( 2^m \equiv 1 \pmod{F_{ni}} \)
  is denoted as \( \ord_{F_{ni}}(2).  \)
</p>
<p>
  If \( n = 2, \) \( F_{n0} = F_{n1} = 1, \) therefore \( 2^m \equiv 1
  \pmod{F_{ni}} \) for \( 0 \le i \lt n - 1 \) and all positive
  integers \( m.  \)  This proves the trivial observation that when
  there are only two cards \( c_0 \) and \( c_1, \) they remain at
  index \( 0 \) and index \( 1 \) respectively, after any number of
  out shuffles, i.e. their positions do not change with out shuffles.
</p>
<h4 id="case-1">Case \( n \ge 4 \)<a href="#case-1"></a></h4>
<p>
  If \( n \ge 4, \) we know that there exists at least one integer
  between \( 1 \) and \( n - 1 \) that is coprime to \( n - 1 \)
  because \( \varphi(n) \ge 2 \) for \( n \ge 4 \) where
  \( \varphi(n) \) represents Euler's totient of \( n.  \)
</p>
<h5 id="subcase-1-1">Subcase \( i \) is coprime to \( n - 1 \)<a href="#subcase-1-1"></a></h5>
<p>
  For any arbitrary \( n \ge 4, \) let \( i \) be an integer that is
  coprime to \( n - 1 \) such that \( 1 \lt i \lt n - 1.  \)  Now \(
  \gcd(i, n - 1 ) = 1, \) so \( F_{ni} = \frac{n - 1}{\gcd(i, n - 1)}
  = n - 1.  \)  As a result, \( \ord_{F_{ni}}(2) = \ord_{n -
  1}({2}).  \)  This shows that any card at index \( i \) such that \(
  i \) is coprime to \( n - 1 \) requires a minimum of \( \ord_{n -
  1}(2) \) out shuffles to return to its initial place.
</p>
<h5 id="subcase-1-2">Subcase \( i \) is <em>not</em> coprime to \( n - 1 \)<a href="#subcase-1-2"></a></h5>
<p>
  For any arbitrary \( n \ge 4, \) now let us consider the case of a
  card at index \( i \) such that \( i \) is not coprime to
  \( n - 1.  \)  Since \( n - 1 \) is odd, we have \( \gcd(2, n - 1) =
  1.  \)  Therefore, by definition of multiplicative order,

  \[
    2^{\ord_{n - 1}(2)} \equiv 1 \pmod{n - 1}.
  \]

  Since \( F_{ni} \mid n - 1, \) we get,

  \[
    2^{\ord_{n - 1}(2)} \equiv 1 \pmod{F_{ni}}.
  \]

  This shows that a card at index \( i \) such that \( i \) is not
  coprime to \( n - 1 \) also return to its initial place after \(
  \ord_{n - 1}(2) \) out shuffles.  Actually, it takes only \(
  \ord_{F_{ni}}(2) \) out shuffles to return the card to its initial
  place.  But \( \ord_{F_{ni}}(2) \mid \ord_{n - 1}(2), \) so \(
  \ord_{n - 1}(2) = c \ord_{F_{ni}}(2) \) for some positive integer \(
  c.  \)  Therefore performing \( \ord_{n - 1}(2) \) out shuffles is
  same as repeating \( \ord_{F_{ni}}(2) \) out shuffles \( c \) times.
  Every \( \ord_{F_{ni}}(2) \) brings back the card to its initial
  position, so repeating it \( c \) times also brings it back to its
  initial position.
</p>
<p>
  We have shown that a card at index \( i \) such that \( i \) is
  coprime to \( n - 1 \) takes a minimum of \( \ord_{n - 1}(2) \) out
  shuffles to return to its initial place.  We have also shown that a
  card at other indices also return to its initial place after the
  same number of out shuffles.  Therefore, it takes a minimum of \(
  \ord_{n - 1}{2} \) out shuffles to return the deck of cards to its
  initial state.
</p>
<h4 id="case-2">Case \( n = 2 \)<a href="#case-2"></a></h4>
<p>
  When there are only \( 2 \) cards in the deck, every out shuffle
  trivially returns the deck to its initial state.  In other words, it
  takes only \( 1 \) out shuffle to return the deck to its initial
  state.  Indeed \( \ord_{n - 1}(2) = \ord_{1}(2) = 1.  \)
</p>
<p>
  We have now shown that for any positive even integer \( n, \) a deck
  of \( n \) cards returns to its initial state after \( \ord_{n -
  1}(2) \) out shuffles.
</p>
<h3 id="part-3">Part 3: Computing Multiplicative Order<a href="#part-3"></a></h3>
<p>
  For a deck of \( 52 \) cards, we have \( n = 52.  \)  A minimum of \(
  \ord_{51}(2) \) out shuffles are required to return the deck to its
  initial state.  To compute \( \ord_{51}(2) \) we first enumerate the
  powers of \( 2 \) modulo \( 51 \):

  \begin{alignat*}{2}
    2^0 &amp; \equiv 1  &amp;&amp; \pmod{51}, \\
    2^1 &amp; \equiv 2  &amp;&amp; \pmod{51}, \\
    2^2 &amp; \equiv 4  &amp;&amp; \pmod{51}, \\
    2^3 &amp; \equiv 8  &amp;&amp; \pmod{51}, \\
    2^4 &amp; \equiv 16 &amp;&amp; \pmod{51}, \\
    2^5 &amp; \equiv 32 &amp;&amp; \pmod{51}, \\
    2^6 &amp; \equiv 13 &amp;&amp; \pmod{51}, \\
    2^7 &amp; \equiv 26 &amp;&amp; \pmod{51}, \\
    2^8 &amp; \equiv 1  &amp;&amp; \pmod{51}.
  \end{alignat*}

  The smallest positive integer \( k \) such that \( 2^k \equiv 1
  \pmod{51} \) is 8, so \( \ord_51(2) = 8.  \)  We need \( 8 \) out
  shuffles to return a deck of \( 52 \) cards to its initial state.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/from-out-shuffles-to-multiplicative-order.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/combinatorics.html">#combinatorics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Polar Bear Puzzle</title>
<link>https://susam.net/polar-bear-puzzle.html</link>
<guid isPermaLink="false">hrcyc</guid>
<pubDate>Wed, 09 Mar 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  Alice asked Bob, "A bear walked 1 km south, then 1 km west, then 1
  km north and it was back at the point from where it started.  What
  colour was the bear most likely to be?"
</p>
<p>
  Bob thought for a while, could not arrive at an answer and gave up.
  Alice explained, "Well, the answer is white.  It is a polar bear.
  It is only when you start from the North Pole that after travelling
  1 km south, 1 km west and 1 km north you would end up at the point
  where you started."
</p>
<p>
  Bob replied, "That is an interesting solution.  Now that I
  understand your solution, I realise that there are other starting
  points apart from the North Pole where one could walk 1 km south,
  then 1 km west and then 1 km north to return to the starting point."
</p>
<p>
  Can you find all the other such starting points that Bob is talking
  about?
</p>
<p>
  See the comments page for the solution.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/polar-bear-puzzle.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Shrinking List Puzzle</title>
<link>https://susam.net/shrinking-list-puzzle.html</link>
<guid isPermaLink="false">ysrvs</guid>
<pubDate>Thu, 17 Feb 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  The first \( 9 \) natural numbers are given in a list.  You are
  supposed to select two numbers randomly from the list, call them \(
  x \) and \( y, \) remove them from the list and insert \( x + y + xy \)
  into the list.  You keep repeating this until you are left with only
  one number in the list.  Find the final number that is left in the
  list.
</p>
<p>
  See the comments page for the solution.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/shrinking-list-puzzle.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>From Diophantine Equation to Fermat's Last Theorem</title>
<link>https://susam.net/from-diophantine-equation-to-fermats-last-theorem.html</link>
<guid isPermaLink="false">sfcma</guid>
<pubDate>Wed, 12 Jan 2011 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  Here is a puzzle I created recently for my friends who love to
  indulge in recreational mathematics:
</p>
<div class="highlight">
  Find all integer solutions to the equation

  \[
    y^2 + 3 = \frac{x^3}{18}.
  \]
</div>
<p>
  <em>If you want to think about this puzzle, this is a good time to
  pause and think about it.  There are spoilers ahead.</em>
</p>
<p>
  It does not take long to realise that this is a Diophantine equation
  of the form \( a^n + b^n = c^n.  \)  Here is how the equation looks
  after rearranging the terms:

  \[
    x^3 = 18y^2 + 54.
  \]
</p>
<p>
  The right hand side is positive, so any \( x \) that satisfies this
  equation must also be positive, i.e. \( x \gt 0 \) must hold good
  for any solution \( x \) and \( y.  \)
</p>
<p>
  Also, if some \( y \) satisfies the equation, then \( -y \) also
  satisfies the equation because the right hand side value remains the
  same for both \( y \) and \( -y.  \)
</p>
<p>
  The right hand side is \( 2(9y^2 + 3^3).  \)  This is of the form \(
  2(3a^2b + b^3) \) where \( a = y \) and \( b = 3.  \)  Now \( 2(3a^2b
  + b^3) = (a + b)^3 - (a - b)^3.  \)  Using these details, we get

  \[
    x^3 = 18y^2 + 54 = 2(9y^2 + 3^3) = (y + 3)^3 - (y - 3)^3.
  \]

  Rearranging the terms, we get

  \[
    x^3 + (y - 3)^3 = (y + 3)^3.
  \]

  From Fermat's Last Theorem, we know that an equation of the form \(
  a^n + b^n = c^n \) does not have any solution for positive integers
  \( a, \) \( b, \) \( c \) and positive integer \( n \gt 2.  \)  We
  know that \( x \gt 0.  \)  Therefore \( y \gt 3 \) contradicts
  Fermat's Last Theorem.  Thus the inequality \( y \le 3 \) must hold
  good.  Further since for every solution \( x \) and \( y, \) there
  is also a solution \( x \) and \( -y, \) the inequality \( -y \le
  3 \) must also hold good.  Therefore values of \( x \) and \( y \)
  that satisfy the above equation must satisfy the following
  inequalities:

  \begin{align*}
    x \gt 0, \\
    -3 \le y \le 3.
  \end{align*}

  Since \( y \) must be one of the seven integers between \( -3 \) and
  \( 3, \) inclusive, we can try solving for \( x \) with each of
  these seven values of \( y.  \)  When we do so, we find that there
  are only two values of \( y \) for which we get integer solutions
  for \( x.  \)  They are \( y = 3 \) and \( y = -3.  \)  In both cases,
  we get \( x = 6.  \)  Therefore, the solutions to the given equation
  are:

  \[
    x = 6, \qquad y = \pm 3.
  \]
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/from-diophantine-equation-to-fermats-last-theorem.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/combinatorics.html">#combinatorics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Stack Overwriting Function</title>
<link>https://susam.net/stack-overwriting-function.html</link>
<guid isPermaLink="false">oijgw</guid>
<pubDate>Wed, 28 Jul 2010 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<h2 id="skipping-over-a-function-call">Skipping Over a Function Call<a href="#skipping-over-a-function-call"></a></h2>
<p>
  Here is a C puzzle that involves some analysis of the machine code
  generated from it followed by manipulation of the runtime stack.
  The solution to this puzzle is <em>implementation-dependent</em>.
  Here is the puzzle:
</p>
<div class="highlight">
<p>
  Consider this C code:
</p>
<pre>
<code>#include &lt;stdio.h&gt;

void f()
{
}

int main()
{
    printf("1\n");
    f();
    printf("2\n");
    printf("3\n");
    return 0;
}</code>
</pre>
<p>
  Define the function <code>f()</code> such that the output of the
  above code is:
</p>
<pre>
<samp>1
3</samp>
</pre>
<p>
  Printing <code>3</code> in <code>f()</code> and exiting is not
  allowed as a solution.
</p>
</div>
<p>
  <em>If you want to think about this problem, this is a good time to
  pause and think about it.  There are spoilers ahead.</em>
</p>
<p>
  The solution essentially involves figuring out what code we can
  place in the body of <code>f()</code> such that it causes the
  program to skip over the machine code generated for
  the <code>printf("2\n")</code> operation.  I'll share two solutions
  for two different implementations:
</p>
<ol>
  <li>
    gcc 4.3.2 on 64-bit Debian 5.0.3 running on 64-bit Intel Core 2
    Duo.
  </li>
  <li>
    Microsoft Visual Studio 2005 on 32-bit Windows XP running on
    64-bit Intel Core 2 Duo.
  </li>
</ol>
<h2 id="solution-for-gcc">Solution for GCC<a href="#solution-for-gcc"></a></h2>
<p>
  Let us first see step by step how I approached this problem for GCC.
  We add a statement <code>char a = 7;</code> to the function
  <code>f()</code>.  The code looks like this:
</p>
<pre>
<code>#include &lt;stdio.h&gt;

void f()
{
    char a = 7;
}

int main()
{
    printf("1\n");
    f();
    printf("2\n");
    printf("3\n");
    return 0;
}</code>
</pre>
<p>
  There is nothing special about the number <code>7</code> here.  We
  just want to define a variable in <code>f()</code> and assign some
  value to it.
</p>
<p>
  Then we compile the code and analyse the machine code generated for
  <code>f()</code> and <code>main()</code> functions.
</p>
<pre>
<samp>$ <kbd>gcc -c overwrite.c &amp;&amp; objdump -d overwrite.o</kbd>

overwrite.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;f&gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   <span class="hl">4:   c6 45 ff 07             movb   $0x7,-0x1(%rbp)</span>
   8:   c9                      leaveq
   9:   c3                      retq

000000000000000a &lt;main&gt;:
   a:   55                      push   %rbp
   b:   48 89 e5                mov    %rsp,%rbp
   e:   bf 00 00 00 00          mov    $0x0,%edi
  13:   e8 00 00 00 00          callq  18 &lt;main+0xe&gt;
  18:   b8 00 00 00 00          mov    $0x0,%eax
  1d:   e8 00 00 00 00          callq  22 &lt;main+0x18&gt;
  <span class="hl">22:   bf 00 00 00 00          mov    $0x0,%edi
  27:   e8 00 00 00 00          callq  2c &lt;main+0x22&gt;</span>
  2c:   bf 00 00 00 00          mov    $0x0,%edi
  31:   e8 00 00 00 00          callq  36 &lt;main+0x2c&gt;
  36:   b8 00 00 00 00          mov    $0x0,%eax
  3b:   c9                      leaveq
  3c:   c3                      retq</samp>
</pre>
<p>
  When <code>main()</code> calls <code>f()</code>, the microprocessor
  saves the return address (where the control must return to after
  <code>f()</code> is executed) in stack.  The line at offset
  <samp>1d</samp> in the listing above for <code>main()</code> is the
  call to <code>f()</code>.  After <code>f()</code> is executed, the
  instruction at offset <samp>22</samp> is executed.  Therefore the
  return address that is saved on stack is the address at which the
  instruction at offset
  <samp>22</samp> would be present at runtime.
</p>
<p>
  The instructions at offsets <samp>22</samp> and <samp>27</samp> are
  the instructions for the <code>printf("2\n")</code> call.  These are
  the instructions we want to skip over.  In other words, we want to
  modify the return address in the stack from the address of the
  instruction at offset <samp>22</samp> to that of the instruction at
  offset <samp>2c</samp>.  This is equivalent to skipping 10 bytes
  (0x2c - 0x22 = 10) of machine code or adding 10 to the return
  address saved in the stack.
</p>
<p>
  Now how do we get hold of the return address saved in the stack when
  <code>f()</code> is being executed?  This is where the variable
  <code>a</code> we defined in <code>f()</code> helps.  The instruction
  at offset <samp>4</samp> is the instruction generated for
  assigning <code>7</code> to the variable <code>a</code>.
</p>
<p>
  From the knowledge of how microprocessor works and from the machine
  code generated for <code>f()</code>, we find that the following
  sequence of steps are performed during the call to <code>f()</code>:
</p>
<ol>
  <li>
    The microprocessor saves the return address by pushing the content
    of RIP (instruction pointer) register into the stack.
  </li>
  <li>
    The function <code>f()</code> pushes the content of the RBP (base
    pointer) register into the stack.
  </li>
  <li>
    The function <code>f()</code> copies the content of the RSP (stack
    pointer) register to the RBP register.
  </li>
  <li>
    The function <code>f()</code> stores the byte value <code>7</code>
    at the memory address specified by the content of RBP minus 1.
    This achieves the assignment of the value <code>7</code> to the
    variable <code>a</code>.
  </li>
</ol>
<p>
  After <code>7</code> is assigned to the variable <code>a</code>, the
  stack is in the following state:
</p>
<table class="grid center textcenter">
  <tr>
    <th>Address</th>
    <th>Content</th>
    <th>Size (in bytes)</th>
  </tr>
  <tr>
    <td><code>&amp;a + 5</code></td>
    <td>Return address (old RIP)</td>
    <td>8</td>
  </tr>
  <tr>
    <td><code>&amp;a + 1</code></td>
    <td>Old base pointer (old RBP)</td>
    <td>8</td>
  </tr>
  <tr>
    <td><code>&amp;a</code></td>
    <td>Variable <code>a</code></td>
    <td>1</td>
  </tr>
</table>
<p>
  If we add 9 to the address of the variable <code>a</code>, i.e.
  <code>&amp;a</code>, we get the address where the return address is
  stored.  We saw earlier that if we increment this return address by
  10 bytes, it solves the problem.  Therefore here is the solution
  code:
</p>
<pre>
<code>#include &lt;stdio.h&gt;

void f()
{
    char a;
    (&amp;a)[9] += 10;
}

int main()
{
    printf("1\n");
    f();
    printf("2\n");
    printf("3\n");
    return 0;
}</code>
</pre>
<p>
  Finally, we compile and run this code and confirm that the solution
  works fine:
</p>
<pre>
<samp>$ <kbd>gcc overwrite.c &amp;&amp; ./a.out</kbd>
1
3</samp>
</pre>
<h2 id="solution-for-visual-studio">Solution for Visual Studio<a href="#solution-for-visual-studio"></a></h2>
<p>
  Now we will see another example solution, this time for Visual
  Studio 2005.
</p>
<p>
  Like before we define a variable <code>a</code> in <code>f()</code>.
  The code now looks like this:
</p>
<pre>
<code>#include &lt;stdio.h&gt;

void f()
{
    char a = 7;
}

int main()
{
    printf("1\n");
    f();
    printf("2\n");
    printf("3\n");
    return 0;
}</code>
</pre>
<p>
  Then we compile the code and analyse the machine code generated from
  it.
</p>
<pre>
<samp>C:\&gt;<kbd>cl overwrite.c</kbd>
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 14.00.50727.42
for 80x86
Copyright (C) Microsoft Corporation.  All rights reserved.

overwrite.c
Microsoft (R) Incremental Linker Version 8.00.50727.42
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:overwrite.exe
overwrite.obj

C:\&gt;<kbd>dumpbin /disasm overwrite.obj</kbd>
Microsoft (R) COFF/PE Dumper Version 8.00.50727.42
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file overwrite.obj

File Type: COFF OBJECT

_f:
  00000000: 55                 push        ebp
  00000001: 8B EC              mov         ebp,esp
  00000003: 51                 push        ecx
  <span class="hl">00000004: C6 45 FF 07        mov         byte ptr [ebp-1],7</span>
  00000008: 8B E5              mov         esp,ebp
  0000000A: 5D                 pop         ebp
  0000000B: C3                 ret
  0000000C: CC                 int         3
  0000000D: CC                 int         3
  0000000E: CC                 int         3
  0000000F: CC                 int         3
_main:
  00000010: 55                 push        ebp
  00000011: 8B EC              mov         ebp,esp
  00000013: 68 00 00 00 00     push        offset $SG2224
  00000018: E8 00 00 00 00     call        _printf
  0000001D: 83 C4 04           add         esp,4
  00000020: E8 00 00 00 00     call        _f
  <span class="hl">00000025: 68 00 00 00 00     push        offset $SG2225
  0000002A: E8 00 00 00 00     call        _printf
  0000002F: 83 C4 04           add         esp,4</span>
  00000032: 68 00 00 00 00     push        offset $SG2226
  00000037: E8 00 00 00 00     call        _printf
  0000003C: 83 C4 04           add         esp,4
  0000003F: 33 C0              xor         eax,eax
  00000041: 5D                 pop         ebp
  00000042: C3                 ret

  Summary

           B .data
          57 .debug$S
          2F .drectve
          43 .text</samp>
</pre>
<p>
  Just like in the previous <code>objdump</code> listing, in this
  listing too, the instruction at offset <code>4</code> shows where
  the variable <code>a</code> is allocated and the instructions at
  offsets <code>25</code>, <code>2A</code> and <code>2F</code> show
  the instructions we want to skip, i.e. instead of returning to the
  instruction at offset <code>25</code>, we want the microprocessor to
  return to the instruction at offset <code>32</code>.  This involves
  skipping 13 bytes (0x32 - 0x25 = 13) of machine code.
</p>
<p>
  Unlike the previous <code>objdump</code> listing, in this listing we
  see that the Visual Studio I am using is a 32-bit on, so it
  generates machine code to use 32-bit registers like EBP, ESP, etc.
  Thus the stack looks like this after <code>7</code> is assigned to
  the variable
  <code>a</code>:
</p>
<table class="grid center textcenter">
  <tr>
    <th>Address</th>
    <th>Content</th>
    <th>Size (in bytes)</th>
  </tr>
  <tr>
    <td><code>&amp;a + 5</code></td>
    <td>Return address (old EIP)</td>
    <td>4</td>
  </tr>
  <tr>
    <td><code>&amp;a + 1</code></td>
    <td>Old base pointer (old EBP)</td>
    <td>4</td>
  </tr>
  <tr>
    <td><code>&amp;a</code></td>
    <td>Variable <code>a</code></td>
    <td>1</td>
  </tr>
</table>
<p>
  If we add 5 to the address of the variable <code>a</code>, i.e.
  <code>&amp;a</code>, we get the address where the return address is
  stored.  Here is the solution code:
</p>
<pre>
<code>#include &lt;stdio.h&gt;

void f()
{
    char a;
    (&amp;a)[5] += 13;
}

int main()
{
    printf("1\n");
    f();
    printf("2\n");
    printf("3\n");
    return 0;
}</code>
</pre>
<p>
  Finally, we compile and run this code and confirm that the solution
  works fine:
</p>
<pre>
<samp>C:\&gt;<kbd>cl /w overwrite.c</kbd>
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 14.00.50727.42
for 80x86
Copyright (C) Microsoft Corporation.  All rights reserved.

overwrite.c
Microsoft (R) Incremental Linker Version 8.00.50727.42
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:overwrite.exe
overwrite.obj

C:\&gt;<kbd>overwrite.exe</kbd>
1
3</samp>
</pre>
<h2 id="conclusion">Conclusion<a href="#conclusion"></a></h2>
<p>
  The machine code that the compiler generates for a given C code is
  highly dependent on the implementation of the compiler.  In the two
  examples above, we have two different solutions for two different
  compilers.
</p>
<p>
  Even with the same brand of compiler, the way it generates machine
  code for a given code may change from one version of the compiler to
  another.  Therefore, it is very likely that the above solution would
  not work on another system (such as your system) even if you use the
  same compiler that I am using in the examples above.
</p>
<p>
  However, we can arrive at the solution for an implementation of the
  compiler by determining what number to add to <code>&amp;a</code> to
  get the address where the return address is saved on stack and what
  number to add to this return address to make it point to the
  instruction we want to skip to after <code>f()</code> returns.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/stack-overwriting-function.html">Read on website</a> |
  <a href="https://susam.net/tag/c.html">#c</a> |
  <a href="https://susam.net/tag/programming.html">#programming</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Illiteracy and Digital Weighing Scale</title>
<link>https://susam.net/illiteracy-and-digital-weighing-scale.html</link>
<guid isPermaLink="false">wrcsp</guid>
<pubDate>Tue, 06 Jul 2010 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  Here is a real life problem from a silica bricks factory in a small
  industrial town in India.  There are illiterate workers who cannot
  identify decimal digits.  The management team of the factory is
  trying to figure if there is a way for these workers to operate a
  digital weighing scale to fill buckets with a certain mass of a
  given material.  For example, they may be asked to fill 5.3&nbsp;kg
  of a certain material in the bucket, i.e. decimal fractions are
  involved.
</p>
<p>
  If the factory were using a beam balance, this would have been an
  easy problem to solve.  The workers could then place the required
  weight in one pan and keep pouring the material in the other pan
  until the beam appears to be balanced.
</p>
<p>
  However this factory uses a digital weighing scale which involves
  recognising decimal digits to read the measurement.  What do you
  think is the easiest way to train the workers to do their job
  without having to teach them how to count?
</p>
<p>
  I have a solution in mind which would involve configuring the
  digital weighing scale in a certain way for every measurement the
  workers have to make.  I will propose this solution to the
  management team of the factory.  But I would like to know any
  suggestions you have and take them into account as well before
  proposing my solution.  I will also share the solution I have in
  mind after learning about your suggestions.
</p>
<hr>
<p>
  <strong>Update on 08&nbsp;July&nbsp;2010:</strong> Prunthaban has
  suggested a solution in the
  <a href="comments/illiteracy-and-digital-weighing-scale.html#5">comments</a>
  section which is pretty much what I had in mind too.  I will propose
  this solution to the factory.  The solution works like this: Say the
  worker has to fill 5.3 kg of a certain material into the bucket.  A
  literate supervisor first places 5.3&nbsp;kg of that material on the
  weighing scale.  The instrument now shows "5.3&nbsp;kg" on its
  display.  Now the remainder of the solution assumes that the digital
  weighing balance has a calibration wheel to calibrate the
  instrument.  The supervisor turns the calibration wheel until the
  display shows "0.0"&nbsp;kg while the 5.3&nbsp;kg of material is
  still placed on it.  Now the material is removed from the balance and
  the display shows "-5.3&nbsp;kg".  Now all a worker needs to do is
  pour the given material on this calibrated balance until the display
  shows "0.0&nbsp;kg".  As long as the workers can be taught to
  recognise the digit "0", this solution should work fine.
</p>
<hr>
<p>
  <strong>Update on 05&nbsp;Aug&nbsp;2010:</strong> The above solution
  was successfully implemented in OCL India Limited, the silica bricks
  factory where this problem was faced.  The digital weighing balance
  involved in the problem indeed had a calibration wheel, so the above
  solution worked for them.  Thank you, Prunthaban and others who
  participated in this discussion.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/illiteracy-and-digital-weighing-scale.html">Read on website</a> |
  <a href="https://susam.net/tag/miscellaneous.html">#miscellaneous</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>ADAC and HE Puzzles from GEB</title>
<link>https://susam.net/adac-and-he-puzzles-from-geb.html</link>
<guid isPermaLink="false">yjsjz</guid>
<pubDate>Sat, 16 May 2009 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  I have been reading
  <em><a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach"
  class="title">G&ouml;del, Escher, Bach: An Eternal Golden
  Braid</a></em> by Douglas R. Hofstadter for a few weeks.  The book
  follows an interesting format of alternating between chapters and
  dialogues between imaginary charaters.  In the words of the author:
</p>
<blockquote>
  The long and the short of it is that I eventually decided - but this
  took many months - that the optimal structure would be a strict
  alternation between chapters and dialogues.  Once that was clear,
  then I had the joyous task of trying to pinpoint the most crucial
  ideas that I wanted to get across to my readers and then somehow
  embodying them in both the form and the content of fanciful, often
  punning dialogues between Achilles and the Tortoise (plus a few new
  friends).
</blockquote>
<p>
  After the second chapter (Chapter II: Meaning and Form in
  Mathematics) there is a dialogue between Achilles and the Tortoise
  on telephone.  The title of the dialogue is <em>Sonata for
  Unaccompanied Achilles</em>.  The text shows the transcript of only
  one end of the call, only what Achilles speaks.  The Tortoise is at
  the far end of the call.  The sentences spoken by the Tortoise at
  the other end are not present in the text.  This makes the reading
  experience very interesting as we keep guessing about what is going
  on at the other end.
</p>
<p>
  It starts in this manner:
</p>
<blockquote>
  <em>Achilles:</em> Hello, this is Achilles.<br>
  <em>Achilles:</em> Oh, hello, Mr. T. How are you?<br>
  <em>Achilles:</em> A torticollis?  Oh, I'm sorry to hear it.  Do you
  have any idea what caused it?
</blockquote>
<p>
  As the dialogue proceeds, they share a few puzzles.  Here is the
  first one from the Tortoise.
</p>
<blockquote>
  <em>Achilles:</em> A word with the letters 'A', 'D', 'A', 'C'
  consecutively inside it &hellip; Hmm &hellip; What about
  "abracadabra"?<br>
  <em>Achilles:</em> True, "ADAC" occurs backwards, not forwards, in
  that word.<br>
  <em>Achilles:</em> Hours and hours?  It sounds like I'm in for a
  long puzzle, then.  Where did you hear this infernal riddle?
</blockquote>
<p>
  Here is the second puzzle from Achilles:
</p>
<blockquote>
  <em>Achilles:</em> Say, I once heard a word puzzle a little bit like
  this one.  Do you want to hear it?  Or would it just drive you
  further into distraction?<br>
  <em>Achilles:</em> I agree - can't do any harm.  Here it is: What's
  a word that begins with the letters "HE" and also ends with
  "HE"?<br>
  <em>Achilles:</em> Very ingenious - but that's almost cheating.
  It's certainly not what I meant!<br>
  <em>Achilles:</em> Of course you're right - it fulfills the
  conditions, but it's a sort of "degenerate" solution.  There's
  another solution which I had in mind.<br>
  <em>Achilles:</em> That's exactly it!  How did you come up with it
  so fast?<br>
  <em>Achilles:</em> So here's a case where having a headache actually
  might have helped you, rather than hindering you.  Excellent!  But
  I'm still in the dark on your "ADAC" puzzle.
</blockquote>
<p>
  <em>If you want to think about these puzzles, this is a good time to
  pause and think about them.  There are spoilers ahead.</em>
</p>
<p>
  It did not take much time for me to solve the puzzle because I
  cheated with the word list file available on Linux distributions.
  Here is what I found with my Debian 5.0 (lenny) system:
</p>
<pre>
<samp>$ <kbd>grep 'adac' /usr/share/dict/words</kbd>
headache
headache's
headaches
$ <kbd>grep '^he.*he$' /usr/share/dict/words</kbd>
headache
heartache</samp>
</pre>
<p>
  The answers to both puzzles seem to be "HEADACHE".  Take another
  look at the last sentence in the dialogue above.  It makes sense now
  as Achilles says that having a <em>headache</em> might have helped
  the Tortoise.
</p>
<p>
  Later in the dialogue the Tortoise offers <em>figure</em> and
  <em>ground</em> as hints to the "ADAC" puzzle.
</p>
<blockquote>
  <em>Achilles:</em> Well, normally I don't like hints, but all right.
  What's your hint?<br>
  <em>Achilles:</em> I don't know what you mean by "figure" and
  "ground" in this case.<br>
  <em>Achilles:</em> Certainly I know Mosaic II!  I know ALL of
  Escher's works.  After all, he's my favorite artist.  In any case,
  I've got a print of Mosaic II hanging on my wall, in plain view from
  here.<br>
  <em>Achilles:</em> Yes, I see all the black animals.<br>
  <em>Achilles:</em> Yes, I also see how their "negative" space -
  what's left out - defines the white animals.<br>
  <em>Achilles:</em> So THAT's what you mean by "figure" and "ground".
  But what does that have to do with the "ADAC" puzzle?<br>
  <em>Achilles:</em> Oh, this is too tricky to me.  I think I'M
  starting to get a headache.
</blockquote>
<p>
  The famous painting discussed in the dialogue can be found
  here: <a href="https://www.wikiart.org/en/m-c-escher/mosaic-ii">https://www.wikiart.org/en/m-c-escher/mosaic-ii</a>.
  We can see how the black animals form the <em>figure</em> (the
  positive space) and how the background or <em>ground</em> (the
  negative space) beautifully fits all the white animals.
</p>
<p>
  The <em>figure</em> and <em>ground</em> in hints make sense now.
  The first puzzle has "ADAC" in the question.  Let us consider "ADAC"
  as the figure or the positive space.  If we remove "ADAC" from
  "HEADACHE", we are left with the ground or negative space, which
  consists of "HE" and "HE" at the beginning and the end of the word.
  The <em>figure</em> is used in the first puzzle and
  the <em>ground</em> is used in the second puzzle.
</p>
<p>
  By the way, what is the first answer from the Tortoise that Achilles
  finds very ingenious but degenerate?  I believe, it is "HE" as this
  word both begins and ends with "HE".
</p>
<p>
  The funny thing about this dialogue is that both of them asked two
  puzzles to each other without knowing that the answers to them were
  the same.  A similar thing happened to me when a colleague of mine
  and I challenged each other with combinatorics puzzles.  See this
  blog post for the story:
  <a href="combinatorics-coincidence.html">Combinatorics Coincidence</a>.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/adac-and-he-puzzles-from-geb.html">Read on website</a> |
  <a href="https://susam.net/tag/miscellaneous.html">#miscellaneous</a> |
  <a href="https://susam.net/tag/book.html">#book</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Combinatorics Coincidence</title>
<link>https://susam.net/combinatorics-coincidence.html</link>
<guid isPermaLink="false">gfhlc</guid>
<pubDate>Sun, 14 Sep 2008 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<h2 id="combinatorics-for-fun">Combinatorics for Fun<a href="#combinatorics-for-fun"></a></h2>
<p>
  At my current workplace, there are several engineers who have an
  affinity for combinatorics.  As a result, discussions about
  combinatorics problems often occur at the cafeteria.  Probability
  theory is another popular topic of discussion.  Of course, often
  combinatorics and probability theory go hand in hand.
</p>
<h2 id="recurrence-relation">Recurrence Relation<a href="#recurrence-relation"></a></h2>
<p>
  At the cafeteria one day, I joined in on a conversation about
  combinatorics problems.  During the conversation, I happened to
  share the following problem:
</p>
<div class="highlight">
  <p>
    For integers \( n \ge 1 \) and \( k \ge 1, \)

    \[
      f_k(n) =
      \begin{cases}
        n                       &amp; \text{if } k = 1, \\
        \sum_{i=1}^n f_{k-1}(i) &amp; \text{if } k \ge 2.
      \end{cases}
    \]

    Find a closed-form expression for \( f_k(n).  \)
  </p>
</div>
<h2 id="nested-loops">Nested Loops<a href="#nested-loops"></a></h2>
<p>
  Soon after I shared the above problem, a colleague of mine shared
  this problem with me:
</p>
<div class="highlight">
  <p>
    Consider the following pseudocode with <code>k</code> nested
    loops:
  </p>
<pre>
<code>x = 0
for c<sub>1</sub> in 0 to (n - 1):
    for c<sub>2</sub> in 0 to (c<sub>1</sub> - 1):
        ...
            for c<sub>k</sub> in 0 to (c<sub>k-1</sub> - 1):
                x = x + 1</code>
</pre>
  <p>
    What is the final value of <code>x</code> after the outermost loop
    terminates?
  </p>
</div>
<h2 id="coincidence">Coincidence<a href="#coincidence"></a></h2>
<p>
  With one problem each, we went back to our desks.  As I began
  solving the <em>nested loops</em> problem shared by my colleague, I
  realised that the solution to his problem led me to
  the <em>recurrence relation</em> in the problem I shared with him.
</p>
<p>
  In the <em>nested loops</em> problem, if \( k = 1, \) the final
  value of \( x \) after the loop terminates is \( x = n.  \)  This is
  also the value of \( f_1(n).  \)
</p>
<p>
  If \( k = 2, \) the inner loop with counter \( c_2 \) runs once when
  \( c_1 = 0, \) twice when \( c_1 = 1 \) and so on.  When the loop
  terminates, \( x = 1 + 2 + \dots + n.  \)  Note that this series is
  same as \( f_2(n) = f_1(1) + f_1(2) + \dots + f_1(n).  \)
</p>
<p>
  Extending this argument, we now see that for any \( k \ge 1, \) the
  final value of \( x \) is

  \[
    f_k(n) = f_{k-1}(1) + f_{k-1}(2) + \dots + f_{k-1}(n).
  \]

  In other words, the solution to his <em>nested loops</em> problem is
  the solution to my <em>recurrence relation</em> problem.  It was an
  interesting coincidence that the problems we shared with each other
  had the same solution.
</p>
<h2 id="closed-form-expression">Closed-Form Expression<a href="#closed-form-expression"></a></h2>
<p>
  The closed form expression for the recurrence relation is

  \[
    f_k(n) = \binom{n + k - 1}{k}.
  \]

  It is quite easy to prove this using the principle of mathematical
  induction.  Since we know that this is also the result of
  the <em>nested loops</em> problem, we can also arrive at this result
  by another way.
</p>
<p>
  In the <em>nested loops</em> problem, the following inequalities are
  always met due to the loop conditions:

  \[
    n - 1 \ge c_1 \ge c_2 \ge \dots \ge c_k \ge 0.
  \]

  The variables \( c_1, c_2, \dots, c_k \) take all possible
  arrangements of integer values that satisfy the above inequalities.
  If we find out how many such arrangements are there, we will know
  how many times the variable \( x \) is incremented.
</p>
<p>
  Let us consider \( n - 1 \) similar balls and \( k \) similar
  sticks.  For every possible permutation of these balls and sticks,
  if we count the number of balls to the right of the \( i \)th stick
  where \( 1 \le i \le k, \) we get a number that the variable \( c_i \)
  holds in some iteration of the \( i \)th loop.  Therefore the
  variable \( c_i \) is represented as the number of balls lying on
  the right side of the \( i \)th stick.
</p>
<p>
  The above argument holds good because the number of balls on the
  right side of the first stick does not exceed \( n - 1, \) the
  number of balls on the right side of the second stick does not
  exceed the number of balls on the right side of the first stick and
  so on.  Thus the inequalities mentioned earlier are always
  satisfied.  Also, any set of valid values for \( c_1, c_2, \dots,
  c_k \) can be represented as an arrangement of these sticks and
  balls.
</p>
<p>
  The number of permutations of \( n - 1 \) similar balls and \( k \)
  similar sticks is

  \[
    \frac{(n + k - 1)!}{(n - 1)! \, k!} = \binom{n + k - 1}{k}.
  \]

  This closed-form expression is the solution to both the
  <em>recurrence relation</em> problem and the <em>nested loops</em>
  problem.
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/combinatorics-coincidence.html">Read on website</a> |
  <a href="https://susam.net/tag/mathematics.html">#mathematics</a> |
  <a href="https://susam.net/tag/combinatorics.html">#combinatorics</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>Obfuscated Main</title>
<link>https://susam.net/obfuscated-main.html</link>
<guid isPermaLink="false">hdzwp</guid>
<pubDate>Sun, 02 Nov 2003 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  I have been running a mailing list called <em>ncoders</em> on Yahoo
  Groups for the past few months.  I created it to host discussions on
  computers, programming and network protocols among university
  students.  There are currently about 150 students from various
  universities across the world on the list.  A few weeks ago, someone
  posted a C programming puzzle to the group.  The puzzle asked
  whether it was possible to write a C program such that the
  <code>main()</code> function <em>does not seem to appear</em> in the
  code.  Here's a solution I came up with, which involves obfuscating
  the identifier <code>main</code> using preprocessor macros and
  the <code>##</code> token-pasting operator.
</p>
<pre>
<code>#include &lt;stdio.h&gt;

#define decode(s,t,u,m,p,e,d) m ## s ## u ## t
#define begin decode(a,n,i,m,a,t,e)

int begin()
{
    printf("Stumped?\n");
}</code>
</pre>
<p>
  This program compiles and runs successfully.  Here is the output:
</p>
<pre><samp>Stumped?</samp></pre>
<p>
  Let me explain how this code works.  When the C preprocessor runs on
  this code, the following preprocessing steps occur:
</p>
<ul>
  <li>
    <code>begin</code> is replaced with <code>decode(a,n,i,m,a,t,e)</code>,
  </li>
  <li>
    <code>decode(a,n,i,m,a,t,e)</code> is replaced with <code>m ## a
    ## i ## n</code> and
  </li>
  <li>
    <code>m ## a ## i ## n</code> is replaced with <code>main</code>.
  </li>
</ul>
<p>
  Thus <code>begin()</code> is replaced with <code>main()</code>.
</p>
<p>
  <strong>Update on 31 Jul 2007:</strong> Although the mailing list
  referred to in this post no longer exists, this tiny piece of code
  seems to have survived on the web.  A
  <a href="https://www.google.com/search?q=%22decode%28s%2Ct%2Cu%2Cm%2Cp%2Ce%2Cd%29%22">quick
  search</a> shows so many occurrences of this code on the web.  It is
  quite surprising to me that a rather silly piece of code written
  during a Sunday afternoon to solve an equally silly puzzle has been
  the subject of much discussion!
</p>
<!-- ### -->
<p>
  <a href="https://susam.net/obfuscated-main.html">Read on website</a> |
  <a href="https://susam.net/tag/c.html">#c</a> |
  <a href="https://susam.net/tag/programming.html">#programming</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>
<item>
<title>C Quine</title>
<link>https://susam.net/c-quine.html</link>
<guid isPermaLink="false">psabp</guid>
<pubDate>Sun, 19 Oct 2003 00:00:00 +0000</pubDate>
<description>
<![CDATA[
<p>
  A quine is a computer program that produces an exact copy of its own
  source code as its output.  It must not consume any input, so tricks
  involving reading its own source code and printing it are not
  permitted.
</p>
<h2 id="classic-quine">The Classic Quine<a href="#classic-quine"></a></h2>
<p>
  Here is a classic quine I came across a few days ago in a mailing
  list:
</p>
<pre><code>main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34);}";printf(s,34,s,34);}</code></pre>
<p>
  This program is written in K&amp;R C.  The current version of GCC
  compiles it fine.  It is a valid quine on ASCII machines because
  this program uses the integer code <code>34</code> to print the
  quotation mark (<code>"</code>) character.  This will be explained
  further in the next section.  On another implementation of the C
  compiler which does not use ASCII code for the quotation mark
  character, the program needs to be modified to the use the correct
  code.
</p>
<p>
  Here are some commands that demonstrate the quine:
</p>
<pre>
<samp>$ <kbd>printf '%s' 'main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34);}";printf(s,34,s,34);}' &gt; quine.c</kbd>
$ <kbd>cc quine.c &amp;&amp; ./a.out &gt; out.txt &amp;&amp; diff quine.c out.txt</kbd>
$ <kbd>cat quine.c; echo</kbd>
main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34);}";printf(s,34,s,34);}
$ <kbd>./a.out</kbd>
main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34);}";printf(s,34,s,34);}</samp>
</pre>
<p>
  The source code of this quine does not end with a newline.
  The <code>-n</code> option of GNU echo ensures that the source code
  file is created without a terminating newline.
</p>
<h2 id="close-look-at-classic-quine">Close Look at the Classic Quine<a href="#close-look-at-classic-quine"></a></h2>
<p>
  Let us take a close look at how the quine introduced in the previous
  section works.  Let us add some newlines in the source code of this
  quine for the sake of clarity.
</p>
<pre>
<code>main()
{
    char*s="main(){char*s=%c%s%c;printf(s,34,s,34);}";
    printf(s,34,s,34);
}</code>
</pre>
<p>
  This is almost the same program presented in the previous section.
  Only a few newlines have been added to it to make the program easier
  to read.
</p>
<p>
  We can see that the <code>printf</code> call uses the
  string <code>s</code> as the format string.  The format string
  contains three conversion specifications:
  <code>%c</code>, <code>%s</code> and <code>%c</code>.  The arguments
  for these conversions are: <code>34</code>, the string
  <code>s</code> itself and <code>34</code> once again.  Note
  that <code>34</code> is the ASCII code for the quotation mark
  character (<code>"</code>).  With that in mind, let us now construct
  the output of the <code>printf</code> call in a step-by-step manner.
</p>
<p>
  The initial portion of the output consists of the format string from
  the beginning up to, but not including, the first conversion
  specification copied unchanged to the output stream.  Here it is:
</p>
<pre><samp>main(){char*s=</samp></pre>
<p>
  Then the first conversion specification <code>%c</code> is
  processed, the corresponnding argument <code>34</code> is taken and
  a quotation mark is printed like this:
</p>
<pre><samp>"</samp></pre>
<p>
  Then the second conversion specification <code>%s</code> is
  processed.  The corresponding argument is the string <code>s</code>
  itself, so the entire string is printed like this:
</p>
<pre><samp>main(){char*s=%c%s%c;printf(s,34,s,34);}</samp></pre>
<p>
  Then the third conversion specification <code>%c</code> is
  processed.  The corresponding argument is <code>34</code> again, so
  once again a quotation mark is printed like this:
</p>
<pre><samp>"</samp></pre>
<p>
  Finally, the rest of the format string is copied unchanged to
  produce the following output:
</p>
<pre><samp>;printf(s,34,s,34);}</samp></pre>
<p>
  Here are all the five parts of the output presented next to each
  other:
</p>
<pre><samp>main(){char*s=</samp></pre>
<pre><samp>"</samp></pre>
<pre><samp>main(){char*s=%c%s%c;printf(s,34,s,34);}</samp></pre>
<pre><samp>"</samp></pre>
<pre><samp>;printf(s,34,s,34);}</samp></pre>
<p>
  Writing them all out in a single line, we get this:
</p>
<pre>
<samp>main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34);}";printf(s,34,s,34);}</samp>
</pre>
<p>
  This output matches the source code of the program thus confirming
  that our program is a quine.
</p>
<h2 id="classic-quine-with-terminating-newline">Classic Quine With Terminating Newline<a href="#classic-quine-with-terminating-newline"></a></h2>
<p>
  The source code of the classic quine presented above does not
  terminate with a newline.  I found that a little bothersome because
  I am used to always terminating my source code with a single
  trailing newline at the end.  So I decided to modify that quine a
  little to ensure that it always ends with a newline.  This is the
  quine I arrived at:
</p>
<pre><samp>main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34,10);}%c";printf(s,34,s,34,10);}</samp></pre>
<p>
  Compared to the quine in the previous sections, this one has an
  additional <code>%c</code> at the end of the formal string and the
  integer <code>10</code> as the corresponding argument to ensure that
  the output ends with a newline.  Here is a demonstration of this
  quine:
</p>
<pre>
<samp>$ <kbd>echo 'main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34,10);}%c";printf(s,34,s,34,10);}' &gt; quine.c</kbd>
$ <kbd>cc quine.c &amp;&amp; ./a.out &gt; out.txt &amp;&amp; diff quine.c out.txt</kbd>
$ <kbd>cat quine.c</kbd>
main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34,10);}%c";printf(s,34,s,34,10);}
$ <kbd>./a.out</kbd>
main(){char*s="main(){char*s=%c%s%c;printf(s,34,s,34,10);}%c";printf(s,34,s,34,10);}</samp>
</pre>
<h2 id="c89-quine">C89 Quine<a href="#c89-quine"></a></h2>
<p>
  The classic C quines presented above are written in K&amp;C.  They
  do not conform to the C standard.  However, with some modifications
  to the quines presented above, we can get a quine that conforms to
  the C89 standard:
</p>
<pre>
<code>#include &lt;stdio.h&gt;
int main(){char*s="#include &lt;stdio.h&gt;%cint main(){char*s=%c%s%c;printf(s,10,34,s,34,10);return 0;}%c";printf(s,10,34,s,34,10);return 0;}</code>
</pre>
<p>
  Here is a demonstration of this quine:
</p>
<pre>
<samp>$ <kbd>echo '#include &lt;stdio.h&gt;
int main(){char*s="#include &lt;stdio.h&gt;%cint main(){char*s=%c%s%c;printf(s,10,34,s,34,10);return 0;}%c";printf(s,10,34,s,34,10);return 0;}' &gt; quine.c</kbd>
$ <kbd>cc -std=c89 -Wall -Wextra -pedantic quine.c &amp;&amp; ./a.out &gt; out.txt &amp;&amp; diff quine.c out.txt</kbd>
$ <kbd>cat quine.c</kbd>
#include &lt;stdio.h&gt;
int main(){char*s="#include &lt;stdio.h&gt;%cint main(){char*s=%c%s%c;printf(s,10,34,s,34,10);return 0;}%c";printf(s,10,34,s,34,10);return 0;}
$ <kbd>./a.out</kbd>
#include &lt;stdio.h&gt;
int main(){char*s="#include &lt;stdio.h&gt;%cint main(){char*s=%c%s%c;printf(s,10,34,s,34,10);return 0;}%c";printf(s,10,34,s,34,10);return 0;}</samp>
</pre>
<!-- ### -->
<p>
  <a href="https://susam.net/c-quine.html">Read on website</a> |
  <a href="https://susam.net/tag/c.html">#c</a> |
  <a href="https://susam.net/tag/programming.html">#programming</a> |
  <a href="https://susam.net/tag/technology.html">#technology</a> |
  <a href="https://susam.net/tag/puzzle.html">#puzzle</a>
</p>
]]>
</description>
</item>


</channel>
</rss>
